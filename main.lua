-- Generated by Haxe 3.4.4
local _hx_array_mt = {
  __newindex = function(t,k,v)
    local len = t.length
    t.length =  k >= len and (k + 1) or len
    rawset(t,k,v)
  end
}

local function _hx_tab_array(tab,length)
  tab.length = length
  return setmetatable(tab, _hx_array_mt)
end

local function _hx_anon_newindex(t,k,v) t.__fields__[k] = true; rawset(t,k,v); end
local _hx_anon_mt = {__newindex=_hx_anon_newindex}
local function _hx_a(...)
  local __fields__ = {};
  local ret = {__fields__ = __fields__};
  local max = select('#',...);
  local tab = {...};
  local cur = 1;
  while cur < max do
    local v = tab[cur];
    __fields__[v] = true;
    ret[v] = tab[cur+1];
    cur = cur + 2
  end
  return setmetatable(ret, _hx_anon_mt)
end

local function _hx_e()
  return setmetatable({__fields__ = {}}, _hx_anon_mt)
end

local function _hx_o(obj)
  return setmetatable(obj, _hx_anon_mt)
end

local function _hx_new(prototype)
  return setmetatable({__fields__ = {}}, {__newindex=_hx_anon_newindex, __index=prototype})
end

local _hxClasses = {}
Int = (function() _hxClasses.Int = _hx_o({__fields__={__name__=true},__name__={"Int"}}); return _hxClasses.Int end)();
Dynamic = (function() 
_hxClasses.Dynamic = _hx_o({__fields__={__name__=true},__name__={"Dynamic"}}); return _hxClasses.Dynamic end)();
Float = (function() 
_hxClasses.Float = _hx_e(); return _hxClasses.Float end)();
Float.__name__ = {"Float"}
Bool = (function() 
_hxClasses.Bool = _hx_e(); return _hxClasses.Bool end)();
Bool.__ename__ = {"Bool"}
Class = (function() 
_hxClasses.Class = _hx_o({__fields__={__name__=true},__name__={"Class"}}); return _hxClasses.Class end)();
Enum = _hx_e();

local Array = _hx_e()
local Camera = _hx_e()
local Date = _hx_e()
local Debug = _hx_e()
local Action = _hx_e()
local InputState = _hx_e()
local GameInput = _hx_e()
local i18n = {}
i18n.I18n = _G.require("i18n")
local Language = _hx_e()
local Level = _hx_e()
local Log = _hx_e()
local WindowType = _hx_e()
local Main = _hx_e()
local Math = _hx_e()
local math = {}
math._Vec3 = {}
math._Vec3.Vec3_Impl_ = _hx_e()
local _Profiler = {}
_Profiler.SegmentColor_Impl_ = _hx_e()
local String = _hx_e()
local Std = _hx_e()
local haxe = {}
haxe.ds = {}
haxe.ds.GenericStack = _hx_e()
local Profiler = _hx_e()
local Reflect = _hx_e()
local Signal = _hx_e()
local StringBuf = _hx_e()
local StringTools = _hx_e()
local System = _hx_e()
local _Time = {}
_Time.ClockTime_Impl_ = _hx_e()
local GameTime = _hx_e()
local TimerAction = _hx_e()
local TimerScript = _hx_e()
local ValueType = _hx_e()
local Type = _hx_e()
local VirtualTile = _hx_e()
local WorldTile = _hx_e()
local World = _hx_e()
local Zone = _hx_e()
local actor = {}
actor.Actor = _hx_e()
actor.TweenState = _hx_e()
actor.TweenType = _hx_e()
local anim9 = {}
anim9.Anim9 = _G.require("anim9")
local backend = {}
backend._Gc = {}
backend._Gc.Gc_Impl_ = _hx_e()
backend.love = {}
backend.love.GameLoop = _hx_e()
backend.love.Gc = _hx_e()
backend.love.Window = _hx_e()
local collision = {}
collision.Collision = _hx_e()
collision.CollisionPacket = _hx_e()
collision.Response = _hx_e()
local components = {}
components.ShaderType = _hx_e()
components.CollisionType = _hx_e()
components.Drawable = _hx_e()
components.TrickState = _hx_e()
components.Player = _hx_e()
components.Rail = _hx_e()
components.Sound = _hx_e()
components.Transform = _hx_e()
components.TriggerState = _hx_e()
components.TriggerType = _hx_e()
components.Trigger = _hx_e()
local editor = {}
editor.EditTile = _hx_e()
editor.Editor = _hx_e()
editor.EntityList = _hx_e()
editor.HeightmapTerrain = _hx_e()
editor.UIPanelCategory = _hx_e()
editor.Panel = _hx_e()
editor.Prefab = _hx_e()
haxe.IMap = _hx_e()
haxe.Json = _hx_e()
haxe.Log = _hx_e()
haxe.crypto = {}
haxe.crypto.Crc32 = _hx_e()
haxe.ds.BalancedTree = _hx_e()
haxe.ds.TreeNode = _hx_e()
haxe.ds.EnumValueMap = _hx_e()
haxe.ds.GenericCell = _hx_e()
haxe.ds.ObjectMap = _hx_e()
haxe.ds.StringMap = _hx_e()
haxe.format = {}
haxe.format.JsonParser = _hx_e()
haxe.format.JsonPrinter = _hx_e()
haxe.io = {}
haxe.io.Bytes = _hx_e()
haxe.io.Eof = _hx_e()
local imgui = {}
imgui.ImGui = _G.require("imgui")
imgui.Input = _G.require("imgui")
imgui.MenuBar = _G.require("imgui")
imgui.Style = _G.require("imgui")
imgui.Widget = _G.require("imgui")
imgui.Window = _G.require("imgui")
local iqm = {}
iqm.Iqm = _G.require("iqm")
local lua = {}
lua.UserData = _hx_e()
local love3d = {}
love3d.Love3d = _G.require("love3d")
lua.Boot = _hx_e()
lua.Thread = _hx_e()
lua.PairTools = _hx_e()
math.Bounds = _hx_e()
math.Capsule = _hx_e()
math.Intersect = _hx_e()
math._Mat4 = {}
math._Mat4.Mat4_Impl_ = _hx_e()
math.Node = _hx_e()
math.Octree = _hx_e()
math.Plane = _hx_e()
math._Quat = {}
math._Quat.Quat_Impl_ = _hx_e()
math.Ray = _hx_e()
math.Triangle = _hx_e()
math.Utils = _hx_e()
math._Vec2 = {}
math._Vec2.Vec2_Impl_ = _hx_e()
math._Vec4 = {}
math._Vec4.Vec4_Impl_ = _hx_e()
local render = {}
render.Grass = _hx_e()
local systems = {}
systems.Animation = _hx_e()
systems.Audio = _hx_e()
systems.Hud = _hx_e()
systems.Loader = _hx_e()
systems.Movement = _hx_e()
systems.RailsHelper = _hx_e()
systems.PlayerController = _hx_e()
systems.Render = _hx_e()
systems.Trigger = _hx_e()
systems.WeatherSystem = _hx_e()
local ui = {}
ui.Anchor = _hx_e()
ui.Helpers = _hx_e()
ui.LogWindow = _hx_e()
ui.MainMenu = _hx_e()
local utils = {}
utils.AssertionFailure = _hx_e()
utils.CacheResource = _hx_e()

local _hx_bind, _hx_bit, _hx_staticToInstance, _hx_funcToField, _hx_maxn, _hx_print, _hx_apply_self, _hx_box_mr, _hx_bit_clamp, _hx_table, _hx_bit_raw

Array.new = {}
Array.__name__ = {"Array"}
Array.prototype = _hx_a(
  'join', function(self,sep) 
    local tbl = ({});
    local _gthis = self;
    local cur_length = 0;
    local i = _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self) 
      do return cur_length < _gthis.length end;
    end,next=function(self) 
      cur_length = cur_length + 1;
      do return _gthis[cur_length - 1] end;
    end});
    while (i:hasNext()) do 
      local i1 = i:next();
      _G.table.insert(tbl,Std.string(i1));
      end;
    do return _G.table.concat(tbl,sep) end
  end,
  'pop', function(self) 
    if (self.length == 0) then 
      do return nil end;
    end;
    local rawlength = _G.rawget(self,"length");
    local ret = _G.rawget(self,rawlength - 1);
    _G.rawset(self,"length",rawlength - 1);
    do return ret end
  end,
  'push', function(self,x) 
    _G.rawset(self,self.length,x);
    _G.rawset(self,"length",self.length + 1);
    do return _G.rawget(self,"length") end
  end,
  'slice', function(self,pos,_end) 
    if ((_end == nil) or (_end > self.length)) then 
      _end = self.length;
    else
      if (_end < 0) then 
        _end = _G.math.fmod((self.length - (_G.math.fmod(-_end, self.length))), self.length);
      end;
    end;
    if (pos < 0) then 
      pos = _G.math.fmod((self.length - (_G.math.fmod(-pos, self.length))), self.length);
    end;
    if ((pos > _end) or (pos > self.length)) then 
      do return _hx_tab_array({ }, 0) end;
    end;
    local ret = _hx_tab_array({ }, 0);
    local _g1 = pos;
    local _g = _end;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      ret:push(self[i]);
      end;
    do return ret end
  end,
  'sort', function(self,f) 
    local i = 0;
    local l = self.length;
    while (i < l) do 
      local swap = false;
      local j = 0;
      local max = (l - i) - 1;
      while (j < max) do 
        if (f(self[j],self[j + 1]) > 0) then 
          local tmp = self[j + 1];
          self[j + 1] = self[j];
          self[j] = tmp;
          swap = true;
        end;
        j = j + 1;
        end;
      if (not swap) then 
        break;
      end;
      i = i + 1;
      end;
  end,
  'splice', function(self,pos,len) 
    if ((len < 0) or (pos > self.length)) then 
      do return _hx_tab_array({ }, 0) end;
    else
      if (pos < 0) then 
        pos = self.length - (_G.math.fmod(-pos, self.length));
      end;
    end;
    local b = self.length - pos;
    len = (function() 
      local _hx_1
      if (Math.isNaN(len) or Math.isNaN(b)) then 
      _hx_1 = (0/0); else 
      _hx_1 = _G.math.min(len,b); end
      return _hx_1
    end )();
    local ret = _hx_tab_array({ }, 0);
    local _g1 = pos;
    local _g = pos + len;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      ret:push(self[i]);
      self[i] = self[i + len];
      end;
    local _g11 = pos + len;
    local _g2 = self.length;
    while (_g11 < _g2) do 
      _g11 = _g11 + 1;
      local i1 = _g11 - 1;
      self[i1] = self[i1 + len];
      end;
    local tmp = self;
    tmp.length = tmp.length - len;
    do return ret end
  end,
  'remove', function(self,x) 
    local _g1 = 0;
    local _g = self.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      if (self[i] == x) then 
        local _g3 = i;
        local _g2 = self.length - 1;
        while (_g3 < _g2) do 
          _g3 = _g3 + 1;
          local j = _g3 - 1;
          self[j] = self[j + 1];
          end;
        self[self.length - 1] = nil;
        self.length = self.length - 1;
        do return true end;
      end;
      end;
    do return false end
  end,
  'indexOf', function(self,x,fromIndex) 
    local _end = self.length;
    if (fromIndex == nil) then 
      fromIndex = 0;
    else
      if (fromIndex < 0) then 
        fromIndex = self.length + fromIndex;
        if (fromIndex < 0) then 
          fromIndex = 0;
        end;
      end;
    end;
    local _g1 = fromIndex;
    local _g = _end;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      if (x == self[i]) then 
        do return i end;
      end;
      end;
    do return -1 end
  end,
  'filter', function(self,f) 
    local _g = _hx_tab_array({ }, 0);
    local _g1 = 0;
    local _g2 = self;
    while (_g1 < _g2.length) do 
      local i = _g2[_g1];
      _g1 = _g1 + 1;
      if (f(i)) then 
        _g:push(i);
      end;
      end;
    do return _g end
  end,
  'iterator', function(self) 
    local _gthis = self;
    local cur_length = 0;
    do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self) 
      do return cur_length < _gthis.length end;
    end,next=function(self) 
      cur_length = cur_length + 1;
      do return _gthis[cur_length - 1] end;
    end}) end
  end
  ,'__class__',  Array
)

Camera.new = function(position) 
  local self = _hx_new(Camera.prototype)
  Camera.super(self,position)
  return self
end
Camera.super = function(self,position) 
  self.pitch_limit_down = 0.9;
  self.pitch_limit_up = 0.9;
  self.mouse_sensitivity = 0.2;
  self.up = math._Vec3.Vec3_Impl_._new(0,0,1);
  self.clip_bias = 3;
  self.clip_minimum = 4;
  self.far = 300.0;
  self.near = 1.0;
  self.clip_distance = 999;
  local this1;
  this1 = ({0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0});
  this1[0] = 1;
  self.projection = this1;
  local this11;
  this11 = ({0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0});
  this11[0] = 1;
  self.view = this11;
  self.direction = math._Vec3.Vec3_Impl_._new(0,1,0);
  self.orientation = math._Quat.Quat_Impl_._new(0,0,0,1);
  self.position = math._Vec3.Vec3_Impl_._new(0,0,0);
  self.offset = math._Vec3.Vec3_Impl_._new(0,0,-4);
  self.orbit_offset = math._Vec3.Vec3_Impl_._new(0,-1.75,0);
  self.fov = 80;
  self.position = position;
  self.direction = math._Quat.Quat_Impl_.mul_vec3(self.orientation,math._Vec3.Vec3_Impl_._new(0,-1,0));
end
Camera.__name__ = {"Camera"}
Camera.prototype = _hx_a(
  'rotate_xy', function(self,mx,my) 
    local sensitivity = self.mouse_sensitivity;
    local mouse_direction_y;
    local mouse_direction_x = _G.math.rad(-mx * sensitivity);
    mouse_direction_y = _G.math.rad(-my * sensitivity);
    local axis = math._Vec3.Vec3_Impl_.cross(self.direction,self.up);
    math._Vec3.Vec3_Impl_.normalize(axis);
    self.orientation = math._Quat.Quat_Impl_.mul(math._Quat.Quat_Impl_.from_angle_axis(mouse_direction_x,self.up),self.orientation);
    local new_orientation = math._Quat.Quat_Impl_.mul(self.orientation,math._Quat.Quat_Impl_.from_angle_axis(mouse_direction_y,math._Vec3.Vec3_Impl_._new(1,0,0)));
    local a = math._Quat.Quat_Impl_.mul_vec3(new_orientation,math._Vec3.Vec3_Impl_._new(0,1,0));
    local b = self.up;
    local new_pitch = ((a[1] * b[1]) + (a[2] * b[2])) + (a[3] * b[3]);
    if (new_pitch >= self.pitch_limit_up) then 
      local b1 = mouse_direction_y;
      if (Math.isNaN(0) or Math.isNaN(b1)) then 
        mouse_direction_y = (0/0);
      else
        mouse_direction_y = _G.math.min(0,b1);
      end;
    else
      if (new_pitch <= -self.pitch_limit_down) then 
        local b2 = mouse_direction_y;
        if (Math.isNaN(0) or Math.isNaN(b2)) then 
          mouse_direction_y = (0/0);
        else
          mouse_direction_y = _G.math.max(0,b2);
        end;
      end;
    end;
    self.orientation = math._Quat.Quat_Impl_.mul(self.orientation,math._Quat.Quat_Impl_.from_angle_axis(mouse_direction_y,math._Vec3.Vec3_Impl_._new(1,0,0)));
    self.direction = math._Quat.Quat_Impl_.mul_vec3(self.orientation,math._Vec3.Vec3_Impl_._new(0,-1,0));
  end,
  'frustum_triangle', function(self,w,h) 
    local a = w / h;
    local b = h / w;
    local aspect = (function() 
      local _hx_1
      if (Math.isNaN(a) or Math.isNaN(b)) then 
      _hx_1 = (0/0); else 
      _hx_1 = _G.math.max(a,b); end
      return _hx_1
    end )();
    local a1 = w / h;
    local b1 = h / w;
    local aspect_inv = (function() 
      local _hx_2
      if (Math.isNaN(a1) or Math.isNaN(b1)) then 
      _hx_2 = (0/0); else 
      _hx_2 = _G.math.min(a1,b1); end
      return _hx_2
    end )();
    local fovy = _G.math.rad(self.fov * aspect_inv);
    local hheight = _G.math.tan(fovy / 2);
    local hwidth = hheight * aspect;
    local cam_right = math._Vec3.Vec3_Impl_.cross(self.direction,self.up);
    local far_clip = self.far;
    local adjusted = self.position;
    local far_center = math._Vec3.Vec3_Impl_.add(adjusted,math._Vec3.Vec3_Impl_.scale(self.direction,far_clip));
    local far_right = math._Vec3.Vec3_Impl_.scale(math._Vec3.Vec3_Impl_.scale(cam_right,hwidth),far_clip);
    local far_top = math._Vec3.Vec3_Impl_.scale(math._Vec3.Vec3_Impl_.scale(self.up,hheight),far_clip);
    local fbl = math._Vec3.Vec3_Impl_.sub(math._Vec3.Vec3_Impl_.sub(far_center,far_right),far_top);
    local ftl = math._Vec3.Vec3_Impl_.add(math._Vec3.Vec3_Impl_.sub(far_center,far_right),far_top);
    local fbr = math._Vec3.Vec3_Impl_.sub(math._Vec3.Vec3_Impl_.add(far_center,far_right),far_top);
    local ftr = math._Vec3.Vec3_Impl_.add(math._Vec3.Vec3_Impl_.add(far_center,far_right),far_top);
    local dx = adjusted[1] - ftl[1];
    local dy = adjusted[2] - ftl[2];
    local dz = adjusted[3] - ftl[3];
    local use_top = _G.math.sqrt(((dx * dx) + (dy * dy)) + (dz * dz));
    local dx1 = adjusted[1] - fbl[1];
    local dy1 = adjusted[2] - fbl[2];
    local dz1 = adjusted[3] - fbl[3];
    local use_top1 = use_top > _G.math.sqrt(((dx1 * dx1) + (dy1 * dy1)) + (dz1 * dz1));
    do return math.Triangle.new((function() 
      local _hx_3
      if (use_top1) then 
      _hx_3 = ftr; else 
      _hx_3 = fbr; end
      return _hx_3
    end )(),(function() 
      local _hx_4
      if (use_top1) then 
      _hx_4 = ftl; else 
      _hx_4 = fbl; end
      return _hx_4
    end )(),adjusted,math._Vec3.Vec3_Impl_._new(0,0,0)) end
  end,
  'update', function(self,w,h) 
    local _gthis = self;
    local a = w / h;
    local b = h / w;
    local aspect = (function() 
      local _hx_1
      if (Math.isNaN(a) or Math.isNaN(b)) then 
      _hx_1 = (0/0); else 
      _hx_1 = _G.math.max(a,b); end
      return _hx_1
    end )();
    local a1 = w / h;
    local b1 = h / w;
    local aspect_inv = (function() 
      local _hx_2
      if (Math.isNaN(a1) or Math.isNaN(b1)) then 
      _hx_2 = (0/0); else 
      _hx_2 = _G.math.min(a1,b1); end
      return _hx_2
    end )();
    local target = math._Vec3.Vec3_Impl_.add(self.position,self.direction);
    local orbit = math._Mat4.Mat4_Impl_.translate(self.orbit_offset);
    self.view = math._Mat4.Mat4_Impl_.mul(math._Mat4.Mat4_Impl_.look_at(self.position,target,math._Vec3.Vec3_Impl_._new(0,0,1)),orbit);
    local a2 = self.clip_distance;
    local b2 = self.clip_minimum;
    local clip = -((function() 
      local _hx_3
      if (Math.isNaN(a2) or Math.isNaN(b2)) then 
      _hx_3 = (0/0); else 
      _hx_3 = _G.math.max(a2,b2); end
      return _hx_3
    end )() - self.clip_bias);
    local a3 = self.offset[3];
    if (Math.isNaN(a3) or Math.isNaN(clip)) then 
      clip = (0/0);
    else
      clip = _G.math.max(a3,clip);
    end;
    self.view = math._Mat4.Mat4_Impl_.mul(self.view,math._Mat4.Mat4_Impl_.translate(math._Vec3.Vec3_Impl_._new(self.offset[1],self.offset[2],clip)));
    local fovy = self.fov * aspect_inv;
    self.projection = math._Mat4.Mat4_Impl_.from_perspective(fovy,aspect,self.near,self.far);
    self.viewable = self:frustum_triangle(w,h);
    local vp = math._Mat4.Mat4_Impl_.mul(self.view,self.projection);
    World.update_visible(self.viewable,math._Mat4.Mat4_Impl_.to_frustum(vp));
    do return end
  end
  ,'__class__',  Camera
)

Date.new = function(year,month,day,hour,min,sec) 
  local self = _hx_new(Date.prototype)
  Date.super(self,year,month,day,hour,min,sec)
  return self
end
Date.super = function(self,year,month,day,hour,min,sec) 
  self.t = _G.os.time(_hx_o({__fields__={year=true,month=true,day=true,hour=true,min=true,sec=true},year=year,month=month + 1,day=day,hour=hour,min=min,sec=sec}));
  self.d = _G.os.date("*t",self.t);
end
Date.__name__ = {"Date"}
Date.now = function() 
  local t = _G.os.time() * 1000;
  local d = _hx_e();
  _G.setmetatable(d,_hx_o({__fields__={__index=true},__index=Date.prototype}));
  d.t = t / 1000;
  d.d = _G.os.date("*t",Std.int(d.t));
  do return d end;
end
Date.fromTime = function(t) 
  local d = _hx_e();
  _G.setmetatable(d,_hx_o({__fields__={__index=true},__index=Date.prototype}));
  d.t = t / 1000;
  d.d = _G.os.date("*t",Std.int(d.t));
  do return d end;
end
Date.fromString = function(s) 
  do return lua.Boot.strDate(s) end;
end
Date.prototype = _hx_a(
  'getHours', function(self) 
    do return self.d.hour end
  end,
  'getMinutes', function(self) 
    do return self.d.min end
  end,
  'getSeconds', function(self) 
    do return self.d.sec end
  end,
  'getFullYear', function(self) 
    do return self.d.year end
  end,
  'getMonth', function(self) 
    do return self.d.month - 1 end
  end,
  'getDate', function(self) 
    do return self.d.day end
  end
  ,'__class__',  Date
)

Debug.new = {}
Debug.__name__ = {"Debug"}
Debug.init = function() 
  local fmt = ({});
  fmt[1] = ({"VertexPosition","float",3});
  fmt[2] = ({"VertexColor","float",4});
  Debug.mesh = love.graphics.newMesh(fmt,65535,"triangles","stream");
end
Debug.capsule = function(capsule,r,g,b) 
  if (b == nil) then 
    b = 1;
  end;
  if (g == nil) then 
    g = 1;
  end;
  if (r == nil) then 
    r = 1;
  end;
  Debug.capsule_queue:push(_hx_o({__fields__={capsule=true,r=true,g=true,b=true},capsule=math.Capsule.new(capsule.a,capsule.b,capsule.radius),r=r,g=g,b=b}));
end
Debug.line = function(v0,v1,r,g,b) 
  if (b == nil) then 
    b = 1;
  end;
  if (g == nil) then 
    g = 1;
  end;
  if (r == nil) then 
    r = 1;
  end;
  Debug.vertices:push(_hx_tab_array({[0]=v0[1], v0[2], v0[3], r, g, b, 1 }, 7));
  Debug.vertices:push(Debug.vertices[Debug.vertices.length - 1]);
  Debug.vertices:push(_hx_tab_array({[0]=v1[1], v1[2], v1[3], r, g, b, 1 }, 7));
end
Debug.axis = function(origin,x,y,z,length) 
  if (length == nil) then 
    length = 1;
  end;
  Debug.line(origin,math._Vec3.Vec3_Impl_.add(origin,math._Vec3.Vec3_Impl_.scale(x,length)),1.0,0.0,0.0);
  Debug.line(origin,math._Vec3.Vec3_Impl_.add(origin,math._Vec3.Vec3_Impl_.scale(y,length)),0.0,1.0,0.0);
  Debug.line(origin,math._Vec3.Vec3_Impl_.add(origin,math._Vec3.Vec3_Impl_.scale(z,length)),0.0,0.0,1.0);
end
Debug.aabb = function(min,max,r,g,b) 
  if (b == nil) then 
    b = 1;
  end;
  if (g == nil) then 
    g = 1;
  end;
  if (r == nil) then 
    r = 1;
  end;
  local cube_vertices = _hx_tab_array({[0]=math._Vec3.Vec3_Impl_._new(min[1],min[2],max[3]), math._Vec3.Vec3_Impl_._new(max[1],min[2],max[3]), math._Vec3.Vec3_Impl_._new(max[1],max[2],max[3]), math._Vec3.Vec3_Impl_._new(min[1],max[2],max[3]), math._Vec3.Vec3_Impl_._new(min[1],min[2],min[3]), math._Vec3.Vec3_Impl_._new(max[1],min[2],min[3]), math._Vec3.Vec3_Impl_._new(max[1],max[2],min[3]), math._Vec3.Vec3_Impl_._new(min[1],max[2],min[3]) }, 8);
  local i = 1;
  local _g1 = 0;
  local _g = Std.int(Debug.cube_indices.length / 2);
  while (_g1 < _g) do 
    _g1 = _g1 + 1;
    local j = _g1 - 1;
    local i0 = Debug.cube_indices[i - 1];
    local i1 = Debug.cube_indices[i];
    Debug.line(cube_vertices[i0],cube_vertices[i1],r,g,b);
    i = i + 2;
    end;
end
Debug.clear_capsules = function() 
  local ret = Debug.capsule_queue;
  Debug.capsule_queue = _hx_tab_array({ }, 0);
  do return ret end;
end
Debug.draw = function(wipe_only) 
  if (wipe_only or (Debug.vertices.length == 0)) then 
    Debug.vertices = _hx_tab_array({ }, 0);
    do return end;
  end;
  local t = ({});
  local verts = Std.int(_G.math.min(Debug.vertices.length,65535));
  local _g1 = 0;
  local _g = verts;
  while (_g1 < _g) do 
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    t[i + 1] = ({});
    local _g2 = 0;
    while (_g2 < 7) do 
      _g2 = _g2 + 1;
      local j = _g2 - 1;
      t[i + 1][j + 1] = Debug.vertices[i][j];
      end;
    end;
  Debug.mesh:setVertices(t);
  Debug.mesh:setDrawRange(1,verts);
  love.graphics.draw(Debug.mesh);
  Debug.vertices = _hx_tab_array({ }, 0);
end
_hxClasses["Action"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Jump","TrickA","TrickB","CameraReverse","CameraRecenter","Walk","MenuToggle","MenuUp","MenuDown","MenuLeft","MenuRight","MenuPrev","MenuNext","MenuConfirm","MenuCancel","XLright","XLleft","YLup","YLdown","XRright","XRleft","YRup","YRdown","XLaxis","YLaxis","XRaxis","YRaxis","LTrigger","RTrigger","Debug_F1","Debug_F2","Debug_F3","Debug_F4","Debug_F5","Debug_F6","Debug_F7","Debug_F8","Debug_F9","Debug_F10","Debug_F11","Debug_F12","Invalid"},42)}
Action = _hxClasses["Action"];
Action.Jump = _hx_tab_array({[0]="Jump",0,__enum__ = Action},2)

Action.TrickA = _hx_tab_array({[0]="TrickA",1,__enum__ = Action},2)

Action.TrickB = _hx_tab_array({[0]="TrickB",2,__enum__ = Action},2)

Action.CameraReverse = _hx_tab_array({[0]="CameraReverse",3,__enum__ = Action},2)

Action.CameraRecenter = _hx_tab_array({[0]="CameraRecenter",4,__enum__ = Action},2)

Action.Walk = _hx_tab_array({[0]="Walk",5,__enum__ = Action},2)

Action.MenuToggle = _hx_tab_array({[0]="MenuToggle",6,__enum__ = Action},2)

Action.MenuUp = _hx_tab_array({[0]="MenuUp",7,__enum__ = Action},2)

Action.MenuDown = _hx_tab_array({[0]="MenuDown",8,__enum__ = Action},2)

Action.MenuLeft = _hx_tab_array({[0]="MenuLeft",9,__enum__ = Action},2)

Action.MenuRight = _hx_tab_array({[0]="MenuRight",10,__enum__ = Action},2)

Action.MenuPrev = _hx_tab_array({[0]="MenuPrev",11,__enum__ = Action},2)

Action.MenuNext = _hx_tab_array({[0]="MenuNext",12,__enum__ = Action},2)

Action.MenuConfirm = _hx_tab_array({[0]="MenuConfirm",13,__enum__ = Action},2)

Action.MenuCancel = _hx_tab_array({[0]="MenuCancel",14,__enum__ = Action},2)

Action.XLright = _hx_tab_array({[0]="XLright",15,__enum__ = Action},2)

Action.XLleft = _hx_tab_array({[0]="XLleft",16,__enum__ = Action},2)

Action.YLup = _hx_tab_array({[0]="YLup",17,__enum__ = Action},2)

Action.YLdown = _hx_tab_array({[0]="YLdown",18,__enum__ = Action},2)

Action.XRright = _hx_tab_array({[0]="XRright",19,__enum__ = Action},2)

Action.XRleft = _hx_tab_array({[0]="XRleft",20,__enum__ = Action},2)

Action.YRup = _hx_tab_array({[0]="YRup",21,__enum__ = Action},2)

Action.YRdown = _hx_tab_array({[0]="YRdown",22,__enum__ = Action},2)

Action.XLaxis = _hx_tab_array({[0]="XLaxis",23,__enum__ = Action},2)

Action.YLaxis = _hx_tab_array({[0]="YLaxis",24,__enum__ = Action},2)

Action.XRaxis = _hx_tab_array({[0]="XRaxis",25,__enum__ = Action},2)

Action.YRaxis = _hx_tab_array({[0]="YRaxis",26,__enum__ = Action},2)

Action.LTrigger = _hx_tab_array({[0]="LTrigger",27,__enum__ = Action},2)

Action.RTrigger = _hx_tab_array({[0]="RTrigger",28,__enum__ = Action},2)

Action.Debug_F1 = _hx_tab_array({[0]="Debug_F1",29,__enum__ = Action},2)

Action.Debug_F2 = _hx_tab_array({[0]="Debug_F2",30,__enum__ = Action},2)

Action.Debug_F3 = _hx_tab_array({[0]="Debug_F3",31,__enum__ = Action},2)

Action.Debug_F4 = _hx_tab_array({[0]="Debug_F4",32,__enum__ = Action},2)

Action.Debug_F5 = _hx_tab_array({[0]="Debug_F5",33,__enum__ = Action},2)

Action.Debug_F6 = _hx_tab_array({[0]="Debug_F6",34,__enum__ = Action},2)

Action.Debug_F7 = _hx_tab_array({[0]="Debug_F7",35,__enum__ = Action},2)

Action.Debug_F8 = _hx_tab_array({[0]="Debug_F8",36,__enum__ = Action},2)

Action.Debug_F9 = _hx_tab_array({[0]="Debug_F9",37,__enum__ = Action},2)

Action.Debug_F10 = _hx_tab_array({[0]="Debug_F10",38,__enum__ = Action},2)

Action.Debug_F11 = _hx_tab_array({[0]="Debug_F11",39,__enum__ = Action},2)

Action.Debug_F12 = _hx_tab_array({[0]="Debug_F12",40,__enum__ = Action},2)

Action.Invalid = _hx_tab_array({[0]="Invalid",41,__enum__ = Action},2)

Action.__empty_constructs__ = _hx_tab_array({[0] = Action.Jump,Action.TrickA,Action.TrickB,Action.CameraReverse,Action.CameraRecenter,Action.Walk,Action.MenuToggle,Action.MenuUp,Action.MenuDown,Action.MenuLeft,Action.MenuRight,Action.MenuPrev,Action.MenuNext,Action.MenuConfirm,Action.MenuCancel,Action.XLright,Action.XLleft,Action.YLup,Action.YLdown,Action.XRright,Action.XRleft,Action.YRup,Action.YRdown,Action.XLaxis,Action.YLaxis,Action.XRaxis,Action.YRaxis,Action.LTrigger,Action.RTrigger,Action.Debug_F1,Action.Debug_F2,Action.Debug_F3,Action.Debug_F4,Action.Debug_F5,Action.Debug_F6,Action.Debug_F7,Action.Debug_F8,Action.Debug_F9,Action.Debug_F10,Action.Debug_F11,Action.Debug_F12,Action.Invalid}, 42)

InputState.new = function() 
  local self = _hx_new(InputState.prototype)
  InputState.super(self)
  return self
end
InputState.super = function(self) 
  self.updated = false;
  self.deadzone = 0.35;
  self.first_update = true;
  self.value = 0;
  self.pressed = -1;
end
InputState.__name__ = {"InputState"}
InputState.prototype = _hx_a(
  'press', function(self,v) 
    if (v == nil) then 
      v = 1;
    end;
    if (self.pressed < 0) then 
      self.first_update = true;
      self.pressed = 0;
    end;
    self.updated = true;
    self.value = v;
  end,
  'update', function(self,dt) 
    if (not self.updated) then 
      self.first_update = true;
      self.pressed = -1;
      self.value = 0;
    end;
    if (self.pressed > 0) then 
      self.first_update = false;
      self.updated = false;
    end;
    local tmp;
    local threshold = self.deadzone;
    if (_G.math.abs(self.value) >= threshold) then 
      tmp = self.pressed >= 0;
    else
      tmp = false;
    end;
    if (tmp) then 
      local tmp1 = self;
      tmp1.pressed = tmp1.pressed + dt;
    end;
  end
  ,'__class__',  InputState
)

GameInput.new = {}
GameInput.__name__ = {"GameInput"}
GameInput.to_action = function(key) 
  local key1 = key;
  if (key1) == "f1" then 
    do return Action.Debug_F1 end;
  elseif (key1) == "f10" then 
    do return Action.Debug_F10 end;
  elseif (key1) == "f11" then 
    do return Action.Debug_F11 end;
  elseif (key1) == "f12" then 
    do return Action.Debug_F12 end;
  elseif (key1) == "f2" then 
    do return Action.Debug_F2 end;
  elseif (key1) == "f3" then 
    do return Action.Debug_F3 end;
  elseif (key1) == "f4" then 
    do return Action.Debug_F4 end;
  elseif (key1) == "f5" then 
    do return Action.Debug_F5 end;
  elseif (key1) == "f6" then 
    do return Action.Debug_F6 end;
  elseif (key1) == "f7" then 
    do return Action.Debug_F7 end;
  elseif (key1) == "f8" then 
    do return Action.Debug_F8 end;
  elseif (key1) == "f9" then 
    do return Action.Debug_F9 end; end;
  do return Action.Invalid end;
end
GameInput.keypressed = function(key) 
  local a = GameInput.to_action(key);
  if (a == Action.Invalid) then 
    do return end;
  end;
  GameInput.active:push(a);
end
GameInput.keyreleased = function(key) 
  local a = GameInput.to_action(key);
  if (a == Action.Invalid) then 
    do return end;
  end;
  local idx = GameInput.active:indexOf(a);
  if (idx >= 0) then 
    GameInput.active:splice(idx,1);
  end;
end
GameInput.bind = function(input,cb) 
  GameInput.callbacks:set(input,cb);
end
GameInput.init = function() 
  local actions = Type.allEnums(Action);
  local _g = 0;
  while (_g < actions.length) do 
    local action = actions[_g];
    _g = _g + 1;
    local this1 = GameInput.input_state;
    local v = InputState.new();
    this1:set(action,v);
    end;
end
GameInput.update_gamepads = function() 
  local joysticks = love.joystick.getJoysticks();
  local axis = GameInput.gp_raw_axes:keys();
  while (axis:hasNext()) do 
    local axis1 = axis:next();
    GameInput.gp_raw_axes:set(axis1,0);
    end;
  lua.PairTools.ipairsEach(joysticks,function(i,js) 
    if (not js:isGamepad()) then 
      do return end;
    end;
    local axis2 = GameInput.gp_raw_axes:keys();
    while (axis2:hasNext()) do 
      local axis3 = axis2:next();
      local v = js:getGamepadAxis(axis3);
      if ((axis3 == "lefty") or (axis3 == "righty")) then 
        v = -v;
      end;
      if (_G.math.abs(v) > _G.math.abs(GameInput.gp_raw_axes:get(axis3))) then 
        GameInput.gp_raw_axes:set(axis3,v);
      end;
      end;
    local button = GameInput.gp_mappings:keys();
    while (button:hasNext()) do 
      local button1 = button:next();
      local b = js:isGamepadDown(button1);
      local m = GameInput.gp_mappings:get(button1).menu;
      if (m ~= nil) then 
        if (b) then 
          GameInput.input_state:get(m):press(1);
        end;
      end;
      local p = GameInput.gp_mappings:get(button1).player;
      if (p ~= nil) then 
        if (b) then 
          GameInput.input_state:get(p):press(1);
        end;
      end;
      end;
  end);
end
GameInput.update_keyboard = function() 
  local key = GameInput.kb_mappings:keys();
  while (key:hasNext()) do 
    local key1 = key:next();
    local bind = GameInput.kb_mappings:get(key1);
    local b = love.keyboard.isDown(Std.string(key1));
    local m = bind.menu;
    if (m ~= nil) then 
      if (b) then 
        GameInput.input_state:get(m):press(1);
      end;
    end;
    local p = bind.player;
    if (p ~= nil) then 
      if (b) then 
        GameInput.input_state:get(p):press(1);
      end;
    end;
    end;
end
GameInput.move_xy = function() 
  local x = GameInput.input_state:get(Action.XLaxis);
  local y = GameInput.input_state:get(Action.YLaxis);
  local x1 = x.value;
  local y1 = y.value;
  local this1;
  local this2 = ({length = 2});
  this1 = this2;
  this1[0] = x1;
  this1[1] = y1;
  local ret = this1;
  local l = math._Vec2.Vec2_Impl_.length(ret);
  local a = x.deadzone;
  local b = y.deadzone;
  if (l < (function() 
    local _hx_1
    if (Math.isNaN(a) or Math.isNaN(b)) then 
    _hx_1 = (0/0); else 
    _hx_1 = _G.math.max(a,b); end
    return _hx_1
  end )()) then 
    ret[0] = 0;
    ret[1] = 0;
  end;
  if (l > 1) then 
    math._Vec2.Vec2_Impl_.scale(ret,1 / l);
  end;
  do return ret end;
end
GameInput.view_xy = function() 
  local x = GameInput.input_state:get(Action.XRaxis);
  local y = GameInput.input_state:get(Action.YRaxis);
  local x1 = x.value;
  local y1 = -y.value;
  local this1;
  local this2 = ({length = 2});
  this1 = this2;
  this1[0] = x1;
  this1[1] = y1;
  local ret = this1;
  local l = math._Vec2.Vec2_Impl_.length(ret);
  local a = x.deadzone;
  local b = y.deadzone;
  if (l < (function() 
    local _hx_1
    if (Math.isNaN(a) or Math.isNaN(b)) then 
    _hx_1 = (0/0); else 
    _hx_1 = _G.math.max(a,b); end
    return _hx_1
  end )()) then 
    ret[0] = 0;
    ret[1] = 0;
  end;
  if (l > 1) then 
    math._Vec2.Vec2_Impl_.scale(ret,1 / l);
  end;
  do return ret end;
end
GameInput.update = function(dt) 
  local _g = 0;
  local _g1 = GameInput.active;
  while (_g < _g1.length) do 
    local run = _g1[_g];
    _g = _g + 1;
    if (GameInput.callbacks:exists(run)) then 
      local fn = GameInput.callbacks:get(run);
      if (fn()) then 
        GameInput.active:remove(run);
        break;
      end;
    end;
    end;
  GameInput.callbacks = haxe.ds.EnumValueMap.new();
  GameInput.update_gamepads();
  GameInput.update_keyboard();
  local v = GameInput.gp_raw_axes:get("leftx");
  local tmp = GameInput.input_state:get(Action.XLright);
  tmp.value = tmp.value + (function() 
    local _hx_1
    if (Math.isNaN(v) or Math.isNaN(0)) then 
    _hx_1 = (0/0); else 
    _hx_1 = _G.math.max(v,0); end
    return _hx_1
  end )();
  local tmp1 = GameInput.input_state:get(Action.XLleft);
  local a = -v;
  tmp1.value = tmp1.value + (function() 
    local _hx_2
    if (Math.isNaN(a) or Math.isNaN(0)) then 
    _hx_2 = (0/0); else 
    _hx_2 = _G.math.max(a,0); end
    return _hx_2
  end )();
  v = GameInput.gp_raw_axes:get("lefty");
  local tmp2 = GameInput.input_state:get(Action.YLup);
  tmp2.value = tmp2.value + (function() 
    local _hx_3
    if (Math.isNaN(v) or Math.isNaN(0)) then 
    _hx_3 = (0/0); else 
    _hx_3 = _G.math.max(v,0); end
    return _hx_3
  end )();
  local tmp3 = GameInput.input_state:get(Action.YLdown);
  local a1 = -v;
  tmp3.value = tmp3.value + (function() 
    local _hx_4
    if (Math.isNaN(a1) or Math.isNaN(0)) then 
    _hx_4 = (0/0); else 
    _hx_4 = _G.math.max(a1,0); end
    return _hx_4
  end )();
  v = GameInput.gp_raw_axes:get("rightx");
  local tmp4 = GameInput.input_state:get(Action.XRright);
  tmp4.value = tmp4.value + (function() 
    local _hx_5
    if (Math.isNaN(v) or Math.isNaN(0)) then 
    _hx_5 = (0/0); else 
    _hx_5 = _G.math.max(v,0); end
    return _hx_5
  end )();
  local tmp5 = GameInput.input_state:get(Action.XRleft);
  local a2 = -v;
  tmp5.value = tmp5.value + (function() 
    local _hx_6
    if (Math.isNaN(a2) or Math.isNaN(0)) then 
    _hx_6 = (0/0); else 
    _hx_6 = _G.math.max(a2,0); end
    return _hx_6
  end )();
  v = GameInput.gp_raw_axes:get("righty");
  local tmp6 = GameInput.input_state:get(Action.YRup);
  tmp6.value = tmp6.value + (function() 
    local _hx_7
    if (Math.isNaN(v) or Math.isNaN(0)) then 
    _hx_7 = (0/0); else 
    _hx_7 = _G.math.max(v,0); end
    return _hx_7
  end )();
  local tmp7 = GameInput.input_state:get(Action.YRdown);
  local a3 = -v;
  tmp7.value = tmp7.value + (function() 
    local _hx_8
    if (Math.isNaN(a3) or Math.isNaN(0)) then 
    _hx_8 = (0/0); else 
    _hx_8 = _G.math.max(a3,0); end
    return _hx_8
  end )();
  GameInput.input_state:get(Action.XLaxis):press(GameInput.input_state:get(Action.XLright).value - GameInput.input_state:get(Action.XLleft).value);
  GameInput.input_state:get(Action.YLaxis):press(GameInput.input_state:get(Action.YLup).value - GameInput.input_state:get(Action.YLdown).value);
  GameInput.input_state:get(Action.XRaxis):press(GameInput.input_state:get(Action.XRright).value - GameInput.input_state:get(Action.XRleft).value);
  GameInput.input_state:get(Action.YRaxis):press(GameInput.input_state:get(Action.YRup).value - GameInput.input_state:get(Action.YRdown).value);
  local action = GameInput.input_state:keys();
  while (action:hasNext()) do 
    local action1 = action:next();
    local bind = GameInput.input_state:get(action1);
    bind:update(dt);
    end;
end

Language.new = {}
Language.__name__ = {"Language"}
Language.load = function(locale) 
  local base = "assets/locales/";
  local files = love.filesystem.getDirectoryItems(base);
  _G.table.foreach(files,function(i,v) 
    local filename = base .. v;
    if (filename:lastIndexOf(".lua") == (filename.length - 4)) then 
      Language.data:load(filename);
    end;
  end);
  Language.data:set_locale(locale);
  if (locale ~= "en") then 
    Language.data:set_fallback("en");
  end;
end
_hxClasses["Level"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Debug","Info","Item","Quest","System"},5)}
Level = _hxClasses["Level"];
Level.Debug = _hx_tab_array({[0]="Debug",0,__enum__ = Level},2)

Level.Info = _hx_tab_array({[0]="Info",1,__enum__ = Level},2)

Level.Item = _hx_tab_array({[0]="Item",2,__enum__ = Level},2)

Level.Quest = _hx_tab_array({[0]="Quest",3,__enum__ = Level},2)

Level.System = _hx_tab_array({[0]="System",4,__enum__ = Level},2)

Level.__empty_constructs__ = _hx_tab_array({[0] = Level.Debug,Level.Info,Level.Item,Level.Quest,Level.System}, 5)

Log.new = {}
Log.__name__ = {"Log"}
Log.write = function(level,msg) 
  local line = "[" .. level[0] .. "] " .. msg;
  ui.LogWindow.messages:push(line);
  _G.print(Std.string(line));
end
_hxClasses["WindowType"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="EditorUI","CameraDebug","Log","ProfilerUI"},4)}
WindowType = _hxClasses["WindowType"];
WindowType.EditorUI = _hx_tab_array({[0]="EditorUI",0,__enum__ = WindowType},2)

WindowType.CameraDebug = _hx_tab_array({[0]="CameraDebug",1,__enum__ = WindowType},2)

WindowType.Log = _hx_tab_array({[0]="Log",2,__enum__ = WindowType},2)

WindowType.ProfilerUI = _hx_tab_array({[0]="ProfilerUI",3,__enum__ = WindowType},2)

WindowType.__empty_constructs__ = _hx_tab_array({[0] = WindowType.EditorUI,WindowType.CameraDebug,WindowType.Log,WindowType.ProfilerUI}, 4)

Main.new = {}
Main.__name__ = {"Main"}
Main.showing_menu = function(window) 
  do return Main.open_windows:indexOf(window) >= 0 end;
end
Main.toggle_window = function(window) 
  local idx = Main.open_windows:indexOf(window);
  if (idx >= 0) then 
    Main.open_windows:splice(idx,1);
    do return end;
  end;
  Main.open_windows:push(window);
end
Main.main = function() 
  love.run = backend.love.GameLoop.real_run;
  do return end;
end
Main.load = function(args) 
  local boot_editor = false;
  local _g = 0;
  local _hx_break_0 = false;
  while (_g < args.length) do 
    repeat 
    local v = args[_g];
    _g = _g + 1;
    if (v == "--perf") then 
      Main.show_profiler = true;
      break;
    end;
    if (v == "--editor") then 
      boot_editor = true;
      break;
    end;
    
  until true
  if _hx_break_1 then _hx_break_1 = false; break; end
  end;
  if (boot_editor) then 
    Main.toggle_window(WindowType.EditorUI);
    Main.editing = true;
    love.mouse.setRelativeMode(false);
  end;
  if (Main.show_profiler) then 
    Main.toggle_window(WindowType.ProfilerUI);
  end;
  Language.load("en");
  ui.Helpers.setup_imgui();
  love.mouse.setRelativeMode(true);
  GameInput.init();
  editor.Editor.init();
  local p = components.Player.new();
  p:load();
  Main.player = p;
  systems.Render.init();
  GameTime.init();
  World.init(p);
  local spawn = math._Vec3.Vec3_Impl_._new(1.0,1.0,0.0);
  Profiler.load_zone();
  Zone.load("assets/maps/world.fresh");
  components.Player.spawn(spawn,Main.player);
  Profiler.start_frame();
  love.resize = Main.resize;
  love.focus = Main.focus;
end
Main.resize = function(w,h) 
  systems.Render.resize(w,h);
end
Main.mousepressed = function(x,y,button) 
  if (not love.mouse.getRelativeMode()) then 
    imgui.Input.MousePressed(button);
  end;
end
Main.mousereleased = function(x,y,button) 
  if (not love.mouse.getRelativeMode()) then 
    imgui.Input.MouseReleased(button);
  end;
end
Main.mousemoved = function(x,y,dx,dy) 
  if (not love.mouse.getRelativeMode()) then 
    imgui.Input.MouseMoved(x,y);
  end;
  if (love.mouse.getRelativeMode()) then 
    systems.PlayerController.mouse_moved(dx,dy);
  end;
end
Main.wheelmoved = function(x,y) 
  if (not love.mouse.getRelativeMode()) then 
    imgui.Input.WheelMoved(y);
  end;
end
Main.textinput = function(str) 
  if (not love.mouse.getRelativeMode()) then 
    imgui.Input.TextInput(str);
  end;
end
Main.keypressed = function(key,scan,isrepeat) 
  if (not isrepeat) then 
    GameInput.keypressed(key);
  end;
  if (key == "escape") then 
    love.mouse.setRelativeMode(not love.mouse.getRelativeMode());
  end;
  if (not love.mouse.getRelativeMode() or (key == "escape")) then 
    imgui.Input.KeyPressed(key);
  end;
end
Main.keyreleased = function(key) 
  GameInput.keyreleased(key);
  if (not love.mouse.getRelativeMode()) then 
    imgui.Input.KeyReleased(key);
  end;
end
Main.respawn = function() 
  local _this = editor.Editor.cursor;
  components.Player.spawn(World.to_world(_this.position,_this.tile_x,_this.tile_y),Main.player);
end
Main.focus = function(focus) 
  Main.has_focus = focus;
end
Main.draw = function(window) 
  ui.MainMenu.draw();
  GameInput.update(Main.dt);
  GameInput.bind(Action.Debug_F5,function() 
    do return true end;
  end);
  GameInput.bind(Action.Debug_F1,function() 
    love.mouse.setRelativeMode(Main.showing_menu(WindowType.EditorUI));
    Main.toggle_window(WindowType.EditorUI);
    do return true end;
  end);
  if (Main.editing and not Main.has_focus) then 
    love.timer.sleep(0.1);
  end;
  Profiler.start_frame();
  GameTime.update(Main.dt);
  World.update(Main.dt);
  local this1 = math._Vec3.Vec3_Impl_._new(0.5,0.0,0.0);
  Profiler.push_block("GC",this1,_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Main.hx",lineNumber=231,className="Main",methodName="draw"}));
  backend._Gc.Gc_Impl_.run(false);
  Profiler.pop_block(_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Main.hx",lineNumber=233,className="Main",methodName="draw"}));
  Profiler.end_frame();
  imgui.ImGui.Render();
  imgui.ImGui.NewFrame();
end
Main.quit = function() 
  imgui.ImGui.ShutDown();
  do return false end;
end

Math.new = {}
Math.__name__ = {"Math"}
Math.isNaN = function(f) 
  do return f ~= f end;
end

math._Vec3.Vec3_Impl_.new = {}
math._Vec3.Vec3_Impl_.__name__ = {"math","_Vec3","Vec3_Impl_"}
math._Vec3.Vec3_Impl_._new = function(x,y,z) 
  if (z == nil) then 
    z = 0;
  end;
  if (y == nil) then 
    y = 0;
  end;
  if (x == nil) then 
    x = 0;
  end;
  local this1 = ({x,y,z});
  do return this1 end;
end
math._Vec3.Vec3_Impl_.add = function(this1,b) 
  local a = this1;
  do return math._Vec3.Vec3_Impl_._new(a[1] + b[1],a[2] + b[2],a[3] + b[3]) end;
end
math._Vec3.Vec3_Impl_.sub = function(this1,b) 
  local a = this1;
  do return math._Vec3.Vec3_Impl_._new(a[1] - b[1],a[2] - b[2],a[3] - b[3]) end;
end
math._Vec3.Vec3_Impl_.div = function(this1,b) 
  local a = this1;
  do return math._Vec3.Vec3_Impl_._new(a[1] / b[1],a[2] / b[2],a[3] / b[3]) end;
end
math._Vec3.Vec3_Impl_.mul = function(this1,b) 
  local a = this1;
  do return math._Vec3.Vec3_Impl_._new(a[1] * b[1],a[2] * b[2],a[3] * b[3]) end;
end
math._Vec3.Vec3_Impl_.fdiv = function(this1,b) 
  local a = this1;
  do return math._Vec3.Vec3_Impl_._new(a[1] / b,a[2] / b,a[3] / b) end;
end
math._Vec3.Vec3_Impl_.scale = function(this1,b) 
  local a = this1;
  do return math._Vec3.Vec3_Impl_._new(a[1] * b,a[2] * b,a[3] * b) end;
end
math._Vec3.Vec3_Impl_.length = function(this1) 
  local _self = this1;
  local self1 = _self;
  do return _G.math.sqrt(((self1[1] * self1[1]) + (self1[2] * self1[2])) + (self1[3] * self1[3])) end;
end
math._Vec3.Vec3_Impl_.normalize = function(this1) 
  local a = this1;
  local _self = a;
  local l = ((_self[1] * _self[1]) + (_self[2] * _self[2])) + (_self[3] * _self[3]);
  if (l == 0) then 
    do return end;
  end;
  l = _G.math.sqrt(l);
  local v = a[1] / l;
  a[1] = v;
  local v1 = a[2] / l;
  a[2] = v1;
  local v2 = a[3] / l;
  a[3] = v2;
end
math._Vec3.Vec3_Impl_.cross = function(a,b) 
  do return math._Vec3.Vec3_Impl_._new((a[2] * b[3]) - (a[3] * b[2]),(a[3] * b[1]) - (a[1] * b[3]),(a[1] * b[2]) - (a[2] * b[1])) end;
end
math._Vec3.Vec3_Impl_.trim = function(this1,max_len) 
  local _self = this1;
  local len = _G.math.sqrt(((_self[1] * _self[1]) + (_self[2] * _self[2])) + (_self[3] * _self[3]));
  if (len > max_len) then 
    local v = _self[1] / len;
    _self[1] = v;
    local v1 = _self[2] / len;
    _self[2] = v1;
    local v2 = _self[3] / len;
    _self[3] = v2;
    local v3 = _self[1] * max_len;
    _self[1] = v3;
    local v4 = _self[2] * max_len;
    _self[2] = v4;
    local v5 = _self[3] * max_len;
    _self[3] = v5;
  end;
end
math._Vec3.Vec3_Impl_.min = function(a,b) 
  do return math._Vec3.Vec3_Impl_._new(_G.math.min(a[1],b[1]),_G.math.min(a[2],b[2]),_G.math.min(a[3],b[3])) end;
end
math._Vec3.Vec3_Impl_.max = function(a,b) 
  do return math._Vec3.Vec3_Impl_._new(_G.math.max(a[1],b[1]),_G.math.max(a[2],b[2]),_G.math.max(a[3],b[3])) end;
end
math._Vec3.Vec3_Impl_.lerp = function(low,high,progress) 
  do return math._Vec3.Vec3_Impl_.add(low,math._Vec3.Vec3_Impl_.scale(math._Vec3.Vec3_Impl_.sub(high,low),progress)) end;
end
math._Vec3.Vec3_Impl_.project_on = function(a,b) 
  local s = (((a[1] * b[1]) + (a[2] * b[2])) + (a[3] * b[3])) / (((b[1] * b[1]) + (b[2] * b[2])) + (b[3] * b[3]));
  do return math._Vec3.Vec3_Impl_._new(b[1] * s,b[2] * s,b[3] * s) end;
end

_Profiler.SegmentColor_Impl_.new = {}
_Profiler.SegmentColor_Impl_.__name__ = {"_Profiler","SegmentColor_Impl_"}

String.new = {}
String.__name__ = {"String"}
String.__index = function(s,k) 
  if (k == "length") then 
    do return _G.string.len(s) end;
  else
    local o = String.prototype;
    local field = k;
    if ((function() 
      local _hx_1
      if (o.__fields__ ~= nil) then 
      _hx_1 = o.__fields__[field] ~= nil; else 
      _hx_1 = o[field] ~= nil; end
      return _hx_1
    end )()) then 
      do return String.prototype[k] end;
    else
      if (String.__oldindex ~= nil) then 
        do return String.__oldindex[k] end;
      else
        do return nil end;
      end;
    end;
  end;
end
String.fromCharCode = function(code) 
  do return _G.string.char(code) end;
end
String.prototype = _hx_a(
  'indexOf', function(self,str,startIndex) 
    if (startIndex == nil) then 
      startIndex = 1;
    else
      startIndex = startIndex + 1;
    end;
    local r = _G.string.find(self,str,startIndex,true);
    if ((r ~= nil) and (r > 0)) then 
      do return r - 1 end;
    else
      do return -1 end;
    end;
  end,
  'lastIndexOf', function(self,str,startIndex) 
    local i = 0;
    local ret = -1;
    if (startIndex == nil) then 
      startIndex = self.length;
    end;
    while (true) do 
      local p = self:indexOf(str,ret + 1);
      if ((p == -1) or (p > startIndex)) then 
        do return ret end;
      end;
      ret = p;
      end;
  end,
  'split', function(self,delimiter) 
    local idx = 1;
    local ret = _hx_tab_array({ }, 0);
    local delim_offset = (function() 
      local _hx_1
      if (delimiter.length > 0) then 
      _hx_1 = delimiter.length; else 
      _hx_1 = 1; end
      return _hx_1
    end )();
    while (idx ~= nil) do 
      local newidx = 0;
      if (delimiter.length > 0) then 
        newidx = _G.string.find(self,delimiter,idx,true);
      else
        if (idx >= self.length) then 
          newidx = nil;
        else
          newidx = idx + 1;
        end;
      end;
      if (newidx ~= nil) then 
        local match = _G.string.sub(self,idx,newidx - 1);
        ret:push(match);
        idx = newidx + delimiter.length;
      else
        ret:push(_G.string.sub(self,idx,_G.string.len(self)));
        idx = nil;
      end;
      end;
    do return ret end
  end,
  'toString', function(self) 
    do return self end
  end,
  'substr', function(self,pos,len) 
    if ((len == nil) or (len > (pos + self.length))) then 
      len = self.length;
    else
      if (len < 0) then 
        len = self.length + len;
      end;
    end;
    if (pos < 0) then 
      pos = self.length + pos;
    end;
    if (pos < 0) then 
      pos = 0;
    end;
    do return _G.string.sub(self,pos + 1,pos + len) end
  end
  ,'__class__',  String
)

Std.new = {}
Std.__name__ = {"Std"}
Std.string = function(s) 
  do return lua.Boot.__string_rec(s) end;
end
Std.int = function(x) 
  if (not ((x > -_G.math.huge) and (x < _G.math.huge)) or Math.isNaN(x)) then 
    do return 0 end;
  else
    do return _hx_bit_clamp(x) end;
  end;
end
Std.parseInt = function(x) 
  if (x == nil) then 
    do return nil end;
  end;
  local hexMatch = _G.string.match(x,"^ *[%-+]*0[xX][%da-FA-F]*");
  if (hexMatch ~= nil) then 
    do return _G.tonumber(hexMatch:substr(2),16) end;
  else
    local intMatch = _G.string.match(x,"^ *[%-+]?%d*");
    if (intMatch ~= nil) then 
      do return _G.tonumber(intMatch) end;
    else
      do return nil end;
    end;
  end;
end
Std.parseFloat = function(x) 
  if ((x == nil) or (x == "")) then 
    do return (0/0) end;
  end;
  local digitMatch = _G.string.match(x,"^ *[%.%-+]?[0-9]%d*");
  if (digitMatch == nil) then 
    do return (0/0) end;
  end;
  x = x:substr(digitMatch.length);
  local decimalMatch = _G.string.match(x,"^%.%d*");
  if (decimalMatch == nil) then 
    decimalMatch = "";
  end;
  x = x:substr(decimalMatch.length);
  local eMatch = _G.string.match(x,"^[eE][+%-]?%d+");
  if (eMatch == nil) then 
    eMatch = "";
  end;
  local result = _G.tonumber(digitMatch .. decimalMatch .. eMatch);
  if (result ~= nil) then 
    do return result end;
  else
    do return (0/0) end;
  end;
end

haxe.ds.GenericStack.new = function() 
  local self = _hx_new(haxe.ds.GenericStack.prototype)
  haxe.ds.GenericStack.super(self)
  return self
end
haxe.ds.GenericStack.super = function(self) 
end
haxe.ds.GenericStack.__name__ = {"haxe","ds","GenericStack"}
haxe.ds.GenericStack.prototype = _hx_a(
  'iterator', function(self) 
    local l = self.head;
    do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self) 
      do return l ~= nil end;
    end,next=function(self) 
      local k = l;
      l = k.next;
      do return k.elt end;
    end}) end
  end
  ,'__class__',  haxe.ds.GenericStack
)

Profiler.new = {}
Profiler.__name__ = {"Profiler"}
Profiler.render = function(frame) 
  GameInput.bind(Action.Debug_F3,function() 
    Main.toggle_window(WindowType.ProfilerUI);
    do return true end;
  end);
  if (not Main.showing_menu(WindowType.ProfilerUI)) then 
    do return end;
  end;
  frame.data:sort(function(a,b) 
    if (a.start > b.start) then 
      do return 1 end;
    else
      do return -1 end;
    end;
  end);
  GameInput.bind(Action.Debug_F4,function() 
    if (Profiler.pause_frame == nil) then 
      Profiler.pause_frame = frame;
    else
      Profiler.pause_frame = nil;
    end;
    do return true end;
  end);
  if (imgui.Window.Begin("Profiler",nil)) then 
    imgui.Widget.Value("FPS",frame.fps);
    imgui.Widget.SameLine(150);
    imgui.Widget.Value("frame ms/f",Std.int(frame.delta * 100000) / 100.0);
    imgui.Widget.SameLine(300);
    imgui.Widget.Value("GC Memory (MiB)",frame.memory / 1024);
    imgui.Widget.Value("UPS",1.0 / frame.duration);
    imgui.Widget.SameLine(150);
    imgui.Widget.Value("update ms/f",Std.int(frame.duration * 100000) / 100.0);
    imgui.Widget.Spacing();
    local height = 0;
    local _g = 0;
    local _g1 = frame.data;
    local _hx_break_0 = false;
    while (_g < _g1.length) do 
      repeat 
      local time = _g1[_g];
      _g = _g + 1;
      if (time.marker) then 
        break;
      end;
      height = height + 1;
      
    until true
    if _hx_break_1 then _hx_break_1 = false; break; end
    end;
    local spacing = 20;
    imgui.Style.PushStyleColor("ChildWindowBg",0.0,0.0,0.0,0.5);
    imgui.Window.BeginChild("Graph",0,height * spacing,true,({"NoInputs"}));
    local _hx_1_v_f1, _hx_1_v_f2 = imgui.Window.GetContentRegionMax();
    local size_0 = _hx_1_v_f1;
    local size_1 = _hx_1_v_f2;
    local scale = frame.duration / size_0;
    local i = 0;
    local _g2 = 0;
    local _g11 = frame.data;
    local _hx_break_0 = false;
    while (_g2 < _g11.length) do 
      repeat 
      local time1 = _g11[_g2];
      _g2 = _g2 + 1;
      if (time1.marker) then 
        break;
      end;
      local key = time1.source;
      if (Profiler.pause_frame == nil) then 
        imgui.Style.PushStyleColor("Button",time1.color[1],time1.color[2],time1.color[3],0.1);
        imgui.Widget.SetCursorPosX(time1.start / scale);
        imgui.Widget.SetCursorPosY(spacing * i);
        local this1 = Profiler.slowest;
        imgui.Widget.Button("",this1.v[key] / scale,spacing);
      end;
      imgui.Style.PushStyleColor("Button",time1.color[1],time1.color[2],time1.color[3],1.0);
      imgui.Widget.SetCursorPosX(time1.start / scale);
      imgui.Widget.SetCursorPosY(spacing * i);
      imgui.Widget.Button("",time1.duration / scale,spacing);
      if (Profiler.pause_frame == nil) then 
        imgui.Style.PushStyleColor("Button",time1.color[1] / 2,time1.color[2] / 2,time1.color[3] / 2,0.75);
        imgui.Widget.SetCursorPosX(time1.start / scale);
        imgui.Widget.SetCursorPosY(spacing * i);
        local this2 = Profiler.fastest;
        imgui.Widget.Button("",this2.v[key] / scale,spacing);
        imgui.Style.PopStyleColor(3);
      else
        imgui.Style.PopStyleColor(1);
      end;
      i = i + 1;
      
    until true
    if _hx_break_1 then _hx_break_1 = false; break; end
    end;
    local _g3 = 0;
    local _g12 = frame.data;
    while (_g3 < _g12.length) do 
      local time2 = _g12[_g3];
      _g3 = _g3 + 1;
      imgui.Widget.SetCursorPosX(time2.start / scale);
      imgui.Widget.SetCursorPosY(0);
      imgui.Style.PushStyleColor("Button",time2.color[1],time2.color[2],time2.color[3],1);
      imgui.Widget.Button("",1,height * spacing);
      imgui.Style.PopStyleColor();
      end;
    i = 0;
    local _g4 = 0;
    local _g13 = frame.data;
    while (_g4 < _g13.length) do 
      local time3 = _g13[_g4];
      _g4 = _g4 + 1;
      imgui.Widget.SetCursorPosX((time3.start / scale) + 2);
      imgui.Widget.SetCursorPosY(spacing * i);
      if (not time3.marker) then 
        imgui.Widget.Text(time3.label .. " (" .. Std.string(Std.int(time3.duration * 100000) / 100.0) .. "ms)");
        i = i + 1;
      else
        imgui.Widget.Text(time3.label);
      end;
      end;
    imgui.Window.EndChild();
    imgui.Style.PopStyleColor();
  end;
  imgui.Window.End();
end
Profiler.end_frame = function() 
  if (Profiler.time_stack.head ~= nil) then 
    local str = "";
    local entry = Profiler.time_stack:iterator();
    while (entry:hasNext()) do 
      local entry1 = entry:next();
      str = str .. ("\n\t- " .. entry1.source .. " (" .. entry1.label .. ")");
      end;
    Log.write(Level.Debug,"Profiler stack dirty at end of frame. Contents: " .. str);
    while (Profiler.time_stack.head ~= nil) do 
      local _this = Profiler.time_stack;
      local k = _this.head;
      if (k ~= nil) then 
        _this.head = k.next;
      end;
      end;
  end;
  local now = love.timer.getTime();
  Profiler.this_frame.duration = now - Profiler.this_frame.start;
  Profiler.this_frame.fps = love.timer.getFPS();
  Profiler.this_frame.delta = love.timer.getDelta();
  Profiler.this_frame.memory = _G.collectgarbage("count");
  local len = Profiler.frame_history.length;
  local frame = Profiler.this_frame;
  local _g = 0;
  local _g1 = frame.data;
  while (_g < _g1.length) do 
    local seg = _g1[_g];
    _g = _g + 1;
    local key = seg.source;
    local tmp;
    local this1 = Profiler.slowest;
    if (not (not (this1.k[key] or false))) then 
      local this2 = Profiler.fastest;
      tmp = not (this2.k[key] or false);
    else
      tmp = true;
    end;
    if (tmp) then 
      local v = seg.duration;
      local _this1 = Profiler.slowest;
      _this1.v[key] = v;
      _this1.k[key] = true;
      local v1 = seg.duration;
      local _this2 = Profiler.fastest;
      _this2.v[key] = v1;
      _this2.k[key] = true;
    else
      local this3 = Profiler.slowest;
      local this4 = Profiler.slowest;
      local v2 = _G.math.max(this4.v[key],seg.duration);
      local _this3 = this3;
      _this3.v[key] = v2;
      _this3.k[key] = true;
      local this5 = Profiler.fastest;
      local this6 = Profiler.fastest;
      local v3 = _G.math.min(this6.v[key],seg.duration);
      local _this4 = this5;
      _this4.v[key] = v3;
      _this4.k[key] = true;
    end;
    end;
  if (Profiler.pause_frame ~= nil) then 
    frame = Profiler.pause_frame;
  else
    if (len > 0) then 
      local fd = haxe.ds.StringMap.new();
      frame = _hx_o({__fields__={data=true,start=true,duration=true,fps=true,delta=true,memory=true},data=_hx_tab_array({ }, 0),start=now,duration=0.0,fps=0.0,delta=0.0,memory=0.0});
      local _g2 = 0;
      local _g11 = Profiler.frame_history;
      while (_g2 < _g11.length) do 
        local f = _g11[_g2];
        _g2 = _g2 + 1;
        local frame1 = frame;
        frame1.duration = frame1.duration + f.duration;
        local frame2 = frame;
        frame2.delta = frame2.delta + f.delta;
        local frame3 = frame;
        frame3.fps = frame3.fps + f.fps;
        local frame4 = frame;
        frame4.memory = frame4.memory + f.memory;
        local _g21 = 0;
        local _g3 = f.data;
        while (_g21 < _g3.length) do 
          local seg1 = _g3[_g21];
          _g21 = _g21 + 1;
          local key1 = seg1.source;
          local key2 = seg1.source;
          if (not (fd.k[key2] or false)) then 
            local v4 = _hx_o({__fields__={color=true,marker=true,source=true,label=true,start=true,duration=true,memory=true},color=seg1.color,marker=seg1.marker,source=seg1.source,label=seg1.label,start=seg1.start,duration=seg1.duration,memory=seg1.memory});
            fd.v[key1] = v4;
            fd.k[key1] = true;
          else
            local avs = fd.v[key1];
            local avs1 = avs;
            avs1.duration = avs1.duration + seg1.duration;
            local avs2 = avs;
            avs2.start = avs2.start + seg1.start;
            local avs3 = avs;
            avs3.memory = avs3.memory + seg1.memory;
          end;
          end;
        end;
      local d = fd:iterator();
      while (d:hasNext()) do 
        local d1 = d:next();
        local d2 = d1;
        d2.duration = d2.duration / len;
        local d3 = d1;
        d3.start = d3.start / len;
        local d4 = d1;
        d4.memory = d4.memory / len;
        frame.data:push(d1);
        end;
      local frame5 = frame;
      frame5.duration = frame5.duration / len;
      local frame6 = frame;
      frame6.delta = frame6.delta / len;
      local frame7 = frame;
      frame7.fps = frame7.fps / len;
      local frame8 = frame;
      frame8.memory = frame8.memory / len;
    end;
  end;
  Profiler.render(frame);
end
Profiler.load_zone = function() 
  Profiler.first_update = 0;
end
Profiler.start_frame = function() 
  local now = love.timer.getTime();
  if (((now - Profiler.last_update) >= Profiler.sample_rate) or (Profiler.frame_history.length < Profiler.history_length)) then 
    if (Profiler.first_update < 4) then 
      Profiler.first_update = Profiler.first_update + 1;
      if (Profiler.first_update == 4) then 
        Profiler.slowest = haxe.ds.StringMap.new();
        Profiler.fastest = haxe.ds.StringMap.new();
      end;
    else
      Profiler.last_update = now;
      Profiler.frame_history:push(Profiler.this_frame);
    end;
    if (Profiler.frame_history.length > Profiler.history_length) then 
      local take = Profiler.frame_history.length - Profiler.history_length;
      Profiler.frame_history:splice(0,take);
    end;
  end;
  Profiler.this_frame = _hx_o({__fields__={data=true,start=true,duration=true,fps=true,delta=true,memory=true},data=_hx_tab_array({ }, 0),start=now,duration=0.0,fps=0.0,delta=0.0,memory=0.0});
end
Profiler.marker = function(label,color,pos) 
  if (color == nil) then 
    color = _Profiler.SegmentColor_Impl_.Default;
  end;
  Profiler.this_frame.data:push(_hx_o({__fields__={color=true,marker=true,source=true,label=true,start=true,duration=true,memory=true},color=color,marker=true,source=pos.className .. "." .. pos.methodName .. "@" .. pos.fileName .. ":" .. Std.string(pos.lineNumber) .. label,label=label,start=love.timer.getTime() - Profiler.this_frame.start,duration=0.0,memory=_G.collectgarbage("count")}));
end
Profiler.push_block = function(label,color,pos) 
  if (color == nil) then 
    color = _Profiler.SegmentColor_Impl_.Default;
  end;
  local _this = Profiler.time_stack;
  _this.head = haxe.ds.GenericCell.new(_hx_o({__fields__={color=true,marker=true,source=true,label=true,start=true,duration=true,memory=true},color=color,marker=false,source=pos.className .. "." .. pos.methodName .. "@" .. pos.fileName .. ":" .. Std.string(pos.lineNumber) .. label,label=label,start=love.timer.getTime() - Profiler.this_frame.start,duration=0.0,memory=_G.collectgarbage("count")}),_this.head);
end
Profiler.pop_block = function(pos) 
  if (Profiler.time_stack.head == nil) then 
    local source = pos.className .. "." .. pos.methodName .. "@" .. pos.fileName .. ":" .. Std.string(pos.lineNumber);
    Log.write(Level.Debug,"Attempt to pop empty profiler stack from " .. source);
    do return end;
  end;
  local _this = Profiler.time_stack;
  local block = (function() 
    local _hx_1
    if (_this.head == nil) then 
    _hx_1 = nil; else 
    _hx_1 = _this.head.elt; end
    return _hx_1
  end )();
  block.duration = (love.timer.getTime() - Profiler.this_frame.start) - block.start;
  local _this1 = Profiler.time_stack;
  local k = _this1.head;
  local tmp;
  if (k == nil) then 
    tmp = nil;
  else
    _this1.head = k.next;
    tmp = k.elt;
  end;
  Profiler.this_frame.data:push(tmp);
end

Reflect.new = {}
Reflect.__name__ = {"Reflect"}
Reflect.field = function(o,field) 
  local _hx_expected_result = {}
  local _hx_status, _hx_result = pcall(function() 
  
      do return o[field] end;
     return _hx_expected_result end)
   if not _hx_status then 
    local _hx_1 = _hx_result
    local e = _hx_1
    do return nil end;
   elseif _hx_result ~= _hx_expected_result then return _hx_result end;
end
Reflect.callMethod = function(o,func,args) 
  if ((args == nil) or (args.length == 0)) then 
    do return func(o) end;
  else
    local self_arg = false;
    if (o ~= nil) then 
      self_arg = true;
    end;
    local new_args = ({});
    local _g1 = 0;
    local _g = args.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      new_args[i + 1] = args[i];
      end;
    if (self_arg) then 
      do return func(o,_hx_table.unpack(new_args,1,_hx_table.maxn(new_args))) end;
    else
      do return func(_hx_table.unpack(new_args,1,_hx_table.maxn(new_args))) end;
    end;
  end;
end
Reflect.fields = function(o) 
  local _g = _hx_tab_array({ }, 0);
  local f = lua.Boot.fieldIterator(o);
  while (f:hasNext()) do 
    local f1 = f:next();
    _g:push(f1);
    end;
  do return _g end;
end
Reflect.isFunction = function(f) 
  if (_G.type(f) == "function") then 
    do return not ((function() 
      local _hx_1
      if (_G.type(f) ~= "table") then 
      _hx_1 = false; else 
      _hx_1 = f.__name__; end
      return _hx_1
    end )() or (function() 
      local _hx_2
      if (_G.type(f) ~= "table") then 
      _hx_2 = false; else 
      _hx_2 = f.__ename__; end
      return _hx_2
    end )()) end;
  else
    do return false end;
  end;
end
Reflect.compare = function(a,b) 
  if (a == b) then 
    do return 0 end;
  else
    if (a == nil) then 
      do return -1 end;
    else
      if (b == nil) then 
        do return 1 end;
      else
        if (a > b) then 
          do return 1 end;
        else
          do return -1 end;
        end;
      end;
    end;
  end;
end
Reflect.isEnumValue = function(v) 
  if ((v ~= nil) and lua.Boot.__instanceof(v,_G.table)) then 
    do return v.__enum__ ~= nil end;
  else
    do return false end;
  end;
end

Signal.new = {}
Signal.__name__ = {"Signal"}
Signal.register = function(event,fn) 
  local this1 = Signal.signals;
  if (not (this1.k[event] or false)) then 
    local v = _hx_tab_array({ }, 0);
    local _this = Signal.signals;
    _this.v[event] = v;
    _this.k[event] = true;
  end;
  local this2 = Signal.signals;
  this2.v[event]:push(fn);
end
Signal.emit = function(event,data) 
  local this1 = Signal.signals;
  if (not (this1.k[event] or false)) then 
    do return end;
  end;
  local this2 = Signal.signals;
  local cbs = this2.v[event];
  local _g = 0;
  while (_g < cbs.length) do 
    local cb = cbs[_g];
    _g = _g + 1;
    cb(data);
    end;
end

StringBuf.new = function() 
  local self = _hx_new(StringBuf.prototype)
  StringBuf.super(self)
  return self
end
StringBuf.super = function(self) 
  self.b = _hx_e();
  self.length = 0;
end
StringBuf.__name__ = {"StringBuf"}
StringBuf.prototype = _hx_a(
  
  '__class__',  StringBuf
)

StringTools.new = {}
StringTools.__name__ = {"StringTools"}
StringTools.lpad = function(s,c,l) 
  if (c.length <= 0) then 
    do return s end;
  end;
  while (s.length < l) do 
    s = c .. s;
    end;
  do return s end;
end

System.new = function(_fixed_tick) 
  local self = _hx_new(System.prototype)
  System.super(self,_fixed_tick)
  return self
end
System.super = function(self,_fixed_tick) 
  if (_fixed_tick == nil) then 
    _fixed_tick = false;
  end;
  self.fixed_tick = _fixed_tick;
  local cn = Type.getClassName(Type.getClass(self));
  local idx = cn:lastIndexOf(".") + 1;
  self.PROFILE_NAME = cn:substr(idx);
  local crc = haxe.crypto.Crc32.make(haxe.io.Bytes.ofString(cn));
  local r = (_hx_bit.band(_hx_bit.arshift(crc,24),255)) / 255.0;
  local g = (_hx_bit.band(_hx_bit.arshift(crc,16),255)) / 255.0;
  local b = (_hx_bit.band(_hx_bit.arshift(crc,8),255)) / 255.0;
  local this1 = math._Vec3.Vec3_Impl_._new(r,g,b);
  self.PROFILE_COLOR = this1;
end
System.__name__ = {"System"}
System.prototype = _hx_a(
  'filter', function(self,e) 
    do return false end
  end,
  'update', function(self,entities,dt) 
  end,
  'process', function(self,e,dt) 
  end
  ,'__class__',  System
)

_Time.ClockTime_Impl_.new = {}
_Time.ClockTime_Impl_.__name__ = {"_Time","ClockTime_Impl_"}
_Time.ClockTime_Impl_._new = function(v) 
  local this1 = v;
  do return this1 end;
end
_Time.ClockTime_Impl_.from_hour = function(v) 
  do return _Time.ClockTime_Impl_._new((v / 1.) * 60.0) end;
end

GameTime.new = {}
GameTime.__name__ = {"GameTime"}
GameTime.init = function() 
  GameTime.time = _Time.ClockTime_Impl_.from_hour(12);
end
GameTime.wrap_clock = function() 
  local now = GameTime.time;
  while (now >= 1440.) do 
    now = now - 1440.;
    GameTime.time = _Time.ClockTime_Impl_._new(now);
    local tmp = GameTime;
    tmp.day = tmp.day + 1;
    end;
end
GameTime.update_sun = function() 
  local now = GameTime.time;
  local rotation = math._Quat.Quat_Impl_.from_angle_axis(_G.math.rad(-90.0),math._Vec3.Vec3_Impl_._new(0,0,1));
  rotation = math._Quat.Quat_Impl_.mul(rotation,math._Quat.Quat_Impl_.from_angle_axis(((now * (_G.math.pi * 2)) / 60) / 24.0,math._Vec3.Vec3_Impl_._new(1,0,0)));
  local basis = math._Vec3.Vec3_Impl_._new(0,0,-1);
  math._Vec3.Vec3_Impl_.normalize(basis);
  GameTime.sun_direction = math._Quat.Quat_Impl_.mul_vec3(rotation,basis);
  local _g = GameTime.sun_direction;
  local v = _g[3] + (_G.math.sin(((GameTime.day / 40.0) * _G.math.pi) * 2.0) * GameTime.SEASON_INFLUENCE);
  _g[3] = v;
  math._Vec3.Vec3_Impl_.normalize(GameTime.sun_direction);
  local a = GameTime.sun_direction;
  local b = math._Vec3.Vec3_Impl_._new(0,0,1);
  GameTime.sun_brightness = _G.math.pow(math.Utils.clamp((((a[1] * b[1]) + (a[2] * b[2])) + (a[3] * b[3])) + 0.35,0,1),3);
end
GameTime.update = function(dt) 
  local tmp = GameTime;
  tmp.time = tmp.time + (dt * GameTime.TIME_SCALE);
  local now = GameTime.time;
  while (now >= 1440.) do 
    now = now - 1440.;
    GameTime.time = _Time.ClockTime_Impl_._new(now);
    local tmp1 = GameTime;
    tmp1.day = tmp1.day + 1;
    end;
  local now1 = GameTime.time;
  local rotation = math._Quat.Quat_Impl_.from_angle_axis(_G.math.rad(-90.0),math._Vec3.Vec3_Impl_._new(0,0,1));
  rotation = math._Quat.Quat_Impl_.mul(rotation,math._Quat.Quat_Impl_.from_angle_axis(((now1 * (_G.math.pi * 2)) / 60) / 24.0,math._Vec3.Vec3_Impl_._new(1,0,0)));
  local basis = math._Vec3.Vec3_Impl_._new(0,0,-1);
  math._Vec3.Vec3_Impl_.normalize(basis);
  GameTime.sun_direction = math._Quat.Quat_Impl_.mul_vec3(rotation,basis);
  local _g = GameTime.sun_direction;
  local v = _g[3] + (_G.math.sin(((GameTime.day / 40.0) * _G.math.pi) * 2.0) * GameTime.SEASON_INFLUENCE);
  _g[3] = v;
  math._Vec3.Vec3_Impl_.normalize(GameTime.sun_direction);
  local a = GameTime.sun_direction;
  local b = math._Vec3.Vec3_Impl_._new(0,0,1);
  GameTime.sun_brightness = _G.math.pow(math.Utils.clamp((((a[1] * b[1]) + (a[2] * b[2])) + (a[3] * b[3])) + 0.35,0,1),3);
end

TimerAction.new = {}
TimerAction.__name__ = {"TimerAction"}
TimerAction.add = function(length,subject,target,type,cb) 
  local _self = subject;
  local timer = _hx_o({__fields__={time=true,length=true,subject=true,original=true,target=true,type=true,cb=true},time=0,length=length,subject=subject,original=math._Vec3.Vec3_Impl_._new(_self[1],_self[2],_self[3]),target=target,type=type,cb=cb});
  TimerAction.timers:push(timer);
end
TimerAction.update = function(dt) 
  local i = TimerAction.timers.length;
  while (true) do 
    i = i - 1;
    if (not ((i + 1) > 0)) then 
      break;
    end;
    local timer = TimerAction.timers[i];
    local timer1 = timer;
    timer1.time = timer1.time + dt;
    if (timer.time >= timer.length) then 
      timer.time = timer.length;
    end;
    local progress = timer.time / timer.length;
    local tween = TimerAction.tween_for(timer.type);
    local new_subject = math._Vec3.Vec3_Impl_.lerp(timer.original,timer.target,tween(progress));
    local v = new_subject[1];
    timer.subject[1] = v;
    local v1 = new_subject[2];
    timer.subject[2] = v1;
    local v2 = new_subject[3];
    timer.subject[3] = v2;
    if (timer.time == timer.length) then 
      if (timer.cb ~= nil) then 
        timer:cb();
      end;
      TimerAction.timers:remove(timer);
    end;
    end;
end
TimerAction.tween_for = function(type) 
  local quad = function(t) 
    do return t * t end;
  end;
  local cubic = function(t1) 
    do return (t1 * t1) * t1 end;
  end;
  local type1 = type[1];
  if (type1) == 0 then 
    do return function(t2) 
      do return 0 end;
    end end;
  elseif (type1) == 1 then 
    do return function(t3) 
      do return t3 end;
    end end;
  elseif (type1) == 2 then 
    do return quad end;
  elseif (type1) == 3 then 
    do return cubic end;
  elseif (type1) == 4 then 
    local f = quad;
    do return function(s) 
      do return 1 - f(1 - s) end;
    end end;
  elseif (type1) == 5 then 
    local f1 = cubic;
    do return function(s1) 
      do return 1 - f1(1 - s1) end;
    end end;
  elseif (type1) == 6 then 
    local f11 = quad;
    local f2 = quad;
    local f21 = function(s2) 
      do return 1 - f2(1 - s2) end;
    end;
    do return function(s3) 
      do return (function() 
        local _hx_1
        if (s3 < .5) then 
        _hx_1 = f11(2 * s3); else 
        _hx_1 = 1 + f21((2 * s3) - 1); end
        return _hx_1
      end )() * .5 end;
    end end;
  elseif (type1) == 7 then 
    local f12 = cubic;
    local f3 = cubic;
    local f22 = function(s4) 
      do return 1 - f3(1 - s4) end;
    end;
    do return function(s5) 
      do return (function() 
        local _hx_2
        if (s5 < .5) then 
        _hx_2 = f12(2 * s5); else 
        _hx_2 = 1 + f22((2 * s5) - 1); end
        return _hx_2
      end )() * .5 end;
    end end; end;
end

TimerScript.new = {}
TimerScript.__name__ = {"TimerScript"}
TimerScript.add = function(f) 
  local routine = _hx_o({__fields__={resume=true,delay=true},resume=coroutine.wrap(function(_, ...) f(...) end),delay=0});
  TimerScript.routines:push(routine);
  routine:resume(function(delay) 
    local tmp = _G.math.abs(routine.delay);
    routine.delay = delay - tmp;
    _G.coroutine.yield();
  end);
end
TimerScript.update = function(dt) 
  local i = TimerScript.routines.length;
  while (true) do 
    i = i - 1;
    if (not ((i + 1) > 0)) then 
      break;
    end;
    local routine = TimerScript.routines[i];
    local routine1 = routine;
    routine1.delay = routine1.delay - dt;
    if (routine.delay <= 0) then 
      if (not _G.pcall(routine.resume)) then 
        TimerScript.routines:remove(routine);
      end;
    end;
    end;
end
_hxClasses["ValueType"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="TNull","TInt","TFloat","TBool","TObject","TFunction","TClass","TEnum","TUnknown"},9)}
ValueType = _hxClasses["ValueType"];
ValueType.TNull = _hx_tab_array({[0]="TNull",0,__enum__ = ValueType},2)

ValueType.TInt = _hx_tab_array({[0]="TInt",1,__enum__ = ValueType},2)

ValueType.TFloat = _hx_tab_array({[0]="TFloat",2,__enum__ = ValueType},2)

ValueType.TBool = _hx_tab_array({[0]="TBool",3,__enum__ = ValueType},2)

ValueType.TObject = _hx_tab_array({[0]="TObject",4,__enum__ = ValueType},2)

ValueType.TFunction = _hx_tab_array({[0]="TFunction",5,__enum__ = ValueType},2)

ValueType.TClass = function(c) local _x = _hx_tab_array({[0]="TClass",6,c,__enum__=ValueType}, 3); return _x; end 
ValueType.TEnum = function(e) local _x = _hx_tab_array({[0]="TEnum",7,e,__enum__=ValueType}, 3); return _x; end 
ValueType.TUnknown = _hx_tab_array({[0]="TUnknown",8,__enum__ = ValueType},2)

ValueType.__empty_constructs__ = _hx_tab_array({[0] = ValueType.TNull,ValueType.TInt,ValueType.TFloat,ValueType.TBool,ValueType.TObject,ValueType.TFunction,ValueType.TUnknown}, 7)

Type.new = {}
Type.__name__ = {"Type"}
Type.getClass = function(o) 
  if (o == nil) then 
    do return nil end;
  end;
  if (lua.Boot.__instanceof(o,Array)) then 
    do return Array end;
  else
    local cl = o.__class__;
    if (cl ~= nil) then 
      do return cl end;
    else
      do return nil end;
    end;
  end;
end
Type.getClassName = function(c) 
  if (c.__name__ == nil) then 
    do return nil end;
  end;
  do return _G.table.concat(c.__name__,".") end;
end
Type.createEnum = function(e,constr,params) 
  local f = Reflect.field(e,constr);
  if (f == nil) then 
    _G.error("No such constructor " .. constr,0);
  end;
  if (Reflect.isFunction(f)) then 
    if (params == nil) then 
      _G.error("Constructor " .. constr .. " need parameters",0);
    end;
    do return Reflect.callMethod(nil,f,params) end;
  end;
  if ((params ~= nil) and (params.length ~= 0)) then 
    _G.error("Constructor " .. constr .. " does not need parameters",0);
  end;
  do return f end;
end
Type.createEnumIndex = function(e,index,params) 
  local c = e.__constructs__[index];
  if (c == nil) then 
    _G.error(index .. " is not a valid enum constructor index",0);
  end;
  do return Type.createEnum(e,c,params) end;
end
Type.typeof = function(v) 
  local _g = _G.type(v);
  local _g1 = _g;
  if (_g1) == "boolean" then 
    do return ValueType.TBool end;
  elseif (_g1) == "function" then 
    if ((function() 
      local _hx_1
      if (_G.type(v) ~= "table") then 
      _hx_1 = false; else 
      _hx_1 = v.__name__; end
      return _hx_1
    end )() or (function() 
      local _hx_2
      if (_G.type(v) ~= "table") then 
      _hx_2 = false; else 
      _hx_2 = v.__ename__; end
      return _hx_2
    end )()) then 
      do return ValueType.TObject end;
    end;
    do return ValueType.TFunction end;
  elseif (_g1) == "nil" then 
    do return ValueType.TNull end;
  elseif (_g1) == "number" then 
    if (_G.math.ceil(v) == (_G.math.fmod(v, 2147483648.0))) then 
      do return ValueType.TInt end;
    end;
    do return ValueType.TFloat end;
  elseif (_g1) == "string" then 
    do return ValueType.TClass(String) end;
  elseif (_g1) == "table" then 
    local e = v.__enum__;
    if (e ~= nil) then 
      do return ValueType.TEnum(e) end;
    end;
    local c;
    if (lua.Boot.__instanceof(v,Array)) then 
      c = Array;
    else
      local cl = v.__class__;
      if (cl ~= nil) then 
        c = cl;
      else
        c = nil;
      end;
    end;
    if (c ~= nil) then 
      do return ValueType.TClass(c) end;
    end;
    do return ValueType.TObject end;else
  do return ValueType.TUnknown end; end;
end
Type.allEnums = function(e) 
  do return e.__empty_constructs__ end;
end

VirtualTile.new = function(base,x,y) 
  local self = _hx_new(VirtualTile.prototype)
  VirtualTile.super(self,base,x,y)
  return self
end
VirtualTile.super = function(self,base,x,y) 
  self.world_tile = base;
  self.x = x;
  self.y = y;
end
VirtualTile.__name__ = {"VirtualTile"}
VirtualTile.prototype = _hx_a(
  'get_triangles', function(self,min,max) 
    local scale = World.tile_size;
    local push = math._Vec3.Vec3_Impl_._new(scale * self.x,scale * self.y,0.0);
    local tris = self.world_tile:get_triangles(math._Vec3.Vec3_Impl_.sub(min,push),math._Vec3.Vec3_Impl_.sub(max,push));
    local final_tris = _hx_tab_array({ }, 0);
    local _g = 0;
    while (_g < tris.length) do 
      local tri = tris[_g];
      _g = _g + 1;
      local t = math.Triangle.new(math._Vec3.Vec3_Impl_.add(tri.v0,push),math._Vec3.Vec3_Impl_.add(tri.v1,push),math._Vec3.Vec3_Impl_.add(tri.v2,push),tri.vn);
      final_tris:push(t);
      end;
    do return final_tris end
  end
  ,'__class__',  VirtualTile
)

WorldTile.new = function(_x,_y) 
  local self = _hx_new(WorldTile.prototype)
  WorldTile.super(self,_x,_y)
  return self
end
WorldTile.super = function(self,_x,_y) 
  local mid = math._Vec3.Vec3_Impl_._new(World.tile_size / 2,World.tile_size / 2,World.tile_size / 2);
  self.tri_octree = math.Octree.new(World.tile_size,mid,2.0,WorldTile.octree_looseness);
  self.entities = _hx_tab_array({ }, 0);
  self.x = _x;
  self.y = _y;
  self.filename = "assets/maps/zones/tile_" .. self.x .. "x" .. self.y .. ".fresh";
end
WorldTile.__name__ = {"WorldTile"}
WorldTile.prototype = _hx_a(
  'get_triangles', function(self,min,max) 
    local size = math._Vec3.Vec3_Impl_.sub(max,min);
    local center = math._Vec3.Vec3_Impl_.add(min,math._Vec3.Vec3_Impl_.fdiv(size,2));
    local tris = self.tri_octree:get_colliding(math.Bounds.new(center,size));
    do return tris end
  end,
  'add_triangle', function(self,xt) 
    local _self = xt.v0;
    local min = math._Vec3.Vec3_Impl_._new(_self[1],_self[2],_self[3]);
    min[1] = _G.math.min(min[1],xt.v1[1]);
    min[1] = _G.math.min(min[1],xt.v2[1]);
    min[2] = _G.math.min(min[2],xt.v1[2]);
    min[2] = _G.math.min(min[2],xt.v2[2]);
    min[3] = _G.math.min(min[3],xt.v1[3]);
    min[3] = _G.math.min(min[3],xt.v2[3]);
    local min1 = min;
    local self1 = xt.v0;
    local max = math._Vec3.Vec3_Impl_._new(self1[1],self1[2],self1[3]);
    max[1] = _G.math.max(max[1],xt.v1[1]);
    max[1] = _G.math.max(max[1],xt.v2[1]);
    max[2] = _G.math.max(max[2],xt.v1[2]);
    max[2] = _G.math.max(max[2],xt.v2[2]);
    max[3] = _G.math.max(max[3],xt.v1[3]);
    max[3] = _G.math.max(max[3],xt.v2[3]);
    local max1 = max;
    self.tri_octree:add(xt,math.Bounds.from_extents(min1,max1));
  end,
  'nearest_hit', function(self,ray) 
    local nearest = 1e20;
    local closest_tri = nil;
    local closest_hit = nil;
    self.tri_octree:cast_ray(ray,function(r,entries) 
      local _g = 0;
      while (_g < entries.length) do 
        local entry = entries[_g];
        _g = _g + 1;
        if (math.Intersect.ray_aabb(ray,entry.bounds) ~= nil) then 
          local hit = math.Intersect.ray_triangle(ray,entry.data);
          if (hit ~= nil) then 
            local a = ray.position;
            local b = hit.point;
            local dx = a[1] - b[1];
            local dy = a[2] - b[2];
            local dz = a[3] - b[3];
            local d = _G.math.sqrt(((dx * dx) + (dy * dy)) + (dz * dz));
            if (d < nearest) then 
              nearest = d;
              closest_tri = entry.data;
              closest_hit = hit.point;
            end;
          end;
        end;
        end;
      do return false end;
    end);
    if ((closest_hit == nil) or (closest_tri == nil)) then 
      do return nil end;
    end;
    do return _hx_o({__fields__={distance=true,triangle=true,point=true},distance=nearest,triangle=closest_tri,point=closest_hit}) end
  end
  ,'__class__',  WorldTile
)

World.new = {}
World.__name__ = {"World"}
World.tile_at = function(world_pos) 
  local xw = _G.math.fmod(world_pos[1], (World.tiles_x * World.tile_size));
  local yw = _G.math.fmod(world_pos[2], (World.tiles_y * World.tile_size));
  local x = Std.int(xw / World.tile_size);
  local y = Std.int(yw / World.tile_size);
  local idx = (y * World.tiles_x) + x;
  local _tmp0 = World.tiles;
  local _tmp1 = idx;
  local _tmp2 = _tmp0[_tmp1];
  local _tmp3 = _tmp2 ~= nil;
  if (not _tmp3) then 
    _G.error(utils.AssertionFailure.new("tiles[idx] != null",_hx_tab_array({[0]=_hx_o({__fields__={expr=true,value=true},expr="tiles",value=_tmp0}), _hx_o({__fields__={expr=true,value=true},expr="idx",value=_tmp1}), _hx_o({__fields__={expr=true,value=true},expr="tiles[idx]",value=_tmp2}), _hx_o({__fields__={expr=true,value=true},expr="tiles[idx] != null",value=_tmp3}) }, 4),"invalid tile"),0);
  end;
  do return World.tiles[idx] end;
end
World.virtual_tile_at = function(world_pos) 
  local x = _G.math.floor(world_pos[1] / World.tile_size);
  local y = _G.math.floor(world_pos[2] / World.tile_size);
  local real = World.tile_at(world_pos);
  do return VirtualTile.new(real,x,y) end;
end
World.to_local = function(world_pos) 
  do return math._Vec3.Vec3_Impl_._new(math.Utils.wrap(world_pos[1],World.tile_size),math.Utils.wrap(world_pos[2],World.tile_size),world_pos[3]) end;
end
World.to_world = function(local_pos,tile_x,tile_y) 
  do return math._Vec3.Vec3_Impl_._new(local_pos[1] + (tile_x * World.tile_size),local_pos[2] + (tile_y * World.tile_size),local_pos[3]) end;
end
World.nearest_hit = function(ray) 
  local tile = World.tile_at(ray.position);
  local local_ray = math.Ray.new(World.to_local(ray.position),ray.direction);
  do return tile:nearest_hit(local_ray) end;
end
World.is_local = function() 
  do return World.is_local_map end;
end
World.init = function(p) 
  World.player = p;
  World.movement = systems.Movement.new(true);
  World.tiles = _hx_tab_array({ }, 0);
  local n = World.tiles_x * World.tiles_y;
  local _g1 = 0;
  local _g = n;
  while (_g1 < _g) do 
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    local x = _G.math.fmod(i, World.tiles_x);
    local y = Std.int(i / World.tiles_x);
    World.tiles:push(WorldTile.new(x,y));
    end;
  World.systems = _hx_tab_array({[0]=systems.Loader.new(), p, systems.PlayerController.new(true), World.movement, systems.Animation.new(), systems.Trigger.new(true), systems.Audio.new(), systems.Hud.new(), systems.Render.new(), systems.WeatherSystem.new() }, 10);
  systems.Trigger.register_signals();
end
World.get_adjacent_tiles = function(center) 
  local origin_tile = World.virtual_tile_at(center);
  local half_tile = math._Vec3.Vec3_Impl_._new(World.tile_size / 2,World.tile_size / 2,0);
  local t_min = math._Vec3.Vec3_Impl_.sub(center,half_tile);
  local t_max = math._Vec3.Vec3_Impl_.add(center,half_tile);
  local adjacent_tiles = _hx_tab_array({[0]=origin_tile, World.virtual_tile_at(math._Vec3.Vec3_Impl_._new(center[1],t_min[2],0.0)), World.virtual_tile_at(math._Vec3.Vec3_Impl_._new(center[1],t_max[2],0.0)), World.virtual_tile_at(math._Vec3.Vec3_Impl_._new(t_min[1],center[2],0.0)), World.virtual_tile_at(math._Vec3.Vec3_Impl_._new(t_max[1],center[2],0.0)), World.virtual_tile_at(math._Vec3.Vec3_Impl_._new(t_min[1],t_min[2],0.0)), World.virtual_tile_at(math._Vec3.Vec3_Impl_._new(t_min[1],t_max[2],0.0)), World.virtual_tile_at(math._Vec3.Vec3_Impl_._new(t_max[1],t_min[2],0.0)), World.virtual_tile_at(math._Vec3.Vec3_Impl_._new(t_max[1],t_max[2],0.0)) }, 9);
  local unique_tiles = _hx_tab_array({ }, 0);
  local _g = 0;
  while (_g < adjacent_tiles.length) do 
    local t = adjacent_tiles[_g];
    _g = _g + 1;
    local found = false;
    local _g1 = 0;
    while (_g1 < unique_tiles.length) do 
      local unique = unique_tiles[_g1];
      _g1 = _g1 + 1;
      if ((t.x == unique.x) and (t.y == unique.y)) then 
        found = true;
        break;
      end;
      end;
    if (not found) then 
      unique_tiles:push(t);
    end;
    end;
  do return unique_tiles end;
end
World.get_triangles = function(min,max) 
  local size = math._Vec3.Vec3_Impl_.sub(max,min);
  local center = math._Vec3.Vec3_Impl_.add(min,math._Vec3.Vec3_Impl_.fdiv(size,2));
  local tris = _hx_tab_array({ }, 0);
  local nearby = World.get_adjacent_tiles(center);
  local half_tile = math._Vec3.Vec3_Impl_._new(World.tile_size / 2,World.tile_size / 2,100);
  local _g = 0;
  while (_g < nearby.length) do 
    local t = nearby[_g];
    _g = _g + 1;
    local tile_tris = t:get_triangles(min,max);
    local _g1 = 0;
    while (_g1 < tile_tris.length) do 
      local tri = tile_tris[_g1];
      _g1 = _g1 + 1;
      tris:push(tri);
      end;
    end;
  do return tris end;
end
World.get_triangles_frustum = function(frustum) 
  local tris = _hx_tab_array({ }, 0);
  local _g = 0;
  local _g1 = World.visible_tiles;
  while (_g < _g1.length) do 
    local vtile = _g1[_g];
    _g = _g + 1;
    local tile = vtile.world_tile;
    local tmp_tris = tile:get_triangles(math._Vec3.Vec3_Impl_._new(0,0,-1000),math._Vec3.Vec3_Impl_._new(World.tile_size,World.tile_size,1000));
    local _g2 = 0;
    while (_g2 < tmp_tris.length) do 
      local t = tmp_tris[_g2];
      _g2 = _g2 + 1;
      tris:push(math.Triangle.new(World.to_world(t.v0,vtile.x,vtile.y),World.to_world(t.v1,vtile.x,vtile.y),World.to_world(t.v2,vtile.x,vtile.y),t.vn));
      end;
    end;
  do return tris end;
end
World.add_triangles = function(tile,xform,tris) 
  local _g = 0;
  while (_g < tris.length) do 
    local t = tris[_g];
    _g = _g + 1;
    local xt = math.Triangle.new(math._Mat4.Mat4_Impl_.mul_vec3(xform,t.v0),math._Mat4.Mat4_Impl_.mul_vec3(xform,t.v1),math._Mat4.Mat4_Impl_.mul_vec3(xform,t.v2),math._Mat4.Mat4_Impl_.mul_vec3(xform,t.vn));
    local _self = xt.v0;
    local min = math._Vec3.Vec3_Impl_._new(_self[1],_self[2],_self[3]);
    min[1] = _G.math.min(min[1],xt.v1[1]);
    min[1] = _G.math.min(min[1],xt.v2[1]);
    min[2] = _G.math.min(min[2],xt.v1[2]);
    min[2] = _G.math.min(min[2],xt.v2[2]);
    min[3] = _G.math.min(min[3],xt.v1[3]);
    min[3] = _G.math.min(min[3],xt.v2[3]);
    local min1 = min;
    local self1 = xt.v0;
    local max = math._Vec3.Vec3_Impl_._new(self1[1],self1[2],self1[3]);
    max[1] = _G.math.max(max[1],xt.v1[1]);
    max[1] = _G.math.max(max[1],xt.v2[1]);
    max[2] = _G.math.max(max[2],xt.v1[2]);
    max[2] = _G.math.max(max[2],xt.v2[2]);
    max[3] = _G.math.max(max[3],xt.v1[3]);
    max[3] = _G.math.max(max[3],xt.v2[3]);
    local max1 = max;
    tile:add_triangle(xt);
    end;
end
World.new_entities = function(new_path,new_entities) 
  World.entities = new_entities;
  World.path = new_path;
  World.is_local_map = love.filesystem.getRealDirectory(World.path):indexOf(love.filesystem.getSaveDirectory()) >= 0;
  World.rebuild_octree();
end
World.reload = function() 
  Zone.load(World.path);
end
World.rebuild_octree = function() 
  local _g = 0;
  local _g1 = World.entities;
  local _hx_break_0 = false;
  while (_g < _g1.length) do 
    repeat 
    local e = _g1[_g];
    _g = _g + 1;
    if ((e.drawable == nil) or (e.transform == nil)) then 
      break;
    end;
    if (e.drawable.collision == components.CollisionType.Triangle) then 
      e.drawable.mesh = nil;
    end;
    
  until true
  if _hx_break_1 then _hx_break_1 = false; break; end
  end;
end
World.save = function() 
  Zone.save(World.path);
  World.is_local_map = love.filesystem.getRealDirectory(World.path):indexOf(love.filesystem.getSaveDirectory()) >= 0;
  World.rebuild_octree();
end
World.refresh_entity = function(old_tile,new_tile,e,add) 
  if (not add) then 
    old_tile.entities:remove(e);
  end;
  new_tile.entities:push(e);
end
World.add = function(to_add) 
  World.entities:push(to_add);
end
World.remove = function(to_remove) 
  World.entities:remove(to_remove);
  local d = to_remove.drawable;
  if (((to_remove.transform ~= nil) and (d ~= nil)) and (d.mesh ~= nil)) then 
    local _this = to_remove.transform;
    local tile = World.tile_at(World.to_world(_this.position,_this.tile_x,_this.tile_y));
    tile.entities:remove(to_remove);
    World.movement:remove(to_remove);
  end;
end
World.get_tile = function(x,y) 
  local tx = _G.math.floor(x);
  local ty = _G.math.floor(y);
  local _tmp0 = tx;
  local _tmp1 = _tmp0 >= 0;
  local _tmp2 = ty;
  local _tmp3 = _tmp2 >= 0;
  local _tmp4 = _tmp1 and _tmp3;
  local _tmp5 = tx;
  local _tmp6 = World.tiles_x;
  local _tmp7 = _tmp5 < _tmp6;
  local _tmp8 = _tmp4 and _tmp7;
  local _tmp9 = ty;
  local _tmp10 = World.tiles_y;
  local _tmp11 = _tmp9 < _tmp10;
  local _tmp12 = _tmp8 and _tmp11;
  if (not _tmp12) then 
    _G.error(utils.AssertionFailure.new("tx >= 0 && ty >= 0 && tx < tiles_x && ty < tiles_y",_hx_tab_array({[0]=_hx_o({__fields__={expr=true,value=true},expr="tx",value=_tmp0}), _hx_o({__fields__={expr=true,value=true},expr="tx >= 0",value=_tmp1}), _hx_o({__fields__={expr=true,value=true},expr="ty",value=_tmp2}), _hx_o({__fields__={expr=true,value=true},expr="ty >= 0",value=_tmp3}), _hx_o({__fields__={expr=true,value=true},expr="tx >= 0 && ty >= 0",value=_tmp4}), _hx_o({__fields__={expr=true,value=true},expr="tx",value=_tmp5}), _hx_o({__fields__={expr=true,value=true},expr="tiles_x",value=_tmp6}), _hx_o({__fields__={expr=true,value=true},expr="tx < tiles_x",value=_tmp7}), _hx_o({__fields__={expr=true,value=true},expr="tx >= 0 && ty >= 0 && tx < tiles_x",value=_tmp8}), _hx_o({__fields__={expr=true,value=true},expr="ty",value=_tmp9}), _hx_o({__fields__={expr=true,value=true},expr="tiles_y",value=_tmp10}), _hx_o({__fields__={expr=true,value=true},expr="ty < tiles_y",value=_tmp11}), _hx_o({__fields__={expr=true,value=true},expr="tx >= 0 && ty >= 0 && tx < tiles_x && ty < tiles_y",value=_tmp12}) }, 13),"Invalid tile index"),0);
  end;
  local idx = (ty * World.tiles_x) + tx;
  local _tmp01 = World.tiles;
  local _tmp13 = idx;
  local _tmp21 = _tmp01[_tmp13];
  local _tmp31 = _tmp21 ~= nil;
  if (not _tmp31) then 
    _G.error(utils.AssertionFailure.new("tiles[idx] != null",_hx_tab_array({[0]=_hx_o({__fields__={expr=true,value=true},expr="tiles",value=_tmp01}), _hx_o({__fields__={expr=true,value=true},expr="idx",value=_tmp13}), _hx_o({__fields__={expr=true,value=true},expr="tiles[idx]",value=_tmp21}), _hx_o({__fields__={expr=true,value=true},expr="tiles[idx] != null",value=_tmp31}) }, 4),"Invalid tile for valid index"),0);
  end;
  do return World.tiles[idx] end;
end
World.render_triangle = function(frustum,vis_tiles,mx,my,w,h,x0,y0,x1,y1,x2,y2) 
  local minimum_x = _G.math.floor(_G.math.min(_G.math.min(x0,x1),x2));
  local minimum_y = _G.math.floor(_G.math.min(_G.math.min(y0,y1),y2));
  local maximum_x = _G.math.ceil(_G.math.max(_G.math.max(x0,x1),x2));
  local maximum_y = _G.math.ceil(_G.math.max(_G.math.max(y0,y1),y2));
  local _g1 = minimum_y;
  local _g = maximum_y;
  while (_g1 < _g) do 
    _g1 = _g1 + 1;
    local y = _g1 - 1;
    local _g3 = minimum_x;
    local _g2 = maximum_x;
    while (_g3 < _g2) do 
      _g3 = _g3 + 1;
      local x = _g3 - 1;
      local w0 = ((x2 - x1) * (y - y1)) - ((y2 - y1) * (x - x1));
      local w1 = ((x0 - x2) * (y - y2)) - ((y0 - y2) * (x - x2));
      local w2 = ((x1 - x0) * (y - y0)) - ((y1 - y0) * (x - x0));
      if (((w0 >= 0) and (w1 >= 0)) and (w2 >= 0)) then 
        local vx = _G.math.floor(mx + x);
        local vy = _G.math.floor(my + y);
        local tx = _G.math.floor(math.Utils.wrap(vx,World.tiles_x));
        local ty = _G.math.floor(math.Utils.wrap(vy,World.tiles_y));
        local tile = World.get_tile(tx,ty);
        local min = math._Vec3.Vec3_Impl_._new(vx * World.tile_size,vy * World.tile_size,-1000);
        local max = math._Vec3.Vec3_Impl_._new(min[1] + World.tile_size,min[2] + World.tile_size,1000);
        if (math.Intersect.aabb_frustum(math.Bounds.from_extents(min,max),frustum)) then 
          vis_tiles:push(VirtualTile.new(tile,vx,vy));
        end;
      end;
      end;
    end;
end
World.update_visible = function(world_tri,frustum) 
  World.visible_tiles = _hx_tab_array({ }, 0);
  local offset = math._Vec3.Vec3_Impl_.scale(math._Vec3.Vec3_Impl_._new(-0.5,-0.5,0),0);
  local tile_tri_vn;
  local tile_tri_v2;
  local tile_tri_v1;
  local tile_tri_v0 = math._Vec3.Vec3_Impl_.add(math._Vec3.Vec3_Impl_.fdiv(world_tri.v0,World.tile_size),offset);
  tile_tri_v1 = math._Vec3.Vec3_Impl_.add(math._Vec3.Vec3_Impl_.fdiv(world_tri.v1,World.tile_size),offset);
  tile_tri_v2 = math._Vec3.Vec3_Impl_.add(math._Vec3.Vec3_Impl_.fdiv(world_tri.v2,World.tile_size),offset);
  tile_tri_vn = world_tri.vn;
  local center = math._Vec3.Vec3_Impl_.add(math._Vec3.Vec3_Impl_.add(tile_tri_v0,tile_tri_v1),tile_tri_v2);
  center = math._Vec3.Vec3_Impl_.fdiv(center,3);
  local expand = 2.5;
  tile_tri_v0 = math._Vec3.Vec3_Impl_.add(center,math._Vec3.Vec3_Impl_.scale(math._Vec3.Vec3_Impl_.sub(tile_tri_v0,center),expand));
  tile_tri_v1 = math._Vec3.Vec3_Impl_.add(center,math._Vec3.Vec3_Impl_.scale(math._Vec3.Vec3_Impl_.sub(tile_tri_v1,center),expand));
  tile_tri_v2 = math._Vec3.Vec3_Impl_.add(center,math._Vec3.Vec3_Impl_.scale(math._Vec3.Vec3_Impl_.sub(tile_tri_v2,center),expand));
  local _self = tile_tri_v0;
  local min = math._Vec3.Vec3_Impl_._new(_self[1],_self[2],_self[3]);
  min[1] = _G.math.min(min[1],tile_tri_v1[1]);
  min[1] = _G.math.min(min[1],tile_tri_v2[1]);
  min[2] = _G.math.min(min[2],tile_tri_v1[2]);
  min[2] = _G.math.min(min[2],tile_tri_v2[2]);
  min[3] = _G.math.min(min[3],tile_tri_v1[3]);
  min[3] = _G.math.min(min[3],tile_tri_v2[3]);
  local min1 = min;
  local self1 = tile_tri_v0;
  local max = math._Vec3.Vec3_Impl_._new(self1[1],self1[2],self1[3]);
  max[1] = _G.math.max(max[1],tile_tri_v1[1]);
  max[1] = _G.math.max(max[1],tile_tri_v2[1]);
  max[2] = _G.math.max(max[2],tile_tri_v1[2]);
  max[2] = _G.math.max(max[2],tile_tri_v2[2]);
  max[3] = _G.math.max(max[3],tile_tri_v1[3]);
  max[3] = _G.math.max(max[3],tile_tri_v2[3]);
  local max1 = max;
  local w = max1[1] - min1[1];
  local h = max1[2] - min1[2];
  World.render_triangle(frustum,World.visible_tiles,min1[1],min1[2],w,h,tile_tri_v0[1] - min1[1],tile_tri_v0[2] - min1[2],tile_tri_v1[1] - min1[1],tile_tri_v1[2] - min1[2],tile_tri_v2[1] - min1[1],tile_tri_v2[2] - min1[2]);
  local tile_over = World.tile_at(systems.Render.camera.position);
  local found = false;
  local _g = 0;
  local _g1 = World.visible_tiles;
  while (_g < _g1.length) do 
    local vt = _g1[_g];
    _g = _g + 1;
    if (vt.world_tile == tile_over) then 
      found = true;
      break;
    end;
    end;
  if (not found) then 
    World.visible_tiles:push(VirtualTile.new(tile_over,tile_over.x,tile_over.y));
  end;
end
World.filter = function(only_visible,fn) 
  local relevant = _hx_tab_array({ }, 0);
  local _tmp0 = only_visible;
  local _tmp1 = _tmp0 == false;
  if (not _tmp1) then 
    _G.error(utils.AssertionFailure.new("only_visible == false",_hx_tab_array({[0]=_hx_o({__fields__={expr=true,value=true},expr="only_visible",value=_tmp0}), _hx_o({__fields__={expr=true,value=true},expr="only_visible == false",value=_tmp1}) }, 2),"only visible is nyi"),0);
  end;
  local set = World.entities;
  local _g = 0;
  while (_g < set.length) do 
    local entity = set[_g];
    _g = _g + 1;
    if (fn(entity)) then 
      relevant:push(entity);
    end;
    end;
  do return relevant end;
end
World.update_systems = function(systems,dt) 
  local log = function(err) 
    if (World.borked:indexOf(World.current_bork) >= 0) then 
      do return end;
    end;
    World.borked:push(World.current_bork);
    Log.write(Level.System,"Error: " .. err);
  end;
  local _g = 0;
  while (_g < systems.length) do 
    local system = systems[_g];
    _g = _g + 1;
    local relevant = _hx_tab_array({ }, 0);
    Profiler.push_block(system.PROFILE_NAME,system.PROFILE_COLOR,_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="World.hx",lineNumber=516,className="World",methodName="update_systems"}));
    local _g1 = 0;
    local _g2 = World.entities;
    while (_g1 < _g2.length) do 
      local entity = _g2[_g1];
      _g1 = _g1 + 1;
      if (system:filter(entity)) then 
        relevant:push(entity);
        if (_hx_bind(system,system.process) ~= nil) then 
          World.current_bork = _hx_bind(system,system.process);
          local _hx_expected_result = {}
          local _hx_status, _hx_result = pcall(function() 
          
              system:process(entity,dt);
             return _hx_expected_result end)
           if not _hx_status then 
            local _hx_1 = _hx_result
            if( lua.Boot.__instanceof(_hx_1,String) ) then 
              local err1 = _hx_1
              log(err1);
            else _G.error(_hx_1)
            end
           elseif _hx_result ~= _hx_expected_result then return _hx_result end;
        end;
      end;
      end;
    if (_hx_bind(system,system.update) ~= nil) then 
      World.current_bork = _hx_bind(system,system.update);
      local _hx_expected_result = {}
      local _hx_status, _hx_result = pcall(function() 
      
          system:update(relevant,dt);
         return _hx_expected_result end)
       if not _hx_status then 
        local _hx_2 = _hx_result
        if( lua.Boot.__instanceof(_hx_2,String) ) then 
          local err2 = _hx_2
          log(err2);
        else _G.error(_hx_2)
        end
       elseif _hx_result ~= _hx_expected_result then return _hx_result end;
    end;
    Profiler.pop_block(_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="World.hx",lineNumber=544,className="World",methodName="update_systems"}));
    end;
end
World.update = function(dt) 
  Profiler.push_block("world update",_Profiler.SegmentColor_Impl_.World,_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="World.hx",lineNumber=549,className="World",methodName="update"}));
  local tmp = World;
  tmp.time = tmp.time + dt;
  local variable = World.systems:filter(function(s) 
    do return not s.fixed_tick end;
  end);
  local fixed = World.systems:filter(function(s1) 
    do return s1.fixed_tick end;
  end);
  while (World.time >= World.tickrate) do 
    local tmp1 = World;
    tmp1.time = tmp1.time - World.tickrate;
    local tmp2 = (World.time / World.tickrate) > 1;
    World.update_systems(fixed,World.tickrate);
    end;
  World.update_systems(variable,dt);
  Profiler.pop_block(_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="World.hx",lineNumber=567,className="World",methodName="update"}));
end

Zone.new = {}
Zone.__name__ = {"Zone"}
Zone.load_tile = function(entities,data) 
  local start = entities.length;
  local max_id = 0;
  local b = data.entities.length;
  max_id = Std.int((function() 
    local _hx_1
    if (Math.isNaN(max_id) or Math.isNaN(b)) then 
    _hx_1 = (0/0); else 
    _hx_1 = _G.math.max(max_id,b); end
    return _hx_1
  end )());
  local _g1 = 0;
  local _g = max_id;
  while (_g1 < _g) do 
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    entities:push(_hx_e());
    end;
  local rails = _hx_tab_array({ }, 0);
  local _g2 = 0;
  local _g11 = data.entities;
  while (_g2 < _g11.length) do 
    local entity = _g11[_g2];
    _g2 = _g2 + 1;
    local target = entities[entity.id + start];
    local is_static = true;
    local tx = components.Transform.new(math._Vec3.Vec3_Impl_._new(entity.pos[0],entity.pos[1],entity.pos[2]),math._Vec3.Vec3_Impl_._new(),math._Quat.Quat_Impl_._new(entity.rot[0],entity.rot[1],entity.rot[2],entity.rot[3]),math._Vec3.Vec3_Impl_._new(entity.scale[0],entity.scale[1],entity.scale[2]),is_static);
    math._Quat.Quat_Impl_.normalize(tx.orientation);
    tx.tile_x = data.x;
    tx.tile_y = data.y;
    tx:update();
    target.transform = tx;
    if (entity.rails.length > 0) then 
      target.rails = _hx_tab_array({ }, 0);
      local _g21 = 0;
      local _g3 = entity.rails;
      while (_g21 < _g3.length) do 
        local rail = _g3[_g21];
        _g21 = _g21 + 1;
        local start1 = math._Mat4.Mat4_Impl_.mul_vec3(tx.mtx,math._Vec3.Vec3_Impl_._new(rail[0],rail[1],rail[2]));
        local _end = math._Mat4.Mat4_Impl_.mul_vec3(tx.mtx,math._Vec3.Vec3_Impl_._new(rail[3],rail[4],rail[5]));
        local r = components.Rail.new(start1,_end,tx.mtx);
        target.rails:push(r);
        rails:push(r);
        end;
    end;
    local threshold = 0.0125;
    local _g22 = 0;
    while (_g22 < rails.length) do 
      local k = rails[_g22];
      _g22 = _g22 + 1;
      local _g31 = 0;
      local _hx_break_2 = false;
      while (_g31 < rails.length) do 
        repeat 
        local i1 = rails[_g31];
        _g31 = _g31 + 1;
        if (k == i1) then 
          break;
        end;
        local tmp;
        local a = k.capsule.a;
        local b1 = i1.capsule.a;
        local dx = a[1] - b1[1];
        local dy = a[2] - b1[2];
        local dz = a[3] - b1[3];
        if (not (_G.math.sqrt(((dx * dx) + (dy * dy)) + (dz * dz)) < threshold)) then 
          local a1 = k.capsule.a;
          local b2 = i1.capsule.b;
          local dx1 = a1[1] - b2[1];
          local dy1 = a1[2] - b2[2];
          local dz1 = a1[3] - b2[3];
          tmp = _G.math.sqrt(((dx1 * dx1) + (dy1 * dy1)) + (dz1 * dz1)) < threshold;
        else
          tmp = true;
        end;
        if (tmp) then 
          k.prev = i1;
        end;
        local tmp1;
        local a2 = k.capsule.b;
        local b3 = i1.capsule.a;
        local dx2 = a2[1] - b3[1];
        local dy2 = a2[2] - b3[2];
        local dz2 = a2[3] - b3[3];
        if (not (_G.math.sqrt(((dx2 * dx2) + (dy2 * dy2)) + (dz2 * dz2)) < threshold)) then 
          local a3 = k.capsule.b;
          local b4 = i1.capsule.b;
          local dx3 = a3[1] - b4[1];
          local dy3 = a3[2] - b4[2];
          local dz3 = a3[3] - b4[3];
          tmp1 = _G.math.sqrt(((dx3 * dx3) + (dy3 * dy3)) + (dz3 * dz3)) < threshold;
        else
          tmp1 = true;
        end;
        if (tmp1) then 
          k.next = i1;
        end;
        
      until true
      if _hx_break_3 then _hx_break_3 = false; break; end
      end;
      end;
    local collidable = Type.createEnumIndex(components.CollisionType,entity.collision,nil);
    if (entity.model.length ~= 0) then 
      target.drawable = components.Drawable.new(entity.model,collidable,components.ShaderType.Basic);
    end;
    if (entity.trigger ~= nil) then 
      target.trigger = components.Trigger.new(entity.trigger.cb,Type.createEnumIndex(components.TriggerType,entity.trigger.type,nil),entity.trigger.range,entity.trigger.max_angle,entity.trigger.enabled);
    end;
    World.entities:push(target);
    World.refresh_entity(nil,World.get_tile(data.x,data.y),target,true);
    end;
end
Zone.load_map = function(data,filename) 
  local entities = _hx_tab_array({ }, 0);
  local _g = 0;
  local _g1 = data.tiles;
  while (_g < _g1.length) do 
    local tile = _g1[_g];
    _g = _g + 1;
    local real = World.get_tile(tile.x,tile.y);
    real.filename = filename;
    Zone.load_tile(entities,tile);
    end;
end
Zone.load_world = function(data) 
  local _g = 0;
  local _g1 = data.maps;
  while (_g < _g1.length) do 
    local map = _g1[_g];
    _g = _g + 1;
    local _hx_1_saved_contents, _hx_1_saved_size = love.filesystem.read(map);
    local data1 = haxe.Json.parse(_hx_1_saved_contents);
    Zone.load_map(data1,map);
    end;
end
Zone.load = function(path) 
  local tx = World.tiles_x;
  local ty = World.tiles_y;
  local n = tx * ty;
  local tiles = _hx_tab_array({ }, 0);
  local tex = love.image.newImageData("assets/textures/heightmap_2x1.png");
  local _g1 = 0;
  local _g = n;
  while (_g1 < _g) do 
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    local x = _G.math.fmod(i, World.tiles_x);
    local y = Std.int(i / World.tiles_x);
    local tx1 = components.Transform.new(math._Vec3.Vec3_Impl_._new(0,0,-30),math._Vec3.Vec3_Impl_._new(),math._Quat.Quat_Impl_._new(),math._Vec3.Vec3_Impl_._new(1,1,1),true);
    tx1.tile_x = x;
    tx1.tile_y = y;
    tx1:update();
    local d = components.Drawable.new(Zone.HEIGHTMAP_TILE,components.CollisionType.None);
    d.mesh = editor.HeightmapTerrain.generate_tile(tex,math._Mat4.Mat4_Impl_.translate(tx1.position),tx1.tile_x,tx1.tile_y);
    d.shader = components.ShaderType.Terrain;
    local e = _hx_o({__fields__={transform=true,drawable=true},transform=tx1,drawable=d});
    tiles:push(e);
    World.refresh_entity(nil,World.get_tile(x,y),e,true);
    end;
  World.new_entities(path,tiles);
  local _hx_1_saved_contents, _hx_1_saved_size = love.filesystem.read(path);
  if (_hx_1_saved_contents ~= nil) then 
    local data = haxe.Json.parse(_hx_1_saved_contents);
    Zone.load_world(data);
  end;
end
Zone.save_zone = function(tiles,filename) 
  local data = _hx_o({__fields__={version=true,tiles=true},version=Zone.map_version,tiles=_hx_tab_array({ }, 0)});
  local _g = 0;
  while (_g < tiles.length) do 
    local tile = tiles[_g];
    _g = _g + 1;
    local tdata = _hx_o({__fields__={x=true,y=true,entities=true},x=tile.x,y=tile.y,entities=_hx_tab_array({ }, 0)});
    local id = 0;
    local _g1 = 0;
    local _g2 = tile.entities;
    local _hx_break_1 = false;
    while (_g1 < _g2.length) do 
      repeat 
      local e = _g2[_g1];
      _g1 = _g1 + 1;
      if (e.player ~= nil) then 
        break;
      end;
      if ((e.drawable ~= nil) and (e.drawable.filename == Zone.HEIGHTMAP_TILE)) then 
        break;
      end;
      if (e.transform ~= nil) then 
        local _pos = e.transform.position;
        local _rot = e.transform.orientation;
        local _sca = e.transform.scale;
        local mesh = "";
        local coll = components.CollisionType.None;
        local rail_data = _hx_tab_array({ }, 0);
        local trigger = nil;
        if (e.drawable ~= nil) then 
          mesh = e.drawable.filename;
          coll = e.drawable.collision;
        end;
        if (e.rails ~= nil) then 
          local inv = math._Mat4.Mat4_Impl_.copy(e.transform.mtx);
          math._Mat4.Mat4_Impl_.invert(inv);
          local _g3 = 0;
          local _g4 = e.rails;
          while (_g3 < _g4.length) do 
            local rail = _g4[_g3];
            _g3 = _g3 + 1;
            local start = math._Mat4.Mat4_Impl_.mul_vec3(inv,rail.capsule.a);
            local _end = math._Mat4.Mat4_Impl_.mul_vec3(inv,rail.capsule.b);
            rail_data:push(_hx_tab_array({[0]=start[1], start[2], start[3], _end[1], _end[2], _end[3] }, 6));
            end;
        end;
        if (e.trigger ~= nil) then 
          trigger = _hx_o({__fields__={cb=true,type=true,range=true,max_angle=true,enabled=true},cb=e.trigger.cb,type=e.trigger.type[1],range=e.trigger.range,max_angle=e.trigger.max_angle,enabled=e.trigger.enabled});
        end;
        tdata.entities:push(_hx_o({__fields__={id=true,model=true,collision=true,pos=true,rot=true,scale=true,rails=true,trigger=true,prefab=true},id=id,model=mesh,collision=coll[1],pos=_hx_tab_array({[0]=_pos[1], _pos[2], _pos[3] }, 3),rot=_hx_tab_array({[0]=_rot[0], _rot[1], _rot[2], _rot[3] }, 4),scale=_hx_tab_array({[0]=_sca[1], _sca[2], _sca[3] }, 3),rails=rail_data,trigger=trigger,prefab=e.prefab_path}));
      end;
      id = id + 1;
      
    until true
    if _hx_break_2 then _hx_break_2 = false; break; end
    end;
    data.tiles:push(tdata);
    end;
  local out = haxe.Json.stringify(data);
  love.filesystem.createDirectory("assets/maps/zones");
  love.filesystem.write(filename,out);
end
Zone.get_zones = function() 
  local zones = haxe.ds.StringMap.new();
  local tiles = World.tiles;
  local _g = 0;
  while (_g < tiles.length) do 
    local tile = tiles[_g];
    _g = _g + 1;
    local key = tile.filename;
    if (not (zones.k[key] or false)) then 
      local k = tile.filename;
      local v = _hx_tab_array({ }, 0);
      zones.v[k] = v;
      zones.k[k] = true;
    end;
    local key1 = tile.filename;
    local zone = zones.v[key1];
    if (zone:indexOf(tile) < 0) then 
      zone:push(tile);
    end;
    end;
  do return zones end;
end
Zone.save = function(filename) 
  local zones = Zone.get_zones();
  love.filesystem.createDirectory("assets/maps");
  local zone_paths = _hx_tab_array({ }, 0);
  local zone = zones:iterator();
  while (zone:hasNext()) do 
    local zone1 = zone:next();
    zone_paths:push(zone1[0].filename);
    Zone.save_zone(zone1,zone1[0].filename);
    end;
  local data = _hx_o({__fields__={version=true,maps=true},version=Zone.map_version,maps=zone_paths});
  local out = haxe.Json.stringify(data);
  love.filesystem.write(filename,out);
end

actor.Actor.new = function() 
  local self = _hx_new(actor.Actor.prototype)
  actor.Actor.super(self)
  return self
end
actor.Actor.super = function(self) 
  local this1;
  this1 = ({0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0});
  this1[0] = 1;
  self.matrix = this1;
  self.children = _hx_tab_array({ }, 0);
  self.commands = haxe.ds.StringMap.new();
  self.actual = actor.TweenState.new(actor.TweenType.Constant,0);
  self.tween_stack = _hx_tab_array({ }, 0);
end
actor.Actor.__name__ = {"actor","Actor"}
actor.Actor.prototype = _hx_a(
  'tween_for', function(self,type) 
    local quad = function(t) 
      do return t * t end;
    end;
    local cubic = function(t1) 
      do return (t1 * t1) * t1 end;
    end;
    local type1 = type[1];
    if (type1) == 0 then 
      do return function(t2) 
        do return 0 end;
      end end;
    elseif (type1) == 1 then 
      do return function(t3) 
        do return t3 end;
      end end;
    elseif (type1) == 2 then 
      do return quad end;
    elseif (type1) == 3 then 
      do return cubic end;
    elseif (type1) == 4 then 
      local f = quad;
      do return function(s) 
        do return 1 - f(1 - s) end;
      end end;
    elseif (type1) == 5 then 
      local f1 = cubic;
      do return function(s1) 
        do return 1 - f1(1 - s1) end;
      end end;
    elseif (type1) == 6 then 
      local f11 = quad;
      local f2 = quad;
      local f21 = function(s2) 
        do return 1 - f2(1 - s2) end;
      end;
      do return function(s3) 
        do return (function() 
          local _hx_1
          if (s3 < .5) then 
          _hx_1 = f11(2 * s3); else 
          _hx_1 = 1 + f21((2 * s3) - 1); end
          return _hx_1
        end )() * .5 end;
      end end;
    elseif (type1) == 7 then 
      local f12 = cubic;
      local f3 = cubic;
      local f22 = function(s4) 
        do return 1 - f3(1 - s4) end;
      end;
      do return function(s5) 
        do return (function() 
          local _hx_2
          if (s5 < .5) then 
          _hx_2 = f12(2 * s5); else 
          _hx_2 = 1 + f22((2 * s5) - 1); end
          return _hx_2
        end )() * .5 end;
      end end; end;
  end,
  'mix', function(self,a,b,t) 
    local tween = self:tween_for(b.tween_type);
    local a1 = a.position;
    local b1 = b.position;
    local tmp = tween(t);
    self.actual.position = math._Vec3.Vec3_Impl_.lerp(a1,b1,tmp);
  end,
  'update', function(self,dt,parent) 
    local a = self.tween_stack[0];
    local b = self.tween_stack[1];
    if (b == nil) then 
      self.actual = a;
      do return end;
    end;
    local b1 = b;
    b1.tween_time = b1.tween_time + dt;
    local progress = b.tween_time / b.tween_duration;
    if ((progress >= 1) and (self.tween_stack.length > 1)) then 
      self.tween_stack:splice(0,1);
      if (b.cmd_queue.length > 0) then 
        local _g = 0;
        local _g1 = b.cmd_queue;
        while (_g < _g1.length) do 
          local cmd = _g1[_g];
          _g = _g + 1;
          local this1 = self.commands;
          if ((this1.k[cmd] or false)) then 
            local this2 = self.commands;
            this2.v[cmd]();
          end;
          end;
        b.cmd_queue = _hx_tab_array({ }, 0);
      end;
      local tmp = self.tween_stack[0];
      tmp.tween_time = tmp.tween_time + (b.tween_time - b.tween_duration);
    end;
    self:mix(a,b,math.Utils.clamp(progress,0,1));
    self.matrix = math._Mat4.Mat4_Impl_.from_srt(self.actual.position,math._Vec3.Vec3_Impl_._new(0,0,0),math._Vec3.Vec3_Impl_._new(1,1,1));
    if (parent ~= nil) then 
      self.matrix = math._Mat4.Mat4_Impl_.mul(parent.matrix,self.matrix);
    end;
    local _g2 = 0;
    local _g11 = self.children;
    while (_g2 < _g11.length) do 
      local child = _g11[_g2];
      _g2 = _g2 + 1;
      child:update(dt,self);
      end;
  end
  ,'__class__',  actor.Actor
)

actor.TweenState.new = function(type,duration) 
  local self = _hx_new(actor.TweenState.prototype)
  actor.TweenState.super(self,type,duration)
  return self
end
actor.TweenState.super = function(self,type,duration) 
  self.cmd_queue = _hx_tab_array({ }, 0);
  self.tween_time = 0;
  self.tween_type = type;
  self.tween_duration = duration;
  self.position = math._Vec3.Vec3_Impl_._new(0,0,0);
end
actor.TweenState.__name__ = {"actor","TweenState"}
actor.TweenState.prototype = _hx_a(
  
  '__class__',  actor.TweenState
)
_hxClasses["actor.TweenType"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Constant","Linear","InQuad","InCubic","OutQuad","OutCubic","SmoothQuad","SmoothCubic"},8)}
actor.TweenType = _hxClasses["actor.TweenType"];
actor.TweenType.Constant = _hx_tab_array({[0]="Constant",0,__enum__ = actor.TweenType},2)

actor.TweenType.Linear = _hx_tab_array({[0]="Linear",1,__enum__ = actor.TweenType},2)

actor.TweenType.InQuad = _hx_tab_array({[0]="InQuad",2,__enum__ = actor.TweenType},2)

actor.TweenType.InCubic = _hx_tab_array({[0]="InCubic",3,__enum__ = actor.TweenType},2)

actor.TweenType.OutQuad = _hx_tab_array({[0]="OutQuad",4,__enum__ = actor.TweenType},2)

actor.TweenType.OutCubic = _hx_tab_array({[0]="OutCubic",5,__enum__ = actor.TweenType},2)

actor.TweenType.SmoothQuad = _hx_tab_array({[0]="SmoothQuad",6,__enum__ = actor.TweenType},2)

actor.TweenType.SmoothCubic = _hx_tab_array({[0]="SmoothCubic",7,__enum__ = actor.TweenType},2)

actor.TweenType.__empty_constructs__ = _hx_tab_array({[0] = actor.TweenType.Constant,actor.TweenType.Linear,actor.TweenType.InQuad,actor.TweenType.InCubic,actor.TweenType.OutQuad,actor.TweenType.OutCubic,actor.TweenType.SmoothQuad,actor.TweenType.SmoothCubic}, 8)

backend._Gc.Gc_Impl_.new = {}
backend._Gc.Gc_Impl_.__name__ = {"backend","_Gc","Gc_Impl_"}
backend._Gc.Gc_Impl_.run = function(major) 
  backend.love.Gc.run(major);
end

backend.love.GameLoop.new = {}
backend.love.GameLoop.__name__ = {"backend","love","GameLoop"}
backend.love.GameLoop.load = function(args) 
  Main.load(args);
end
backend.love.GameLoop.update = function(dt) 
  ui.Anchor.update(backend.love.GameLoop.window);
  Main.dt = dt;
end
backend.love.GameLoop.draw = function() 
  Main.draw(backend.love.GameLoop.window);
end
backend.love.GameLoop.mousepressed = function(x,y,button,istouch) 
  Main.mousepressed(x,y,Std.int(button));
end
backend.love.GameLoop.mousereleased = function(x,y,button,istouch) 
  Main.mousereleased(x,y,Std.int(button));
end
backend.love.GameLoop.mousemoved = function(x,y,dx,dy,istouch) 
  Main.mousemoved(x,y,dx,dy);
end
backend.love.GameLoop.wheelmoved = function(x,y) 
  Main.wheelmoved(x,y);
end
backend.love.GameLoop.textinput = function(str) 
  Main.textinput(str);
end
backend.love.GameLoop.keypressed = function(key,scan,isrepeat) 
  if ((key == "escape") and love.keyboard.isDown("lshift","rshift")) then 
    love.event.quit();
  end;
  Main.keypressed(key,scan,isrepeat);
end
backend.love.GameLoop.keyreleased = function(key) 
  Main.keyreleased(key);
end
backend.love.GameLoop.real_run = function() 
  local this1 = backend.love.Window.new();
  backend.love.GameLoop.window = this1;
  backend.love.GameLoop.window:open(1920,1080);
  love.math.setRandomSeed(_G.os.time());
  local t = arg;
  local length = nil;
  if (length == nil) then 
    length = _hx_table.maxn(t) + 1;
  end;
  local args = _hx_tab_array(t,length);
  args:splice(0,1);
  backend.love.GameLoop.load(args);
  love.mousepressed = backend.love.GameLoop.mousepressed;
  love.mousereleased = backend.love.GameLoop.mousereleased;
  love.mousemoved = backend.love.GameLoop.mousemoved;
  love.wheelmoved = backend.love.GameLoop.wheelmoved;
  love.textinput = backend.love.GameLoop.textinput;
  love.keypressed = backend.love.GameLoop.keypressed;
  love.keyreleased = backend.love.GameLoop.keyreleased;
  love.timer.step();
  local dt = 0;
  while (true) do 
    backend.love.GameLoop.window:poll_events();
    
				for name, a,b,c,d,e,f in love.event.poll() do
					if name == "quit" then
						if not Main.quit or not Main.quit() then
							return a
						end
					end
					love.handlers[name](a,b,c,d,e,f)
				end
			;
    love.timer.step();
    dt = love.timer.getDelta();
    if (Math.isNaN(dt) or Math.isNaN(0.033333333333333333)) then 
      dt = (0/0);
    else
      dt = _G.math.min(dt,0.033333333333333333);
    end;
    if (Math.isNaN(dt) or Math.isNaN(0.0005)) then 
      dt = (0/0);
    else
      dt = _G.math.max(dt,0.0005);
    end;
    if (love.keyboard.isDown("tab")) then 
      dt = dt * 4;
    end;
    backend.love.GameLoop.update(dt);
    if (backend.love.GameLoop.window:is_open()) then 
      local _hx_1_bg_r, _hx_1_bg_g, _hx_1_bg_b, _hx_1_bg_a = love.graphics.getBackgroundColor();
      love.graphics.clear(_hx_1_bg_r,_hx_1_bg_g,_hx_1_bg_b,_hx_1_bg_a);
      love.graphics.origin();
      backend.love.GameLoop.draw();
      backend.love.GameLoop.window:present();
    end;
    love.timer.sleep(0.001);
    end;
end

backend.love.Gc.new = {}
backend.love.Gc.__name__ = {"backend","love","Gc"}
backend.love.Gc.run = function(major) 
  if (major) then 
    _G.collectgarbage("collect");
  else
    _G.collectgarbage("step",20);
  end;
end

backend.love.Window.new = function() 
  local self = _hx_new(backend.love.Window.prototype)
  backend.love.Window.super(self)
  return self
end
backend.love.Window.super = function(self) 
end
backend.love.Window.__name__ = {"backend","love","Window"}
backend.love.Window.prototype = _hx_a(
  'open', function(self,w,h) 
    local flags = ({vsync = true, msaa = 0, resizable = true});
    local ps = love.window.getPixelScale();
    love.window.setMode(w * ps,h * ps,flags);
    love.window.setTitle("off the rails (1.0.0 LD40)");
  end,
  'get_framebuffer_size', function(self) 
    do return _hx_o({__fields__={width=true,height=true},width=Std.int(love.graphics.getWidth()),height=Std.int(love.graphics.getHeight())}) end
  end,
  'is_open', function(self) 
    do return love.window.isOpen() end
  end,
  'present', function(self) 
    love.graphics.present();
  end,
  'poll_events', function(self) 
    love.event.pump();
    do return end
  end
  ,'__class__',  backend.love.Window
)

collision.Collision.new = {}
collision.Collision.__name__ = {"collision","Collision"}
collision.Collision.triangle_intersects_point = function(point,v0,v1,v2) 
  local u = math._Vec3.Vec3_Impl_.sub(v1,v0);
  local v = math._Vec3.Vec3_Impl_.sub(v2,v0);
  local w = math._Vec3.Vec3_Impl_.sub(point,v0);
  local vw = math._Vec3.Vec3_Impl_.cross(v,w);
  local vu = math._Vec3.Vec3_Impl_.cross(v,u);
  if ((((vw[1] * vu[1]) + (vw[2] * vu[2])) + (vw[3] * vu[3])) < 0.0) then 
    do return false end;
  end;
  local uw = math._Vec3.Vec3_Impl_.cross(u,w);
  local uv = math._Vec3.Vec3_Impl_.cross(u,v);
  if ((((uw[1] * uv[1]) + (uw[2] * uv[2])) + (uw[3] * uv[3])) < 0.0) then 
    do return false end;
  end;
  local d = math._Vec3.Vec3_Impl_.length(uv);
  local r = math._Vec3.Vec3_Impl_.length(vw) / d;
  local t = math._Vec3.Vec3_Impl_.length(uw) / d;
  do return (r + t) <= 1 end;
end
collision.Collision.get_lowest_root = function(a,b,c,max) 
  local determinant = (b * b) - ((4.0 * a) * c);
  if (determinant < 0.0) then 
    do return nil end;
  end;
  local sqrtD = _G.math.sqrt(determinant);
  local r1 = (-b - sqrtD) / (2 * a);
  local r2 = (-b + sqrtD) / (2 * a);
  if (r1 > r2) then 
    local temp = r2;
    r2 = r1;
    r1 = temp;
  end;
  if ((r1 > 0) and (r1 < max)) then 
    do return r1 end;
  end;
  if ((r2 > 0) and (r2 < max)) then 
    do return r2 end;
  end;
  do return nil end;
end
collision.Collision.check_triangle = function(packet,p1,p2,p3) 
  local plane = math.Plane.from_triangle(p1,p2,p3);
  if (not plane:is_front_facing(packet.e_norm_velocity)) then 
    do return packet end;
  end;
  local t0 = 0.0;
  local t1 = 0.0;
  local embedded_in_plane = false;
  local signed_dist_to_plane = plane:signed_distance(packet.e_base_point);
  local a = plane.normal;
  local b = packet.e_velocity;
  local normal_dot_vel = ((a[1] * b[1]) + (a[2] * b[2])) + (a[3] * b[3]);
  if (normal_dot_vel == 0.0) then 
    if (_G.math.abs(signed_dist_to_plane) >= 1.0) then 
      do return packet end;
    else
      embedded_in_plane = true;
      t0 = 0.0;
      t1 = 1.0;
    end;
  else
    local nvi = 1.0 / normal_dot_vel;
    t0 = (-1.0 - signed_dist_to_plane) * nvi;
    t1 = (1.0 - signed_dist_to_plane) * nvi;
    if (t0 > t1) then 
      local temp = t1;
      t1 = t0;
      t0 = temp;
    end;
    if ((t0 > 1.0) or (t1 < 0.0)) then 
      do return packet end;
    end;
    t0 = math.Utils.clamp(t0,0.0,1.0);
    t1 = math.Utils.clamp(t1,0.0,1.0);
  end;
  local collision_point = math._Vec3.Vec3_Impl_._new(0.0,0.0,0.0);
  local found_collision = false;
  local t = 1.0;
  if (not embedded_in_plane) then 
    local plane_intersect = math._Vec3.Vec3_Impl_.sub(packet.e_base_point,plane.normal);
    local temp1 = math._Vec3.Vec3_Impl_.scale(packet.e_velocity,t0);
    plane_intersect = math._Vec3.Vec3_Impl_.add(plane_intersect,temp1);
    if (collision.Collision.triangle_intersects_point(plane_intersect,p1,p2,p3)) then 
      found_collision = true;
      t = t0;
      collision_point = plane_intersect;
    end;
  end;
  if (not found_collision) then 
    local _self = packet.e_velocity;
    local velocity = math._Vec3.Vec3_Impl_._new(_self[1],_self[2],_self[3]);
    local self1 = packet.e_base_point;
    local base = math._Vec3.Vec3_Impl_._new(self1[1],self1[2],self1[3]);
    local self2 = velocity;
    local velocity_sq_length = ((self2[1] * self2[1]) + (self2[2] * self2[2])) + (self2[3] * self2[3]);
    local a1 = velocity_sq_length;
    local b1 = 0.0;
    local c = 0.0;
    local temp2 = math._Vec3.Vec3_Impl_.sub(base,p1);
    b1 = 2.0 * (((velocity[1] * temp2[1]) + (velocity[2] * temp2[2])) + (velocity[3] * temp2[3]));
    temp2 = math._Vec3.Vec3_Impl_.sub(p1,base);
    local self3 = temp2;
    c = (((self3[1] * self3[1]) + (self3[2] * self3[2])) + (self3[3] * self3[3])) - 1.0;
    local new_t = collision.Collision.get_lowest_root(a1,b1,c,t);
    if (new_t ~= nil) then 
      t = new_t;
      found_collision = true;
      collision_point = p1;
    end;
    if (not found_collision) then 
      temp2 = math._Vec3.Vec3_Impl_.sub(base,p2);
      b1 = 2.0 * (((velocity[1] * temp2[1]) + (velocity[2] * temp2[2])) + (velocity[3] * temp2[3]));
      temp2 = math._Vec3.Vec3_Impl_.sub(p2,base);
      local self4 = temp2;
      c = (((self4[1] * self4[1]) + (self4[2] * self4[2])) + (self4[3] * self4[3])) - 1.0;
      new_t = collision.Collision.get_lowest_root(a1,b1,c,t);
      if (new_t ~= nil) then 
        t = new_t;
        found_collision = true;
        collision_point = p2;
      end;
    end;
    if (not found_collision) then 
      temp2 = math._Vec3.Vec3_Impl_.sub(base,p3);
      b1 = 2.0 * (((velocity[1] * temp2[1]) + (velocity[2] * temp2[2])) + (velocity[3] * temp2[3]));
      temp2 = math._Vec3.Vec3_Impl_.sub(p3,base);
      local self5 = temp2;
      c = (((self5[1] * self5[1]) + (self5[2] * self5[2])) + (self5[3] * self5[3])) - 1.0;
      new_t = collision.Collision.get_lowest_root(a1,b1,c,t);
      if (new_t ~= nil) then 
        t = new_t;
        found_collision = true;
        collision_point = p3;
      end;
    end;
    local edge = math._Vec3.Vec3_Impl_.sub(p2,p1);
    local base_to_vertex = math._Vec3.Vec3_Impl_.sub(p1,base);
    local self6 = edge;
    local edge_sq_length = ((self6[1] * self6[1]) + (self6[2] * self6[2])) + (self6[3] * self6[3]);
    local edge_dot_velocity = ((edge[1] * velocity[1]) + (edge[2] * velocity[2])) + (edge[3] * velocity[3]);
    local edge_dot_base_to_vertex = ((edge[1] * base_to_vertex[1]) + (edge[2] * base_to_vertex[2])) + (edge[3] * base_to_vertex[3]);
    a1 = (edge_sq_length * -velocity_sq_length) + (edge_dot_velocity * edge_dot_velocity);
    b1 = (edge_sq_length * (2.0 * (((velocity[1] * base_to_vertex[1]) + (velocity[2] * base_to_vertex[2])) + (velocity[3] * base_to_vertex[3])))) - ((2.0 * edge_dot_velocity) * edge_dot_base_to_vertex);
    local self7 = base_to_vertex;
    c = (edge_sq_length * (1.0 - (((self7[1] * self7[1]) + (self7[2] * self7[2])) + (self7[3] * self7[3])))) + (edge_dot_base_to_vertex * edge_dot_base_to_vertex);
    new_t = collision.Collision.get_lowest_root(a1,b1,c,t);
    if (new_t ~= nil) then 
      local f = ((edge_dot_velocity * new_t) - edge_dot_base_to_vertex) / edge_sq_length;
      if ((f >= 0.0) and (f <= 1.0)) then 
        t = new_t;
        found_collision = true;
        collision_point = math._Vec3.Vec3_Impl_.add(p1,math._Vec3.Vec3_Impl_.scale(edge,f));
      end;
    end;
    edge = math._Vec3.Vec3_Impl_.sub(p3,p2);
    base_to_vertex = math._Vec3.Vec3_Impl_.sub(p2,base);
    local self8 = edge;
    edge_sq_length = ((self8[1] * self8[1]) + (self8[2] * self8[2])) + (self8[3] * self8[3]);
    edge_dot_velocity = ((edge[1] * velocity[1]) + (edge[2] * velocity[2])) + (edge[3] * velocity[3]);
    edge_dot_base_to_vertex = ((edge[1] * base_to_vertex[1]) + (edge[2] * base_to_vertex[2])) + (edge[3] * base_to_vertex[3]);
    a1 = (edge_sq_length * -velocity_sq_length) + (edge_dot_velocity * edge_dot_velocity);
    b1 = (edge_sq_length * (2.0 * (((velocity[1] * base_to_vertex[1]) + (velocity[2] * base_to_vertex[2])) + (velocity[3] * base_to_vertex[3])))) - ((2.0 * edge_dot_velocity) * edge_dot_base_to_vertex);
    local self9 = base_to_vertex;
    c = (edge_sq_length * (1.0 - (((self9[1] * self9[1]) + (self9[2] * self9[2])) + (self9[3] * self9[3])))) + (edge_dot_base_to_vertex * edge_dot_base_to_vertex);
    new_t = collision.Collision.get_lowest_root(a1,b1,c,t);
    if (new_t ~= nil) then 
      local f1 = ((edge_dot_velocity * new_t) - edge_dot_base_to_vertex) / edge_sq_length;
      if ((f1 >= 0.0) and (f1 <= 1.0)) then 
        t = new_t;
        found_collision = true;
        collision_point = math._Vec3.Vec3_Impl_.add(p2,math._Vec3.Vec3_Impl_.scale(edge,f1));
      end;
    end;
    edge = math._Vec3.Vec3_Impl_.sub(p1,p3);
    base_to_vertex = math._Vec3.Vec3_Impl_.sub(p3,base);
    local self10 = edge;
    edge_sq_length = ((self10[1] * self10[1]) + (self10[2] * self10[2])) + (self10[3] * self10[3]);
    edge_dot_velocity = ((edge[1] * velocity[1]) + (edge[2] * velocity[2])) + (edge[3] * velocity[3]);
    edge_dot_base_to_vertex = ((edge[1] * base_to_vertex[1]) + (edge[2] * base_to_vertex[2])) + (edge[3] * base_to_vertex[3]);
    a1 = (edge_sq_length * -velocity_sq_length) + (edge_dot_velocity * edge_dot_velocity);
    b1 = (edge_sq_length * (2.0 * (((velocity[1] * base_to_vertex[1]) + (velocity[2] * base_to_vertex[2])) + (velocity[3] * base_to_vertex[3])))) - ((2.0 * edge_dot_velocity) * edge_dot_base_to_vertex);
    local self11 = base_to_vertex;
    c = (edge_sq_length * (1.0 - (((self11[1] * self11[1]) + (self11[2] * self11[2])) + (self11[3] * self11[3])))) + (edge_dot_base_to_vertex * edge_dot_base_to_vertex);
    new_t = collision.Collision.get_lowest_root(a1,b1,c,t);
    if (new_t ~= nil) then 
      local f2 = ((edge_dot_velocity * new_t) - edge_dot_base_to_vertex) / edge_sq_length;
      if ((f2 >= 0.0) and (f2 <= 1.0)) then 
        t = new_t;
        found_collision = true;
        collision_point = math._Vec3.Vec3_Impl_.add(p3,math._Vec3.Vec3_Impl_.scale(edge,f2));
      end;
    end;
  end;
  if (found_collision) then 
    local dist_to_coll = t * math._Vec3.Vec3_Impl_.length(packet.e_velocity);
    if (not packet.found_collision or (dist_to_coll < packet.nearest_distance)) then 
      packet.nearest_distance = dist_to_coll;
      packet.intersect_point = collision_point;
      packet.found_collision = true;
    end;
    local n = math._Vec3.Vec3_Impl_.sub(packet.e_base_point,collision_point);
    math._Vec3.Vec3_Impl_.normalize(n);
    local b2 = math._Vec3.Vec3_Impl_._new(0,0,1);
    local dz = ((n[1] * b2[1]) + (n[2] * b2[2])) + (n[3] * b2[3]);
    if (dz >= 0.25) then 
      packet.grounded = true;
    end;
  end;
  do return packet end;
end

collision.CollisionPacket.new = function() 
  local self = _hx_new(collision.CollisionPacket.prototype)
  collision.CollisionPacket.super(self)
  return self
end
collision.CollisionPacket.super = function(self) 
  self.r3_position = math._Vec3.Vec3_Impl_._new(0.0,0.0,0.0);
  self.r3_velocity = math._Vec3.Vec3_Impl_._new(0.0,0.0,0.0);
  self.e_radius = math._Vec3.Vec3_Impl_._new(1.0,1.0,1.0);
  self.e_position = math._Vec3.Vec3_Impl_._new(0.0,0.0,0.0);
  self.e_velocity = math._Vec3.Vec3_Impl_._new(0.0,0.0,0.0);
  self.e_norm_velocity = math._Vec3.Vec3_Impl_._new(0.0,0.0,0.0);
  self.e_base_point = math._Vec3.Vec3_Impl_._new(0.0,0.0,0.0);
  self.found_collision = false;
  self.nearest_distance = 0.0;
  self.intersect_point = math._Vec3.Vec3_Impl_._new(0.0,0.0,0.0);
  self.depth = 0;
  self.grounded = false;
end
collision.CollisionPacket.__name__ = {"collision","CollisionPacket"}
collision.CollisionPacket.from_entity = function(position,velocity,radius) 
  local packet = collision.CollisionPacket.new();
  packet.r3_position = position;
  packet.r3_velocity = velocity;
  packet.e_radius = radius;
  packet.e_position = math._Vec3.Vec3_Impl_.div(packet.r3_position,packet.e_radius);
  packet.e_velocity = math._Vec3.Vec3_Impl_.div(packet.r3_velocity,packet.e_radius);
  do return packet end;
end
collision.CollisionPacket.prototype = _hx_a(
  
  '__class__',  collision.CollisionPacket
)

collision.Response.new = {}
collision.Response.__name__ = {"collision","Response"}
collision.Response.collide_with_world = function(packet,e_position,e_velocity,slide_threshold) 
  if (packet.depth > 5) then 
    do return e_position end;
  end;
  packet.e_velocity = e_velocity;
  local _self = e_velocity;
  packet.e_norm_velocity = math._Vec3.Vec3_Impl_._new(_self[1],_self[2],_self[3]);
  math._Vec3.Vec3_Impl_.normalize(packet.e_norm_velocity);
  packet.e_base_point = e_position;
  packet.e_base_point = math._Vec3.Vec3_Impl_.add(packet.e_base_point,math._Vec3.Vec3_Impl_.scale(e_velocity,collision.Response.VERY_CLOSE_DIST));
  packet.found_collision = false;
  packet.nearest_distance = 1e20;
  local scale = _G.math.max(1.5,math._Vec3.Vec3_Impl_.length(e_velocity)) * 1.25;
  local r3_position = math._Vec3.Vec3_Impl_.mul(e_position,packet.e_radius);
  local query_radius = math._Vec3.Vec3_Impl_.scale(packet.e_radius,scale);
  local min = math._Vec3.Vec3_Impl_.sub(r3_position,query_radius);
  local max = math._Vec3.Vec3_Impl_.add(r3_position,query_radius);
  local tris = World.get_triangles(min,max);
  collision.Response.check_collision(packet,tris);
  if (not packet.found_collision) then 
    do return math._Vec3.Vec3_Impl_.add(e_position,e_velocity) end;
  end;
  local dest_point = math._Vec3.Vec3_Impl_.add(e_position,e_velocity);
  local new_base_point = e_position;
  if (packet.nearest_distance >= collision.Response.VERY_CLOSE_DIST) then 
    local self1 = e_velocity;
    local v = math._Vec3.Vec3_Impl_._new(self1[1],self1[2],self1[3]);
    math._Vec3.Vec3_Impl_.trim(v,packet.nearest_distance - collision.Response.VERY_CLOSE_DIST);
    new_base_point = math._Vec3.Vec3_Impl_.add(packet.e_base_point,v);
    math._Vec3.Vec3_Impl_.normalize(v);
    packet.intersect_point = math._Vec3.Vec3_Impl_.sub(packet.intersect_point,math._Vec3.Vec3_Impl_.scale(v,collision.Response.VERY_CLOSE_DIST));
  end;
  local self2 = packet.intersect_point;
  local slide_plane_origin = math._Vec3.Vec3_Impl_._new(self2[1],self2[2],self2[3]);
  local slide_plane_normal = math._Vec3.Vec3_Impl_.sub(new_base_point,packet.intersect_point);
  math._Vec3.Vec3_Impl_.normalize(slide_plane_normal);
  local sliding_plane = math.Plane.new(slide_plane_origin,slide_plane_normal);
  local slide_factor = sliding_plane:signed_distance(dest_point);
  local new_dest_point = math._Vec3.Vec3_Impl_.sub(dest_point,math._Vec3.Vec3_Impl_.scale(slide_plane_normal,slide_factor));
  local new_velocity = math._Vec3.Vec3_Impl_.sub(new_dest_point,packet.intersect_point);
  if (math._Vec3.Vec3_Impl_.length(new_velocity) < collision.Response.VERY_CLOSE_DIST) then 
    do return new_base_point end;
  end;
  local packet1 = packet;
  packet1.depth = packet1.depth + 1;
  do return collision.Response.collide_with_world(packet,new_base_point,new_velocity,slide_threshold) end;
end
collision.Response.check_collision = function(packet,tris) 
  local _g = 0;
  while (_g < tris.length) do 
    local tri = tris[_g];
    _g = _g + 1;
    collision.Collision.check_triangle(packet,math._Vec3.Vec3_Impl_.div(tri.v0,packet.e_radius),math._Vec3.Vec3_Impl_.div(tri.v1,packet.e_radius),math._Vec3.Vec3_Impl_.div(tri.v2,packet.e_radius));
    end;
end
collision.Response.collide_and_slide = function(packet,gravity) 
  local _self = packet.r3_position;
  local player_position = math._Vec3.Vec3_Impl_._new(_self[1],_self[2],_self[3]);
  local e_position = math._Vec3.Vec3_Impl_.div(packet.r3_position,packet.e_radius);
  local e_velocity = math._Vec3.Vec3_Impl_.div(packet.r3_velocity,packet.e_radius);
  local final_position = math._Vec3.Vec3_Impl_._new();
  local slide_threshold = 0.9;
  packet.depth = 0;
  final_position = collision.Response.collide_with_world(packet,e_position,e_velocity,slide_threshold);
  packet.r3_position = math._Vec3.Vec3_Impl_.mul(final_position,packet.e_radius);
  local self1 = gravity;
  packet.r3_velocity = math._Vec3.Vec3_Impl_._new(self1[1],self1[2],self1[3]);
  e_velocity = math._Vec3.Vec3_Impl_.add(e_velocity,math._Vec3.Vec3_Impl_.div(gravity,packet.e_radius));
  packet.depth = 0;
  final_position = collision.Response.collide_with_world(packet,final_position,e_velocity,slide_threshold);
  packet.r3_velocity = math._Vec3.Vec3_Impl_.sub(packet.r3_position,player_position);
  packet.r3_position = math._Vec3.Vec3_Impl_.mul(final_position,packet.e_radius);
end
collision.Response.check_grounded = function(packet) 
  if (packet.found_collision) then 
    local e_position = math._Vec3.Vec3_Impl_.div(packet.r3_position,packet.e_radius);
    local _self = e_position;
    local new_base_point = math._Vec3.Vec3_Impl_._new(_self[1],_self[2],_self[3]);
    local slide_plane_normal = math._Vec3.Vec3_Impl_.sub(new_base_point,packet.intersect_point);
    math._Vec3.Vec3_Impl_.normalize(slide_plane_normal);
    local b = math._Vec3.Vec3_Impl_._new(0,0,1);
    local slope = ((slide_plane_normal[1] * b[1]) + (slide_plane_normal[2] * b[2])) + (slide_plane_normal[3] * b[3]);
    if (slope > 0.9) then 
      local temp = math._Vec3.Vec3_Impl_.sub(e_position,packet.intersect_point);
      local v = temp[3] - packet.e_radius[3];
      temp[3] = v;
      if (temp[3] < collision.Response.VERY_CLOSE_DIST) then 
        local push = 0.1;
        local v1 = ((packet.intersect_point[3] + push) + packet.e_radius[3]) * packet.e_radius[3];
        packet.r3_position[3] = v1;
      end;
      packet.grounded = true;
    end;
  end;
end
collision.Response.update = function(packet,gravity) 
  collision.Response.collide_and_slide(packet,gravity);
  collision.Response.check_grounded(packet);
end
_hxClasses["components.ShaderType"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Basic","Terrain"},2)}
components.ShaderType = _hxClasses["components.ShaderType"];
components.ShaderType.Basic = _hx_tab_array({[0]="Basic",0,__enum__ = components.ShaderType},2)

components.ShaderType.Terrain = _hx_tab_array({[0]="Terrain",1,__enum__ = components.ShaderType},2)

components.ShaderType.__empty_constructs__ = _hx_tab_array({[0] = components.ShaderType.Basic,components.ShaderType.Terrain}, 2)
_hxClasses["components.CollisionType"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="None","Triangle"},2)}
components.CollisionType = _hxClasses["components.CollisionType"];
components.CollisionType.None = _hx_tab_array({[0]="None",0,__enum__ = components.CollisionType},2)

components.CollisionType.Triangle = _hx_tab_array({[0]="Triangle",1,__enum__ = components.CollisionType},2)

components.CollisionType.__empty_constructs__ = _hx_tab_array({[0] = components.CollisionType.None,components.CollisionType.Triangle}, 2)

components.Drawable.new = function(model,collision,shader) 
  local self = _hx_new(components.Drawable.prototype)
  components.Drawable.super(self,model,collision,shader)
  return self
end
components.Drawable.super = function(self,model,collision,shader) 
  self.mesh = nil;
  self.filename = model;
  self.collision = (function() 
    local _hx_1
    if (collision ~= nil) then 
    _hx_1 = collision; else 
    _hx_1 = components.CollisionType.None; end
    return _hx_1
  end )();
  self.shader = (function() 
    local _hx_2
    if (shader ~= nil) then 
    _hx_2 = shader; else 
    _hx_2 = components.ShaderType.Basic; end
    return _hx_2
  end )();
end
components.Drawable.__name__ = {"components","Drawable"}
components.Drawable.prototype = _hx_a(
  
  '__class__',  components.Drawable
)
_hxClasses["components.TrickState"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="None","TrickA","TrickB","TrickC"},4)}
components.TrickState = _hxClasses["components.TrickState"];
components.TrickState.None = _hx_tab_array({[0]="None",0,__enum__ = components.TrickState},2)

components.TrickState.TrickA = _hx_tab_array({[0]="TrickA",1,__enum__ = components.TrickState},2)

components.TrickState.TrickB = _hx_tab_array({[0]="TrickB",2,__enum__ = components.TrickState},2)

components.TrickState.TrickC = _hx_tab_array({[0]="TrickC",3,__enum__ = components.TrickState},2)

components.TrickState.__empty_constructs__ = _hx_tab_array({[0] = components.TrickState.None,components.TrickState.TrickA,components.TrickState.TrickB,components.TrickState.TrickC}, 4)

components.Player.new = function(_fixed_tick) 
  local self = _hx_new(components.Player.prototype)
  components.Player.super(self,_fixed_tick)
  return self
end
components.Player.super = function(self,_fixed_tick) 
  self.jump = _hx_o({__fields__={jumping=true,falling=true,start=true,z_offset=true,speed=true},jumping=false,falling=false,start=0,z_offset=0,speed=0});
  self.tracks = haxe.ds.StringMap.new();
  self.trick_cooldown = 0;
  self.trick_state = components.TrickState.None;
  self.rail_attach_radius = 0.25;
  self.radius = math._Vec3.Vec3_Impl_._new(0.25,0.25,0.5);
  self.accel = math._Vec3.Vec3_Impl_._new();
  self.on_ground = false;
  self.friction = 1.25;
  self.mass = 75;
  self.turn_weight = 3;
  self.speed = 4;
  self.rail_stick_min = 1;
  System.super(self,_fixed_tick);
end
components.Player.__name__ = {"components","Player"}
components.Player.spawn = function(at,player) 
  local to_add = _hx_o({__fields__={camera=true,player=true,transform=true,drawable=true,animation=true},camera=Camera.new(at),player=player,transform=components.Transform.new(at),drawable=components.Drawable.new("assets/models/new-player.iqm"),animation=_hx_o({__fields__={filename=true,anims=true,timeline=true},filename="assets/models/new-player.iqm",anims=_hx_tab_array({[0]="assets/models/new-player.iqm" }, 1),timeline=nil})});
  World.entities:push(to_add);
end
components.Player.prototype = _hx_a(
  'mk_track', function(self,tl,name) 
    local this1 = self.tracks;
    if ((this1.k[name] or false)) then 
      local this2 = self.tracks;
      do return this2.v[name] end;
    end;
    local track = tl:new_track(name);
    if (track ~= nil) then 
      local _this = self.tracks;
      _this.v[name] = track;
      _this.k[name] = true;
    end;
    do return track end
  end,
  'get_track', function(self,tl,name) 
    local track = self:mk_track(tl,name);
    if (track ~= nil) then 
      do return track end;
    else
      Log.write(Level.System,"Animation not found: " .. name);
      do return self:mk_track(tl,"skate") end;
    end;
  end,
  'load', function(self) 
    local _hx_1_saved_contents, _hx_1_saved_size = love.filesystem.read("game.save",nil);
    local tmp = _hx_1_saved_contents ~= nil;
  end,
  'save', function(self) 
    local data = _hx_e();
    local out = haxe.Json.stringify(data);
    love.filesystem.write("game.save",out);
  end,
  'filter', function(self,e) 
    if (e.player ~= nil) then 
      do return true end;
    end;
    do return false end
  end,
  'process', function(self,e,dt) 
    local e1 = e.player;
    e1.trick_cooldown = e1.trick_cooldown - dt;
    if (e.player.trick_cooldown < 0) then 
      e.player.trick_cooldown = 0;
    end;
    if ((e.transform.position[3] < World.kill_z) and false) then 
      World.remove(e);
      Main.respawn();
    else
      editor.Editor.cursor = e.transform:copy();
    end;
  end
  ,'__class__',  components.Player
)
components.Player.__super__ = System
setmetatable(components.Player.prototype,{__index=System.prototype})

components.Rail.new = function(start,_end,mtx) 
  local self = _hx_new(components.Rail.prototype)
  components.Rail.super(self,start,_end,mtx)
  return self
end
components.Rail.super = function(self,start,_end,mtx) 
  self.friction = 0.25;
  local dx = start[1] - _end[1];
  local dy = start[2] - _end[2];
  local dz = start[3] - _end[3];
  self.length = _G.math.sqrt(((dx * dx) + (dy * dy)) + (dz * dz));
  self.capsule = math.Capsule.new(start,_end,0.25);
  self.mtx = mtx;
end
components.Rail.__name__ = {"components","Rail"}
components.Rail.prototype = _hx_a(
  'copy', function(self) 
    local _self = self.capsule.a;
    local r = math._Vec3.Vec3_Impl_._new(_self[1],_self[2],_self[3]);
    local self1 = self.capsule.b;
    local r1 = components.Rail.new(r,math._Vec3.Vec3_Impl_._new(self1[1],self1[2],self1[3]),self.mtx);
    r1.prev = self.prev;
    r1.next = self.next;
    do return r1 end
  end
  ,'__class__',  components.Rail
)

components.Sound.new = function() 
  local self = _hx_new(components.Sound.prototype)
  components.Sound.super(self)
  return self
end
components.Sound.super = function(self) 
  self.sounds = haxe.ds.StringMap.new();
end
components.Sound.__name__ = {"components","Sound"}
components.Sound.prototype = _hx_a(
  
  '__class__',  components.Sound
)

components.Transform.new = function(pos,vel,rot,sca,_static) 
  local self = _hx_new(components.Transform.prototype)
  components.Transform.super(self,pos,vel,rot,sca,_static)
  return self
end
components.Transform.super = function(self,pos,vel,rot,sca,_static) 
  if (_static == nil) then 
    _static = false;
  end;
  local this1;
  this1 = ({0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0});
  this1[0] = 1;
  self.mtx = this1;
  self.tile_x = 0;
  self.tile_y = 0;
  self.position = pos;
  self.is_static = _static;
  self:recenter();
  if (vel ~= nil) then 
    self.velocity = vel;
  else
    self.velocity = math._Vec3.Vec3_Impl_._new(0,0,0);
  end;
  if (rot ~= nil) then 
    self.orientation = rot;
  else
    self.orientation = math._Quat.Quat_Impl_._new(0,0,0,1);
  end;
  if (sca ~= nil) then 
    self.scale = sca;
  else
    self.scale = math._Vec3.Vec3_Impl_._new(1,1,1);
  end;
  self.snap_to = math._Quat.Quat_Impl_._new(0,0,0,1);
  self.snap = false;
  self.slerp = 0;
end
components.Transform.__name__ = {"components","Transform"}
components.Transform.prototype = _hx_a(
  'recenter', function(self) 
    if (self.position[1] < 0) then 
      local tmp = self;
      tmp.tile_x = tmp.tile_x - 1;
    end;
    if (self.position[2] < 0) then 
      local tmp1 = self;
      tmp1.tile_y = tmp1.tile_y - 1;
    end;
    if (self.position[1] > World.tile_size) then 
      local tmp2 = self;
      tmp2.tile_x = tmp2.tile_x + 1;
    end;
    if (self.position[2] > World.tile_size) then 
      local tmp3 = self;
      tmp3.tile_y = tmp3.tile_y + 1;
    end;
    self.tile_x = Std.int(math.Utils.wrap(self.tile_x,World.tiles_x));
    self.tile_y = Std.int(math.Utils.wrap(self.tile_y,World.tiles_y));
    local this1 = self.position;
    local v = math.Utils.wrap(self.position[1],World.tile_size);
    this1[1] = v;
    local this2 = self.position;
    local v1 = math.Utils.wrap(self.position[2],World.tile_size);
    this2[2] = v1;
  end,
  'copy', function(self) 
    local _self = self.position;
    local t = math._Vec3.Vec3_Impl_._new(_self[1],_self[2],_self[3]);
    local self1 = self.velocity;
    local t1 = math._Vec3.Vec3_Impl_._new(self1[1],self1[2],self1[3]);
    local this1 = self.orientation;
    local t2 = math._Quat.Quat_Impl_._new(this1[0],this1[1],this1[2],this1[3]);
    local self2 = self.scale;
    local t3 = components.Transform.new(t,t1,t2,math._Vec3.Vec3_Impl_._new(self2[1],self2[2],self2[3]));
    t3.tile_x = self.tile_x;
    t3.tile_y = self.tile_y;
    t3:update();
    do return t3 end
  end,
  'update', function(self) 
    self:recenter();
    math._Mat4.Mat4_Impl_.identity(self.mtx);
    local _self = self.scale;
    if ((((_self[1] * _self[1]) + (_self[2] * _self[2])) + (_self[3] * _self[3])) > 0) then 
      self.mtx = math._Mat4.Mat4_Impl_.mul(self.mtx,math._Mat4.Mat4_Impl_.scale(self.scale));
    end;
    local tmp = self.mtx;
    local a = math._Quat.Quat_Impl_.to_angle_axis(self.orientation);
    self.mtx = math._Mat4.Mat4_Impl_.mul(tmp,math._Mat4.Mat4_Impl_.from_angle_axis(a.angle,a.axis));
    self.mtx = math._Mat4.Mat4_Impl_.mul(self.mtx,math._Mat4.Mat4_Impl_.translate(World.to_world(self.position,self.tile_x,self.tile_y)));
  end
  ,'__class__',  components.Transform
)
_hxClasses["components.TriggerState"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Entered","Inside","Left"},3)}
components.TriggerState = _hxClasses["components.TriggerState"];
components.TriggerState.Entered = _hx_tab_array({[0]="Entered",0,__enum__ = components.TriggerState},2)

components.TriggerState.Inside = _hx_tab_array({[0]="Inside",1,__enum__ = components.TriggerState},2)

components.TriggerState.Left = _hx_tab_array({[0]="Left",2,__enum__ = components.TriggerState},2)

components.TriggerState.__empty_constructs__ = _hx_tab_array({[0] = components.TriggerState.Entered,components.TriggerState.Inside,components.TriggerState.Left}, 3)
_hxClasses["components.TriggerType"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Radius","Volume","RadiusInFront"},3)}
components.TriggerType = _hxClasses["components.TriggerType"];
components.TriggerType.Radius = _hx_tab_array({[0]="Radius",0,__enum__ = components.TriggerType},2)

components.TriggerType.Volume = _hx_tab_array({[0]="Volume",1,__enum__ = components.TriggerType},2)

components.TriggerType.RadiusInFront = _hx_tab_array({[0]="RadiusInFront",2,__enum__ = components.TriggerType},2)

components.TriggerType.__empty_constructs__ = _hx_tab_array({[0] = components.TriggerType.Radius,components.TriggerType.Volume,components.TriggerType.RadiusInFront}, 3)

components.Trigger.new = function(_cb,_type,_range,_max_angle,_enabled) 
  local self = _hx_new(components.Trigger.prototype)
  components.Trigger.super(self,_cb,_type,_range,_max_angle,_enabled)
  return self
end
components.Trigger.super = function(self,_cb,_type,_range,_max_angle,_enabled) 
  if (_enabled == nil) then 
    _enabled = false;
  end;
  if (_max_angle == nil) then 
    _max_angle = 0.5;
  end;
  self.inside = false;
  self.cb = _cb;
  self.type = _type;
  self.range = _range;
  self.max_angle = _max_angle;
  self.enabled = _enabled;
end
components.Trigger.__name__ = {"components","Trigger"}
components.Trigger.prototype = _hx_a(
  
  '__class__',  components.Trigger
)

editor.EditTile.new = {}
editor.EditTile.__name__ = {"editor","EditTile"}
editor.EditTile.draw = function(tile) 
  local zones = Zone.get_zones();
  local zone_paths = _hx_tab_array({ }, 0);
  local i = 0;
  local selected = 0;
  local tiles = zones:iterator();
  while (tiles:hasNext()) do 
    local tiles1 = tiles:next();
    local file = tiles1[0].filename;
    if (file == tile.filename) then 
      selected = i + 1;
    end;
    zone_paths:push(file);
    i = i + 1;
    end;
  tile.filename = zone_paths[selected - 1];
  local key = tile.filename;
  local zone = zones.v[key];
  local _g = 0;
  while (_g < zone.length) do 
    local tile1 = zone[_g];
    _g = _g + 1;
    Debug.aabb(World.to_world(math._Vec3.Vec3_Impl_._new(0,0,-editor.HeightmapTerrain.HEIGHT_SCALE),tile1.x,tile1.y),World.to_world(math._Vec3.Vec3_Impl_._new(World.tile_size,World.tile_size,0),tile1.x,tile1.y),0.25,0,1);
    end;
  local _hx_1_ret_status, _hx_1_ret_str = imgui.Widget.InputText("Filename",tile.filename,100);
  local new_name = _hx_1_ret_str;
  if (new_name ~= tile.filename) then 
    local _g1 = 0;
    while (_g1 < zone.length) do 
      local tile2 = zone[_g1];
      _g1 = _g1 + 1;
      tile2.filename = new_name;
      end;
  end;
  local t = ({});
  local _g2 = 0;
  while (_g2 < zone_paths.length) do 
    local v = zone_paths[_g2];
    _g2 = _g2 + 1;
    _G.table.insert(t,v);
    end;
  selected = _G.select(2, imgui.Widget.Combo("Zone",selected,t,zone_paths.length));
  imgui.Widget.InputInt2("Location",tile.x,tile.y);
end

editor.Editor.new = {}
editor.Editor.__name__ = {"editor","Editor"}
editor.Editor.init = function() 
  editor.Editor.cursor = components.Transform.new(math._Vec3.Vec3_Impl_._new());
  editor.EntityList.init();
  local cats = Type.allEnums(editor.UIPanelCategory);
  local _g = 0;
  while (_g < cats.length) do 
    local v = cats[_g];
    _g = _g + 1;
    editor.Panel.panels:push(_hx_o({__fields__={type=true,panels=true,dock_at=true},type=v,panels=_hx_tab_array({ }, 0),dock_at=(function() 
      local _hx_1
      if (v == editor.UIPanelCategory.Selection) then 
      _hx_1 = "Bottom"; else 
      _hx_1 = nil; end
      return _hx_1
    end )()}));
    end;
end
editor.Editor.edit_transform = function(e) 
  if (e.transform ~= nil) then 
    local _this = e.transform;
    local pos = World.to_world(_this.position,_this.tile_x,_this.tile_y);
    Debug.axis(pos,math._Vec3.Vec3_Impl_._new(1,0,0),math._Vec3.Vec3_Impl_._new(0,-1,0),math._Vec3.Vec3_Impl_._new(0,0,1),1.0);
    imgui.Widget.SetNextTreeNodeOpen(true,"FirstUseEver");
    if (imgui.Widget.TreeNode("Transform")) then 
      ui.Helpers.drag_vec3("Position",e.transform.position);
      ui.Helpers.drag_vec3("Velocity",e.transform.velocity);
      ui.Helpers.input_quat("Rotation",e.transform.orientation);
      local r1 = _hx_box_mr(_hx_table.pack(imgui.Widget.SliderInt("TX",e.transform.tile_x,0,World.tiles_x - 1)), {"status", "i1"});
      e.transform.tile_x = r1.i1;
      r1 = _hx_box_mr(_hx_table.pack(imgui.Widget.SliderInt("TY",e.transform.tile_y,0,World.tiles_y - 1)), {"status", "i1"});
      e.transform.tile_y = r1.i1;
      if (imgui.Widget.Button("Randomize##randrot")) then 
        local q = math._Quat.Quat_Impl_._new((_G.math.random() * 2) - 1,(_G.math.random() * 2) - 1,(_G.math.random() * 2) - 1,((_G.math.random() * 2) - 1) + 0.0001);
        math._Quat.Quat_Impl_.normalize(q);
        e.transform.orientation = q;
      end;
      if ((e.player ~= nil) and e.player.jump.falling) then 
        e.player.jump.z_offset = e.transform.position[3];
      end;
      if (e.rails ~= nil) then 
        local inv = math._Mat4.Mat4_Impl_.copy(e.transform.mtx);
        math._Mat4.Mat4_Impl_.invert(inv);
        e.transform:update();
        local mtx = e.transform.mtx;
        local _g = 0;
        local _g1 = e.rails;
        while (_g < _g1.length) do 
          local rail = _g1[_g];
          _g = _g + 1;
          local start = math._Mat4.Mat4_Impl_.mul_vec3(inv,rail.capsule.a);
          local _end = math._Mat4.Mat4_Impl_.mul_vec3(inv,rail.capsule.b);
          rail.capsule.a = math._Mat4.Mat4_Impl_.mul_vec3(mtx,start);
          rail.capsule.b = math._Mat4.Mat4_Impl_.mul_vec3(mtx,_end);
          end;
      else
        e.transform:update();
      end;
      ui.Helpers.drag_vec3("Scale",e.transform.scale);
      imgui.Widget.TreePop();
    end;
  else
    if (imgui.Widget.Button("Add transform")) then 
      e.transform = editor.Editor.cursor:copy();
    end;
  end;
end
editor.Editor.entity_info = function(e) 
  local title = (function() 
    local _hx_1
    if (editor.Prefab.is_empty()) then 
    _hx_1 = "New Prefab"; else 
    _hx_1 = "Add to Prefab"; end
    return _hx_1
  end )();
  if (imgui.Widget.Button(title)) then 
    editor.Prefab.add(e);
  end;
  imgui.Widget.Spacing();
  local _hx_2_v_f1, _hx_2_v_f2 = imgui.Window.GetContentRegionMax();
  local size_0 = _hx_2_v_f1;
  local size_1 = _hx_2_v_f2;
  editor.Editor.edit_transform(e);
  imgui.Widget.Spacing();
  if (e.drawable ~= nil) then 
    imgui.Widget.SetNextTreeNodeOpen(true,"FirstUseEver");
    if (imgui.Widget.TreeNode("Drawable")) then 
      local d = e.drawable;
      imgui.Widget.Text("Filename");
      imgui.Widget.SameLine(75);
      imgui.Widget.Text(d.filename);
      if (imgui.Widget.Button("Remove##remove_drawable")) then 
        e.drawable = nil;
      end;
      local actor = e.drawable.collision == components.CollisionType.Triangle;
      if (imgui.Widget.Checkbox("Collidable##set_collidable",actor)) then 
        if (actor) then 
          e.drawable.collision = components.CollisionType.None;
        else
          e.drawable.collision = components.CollisionType.Triangle;
        end;
      end;
      imgui.Widget.TreePop();
    end;
  else
    if (not editor.Editor.show_select_drawable and imgui.Widget.Button("Add drawable")) then 
      editor.Editor.show_select_drawable = true;
    end;
    if (editor.Editor.show_select_drawable) then 
      if (imgui.Widget.Button("Cancel##cancel_select_drawable")) then 
        editor.Editor.show_select_drawable = false;
      end;
      if (imgui.Window.BeginChild("select model",400,300)) then 
        local _g = 0;
        local _g1 = editor.EntityList.available_entities;
        while (_g < _g1.length) do 
          local v1 = _g1[_g];
          _g = _g + 1;
          local is_selected = editor.Editor.selected_item == v1.filename;
          if (imgui.Widget.Selectable(v1.filename,is_selected,nil,0,0)) then 
            if (editor.Editor.selected_item == v1.filename) then 
              editor.Editor.selected_item = nil;
              is_selected = false;
            else
              editor.Editor.selected_item = v1.filename;
              is_selected = true;
            end;
          end;
          if (is_selected) then 
            if (imgui.Widget.Button("Add##load_drawable")) then 
              e.drawable = components.Drawable.new(v1.filename);
              editor.Editor.show_select_drawable = false;
            end;
          end;
          end;
      end;
      imgui.Window.EndChild();
    end;
  end;
  imgui.Widget.Spacing();
  if (e.rails ~= nil) then 
    local mtx = e.transform.mtx;
    imgui.Widget.SetNextTreeNodeOpen(true,"FirstUseEver");
    if (imgui.Widget.TreeNode("Rails")) then 
      local i = 0;
      local inv = math._Mat4.Mat4_Impl_.copy(mtx);
      math._Mat4.Mat4_Impl_.invert(inv);
      local _g2 = 0;
      local _g11 = e.rails;
      while (_g2 < _g11.length) do 
        local rail = _g11[_g2];
        _g2 = _g2 + 1;
        local start = math._Mat4.Mat4_Impl_.mul_vec3(inv,rail.capsule.a);
        local _end = math._Mat4.Mat4_Impl_.mul_vec3(inv,rail.capsule.b);
        ui.Helpers.drag_vec3("A##" .. i,start);
        rail.capsule.a = math._Mat4.Mat4_Impl_.mul_vec3(mtx,start);
        ui.Helpers.drag_vec3("B##" .. i,_end);
        rail.capsule.b = math._Mat4.Mat4_Impl_.mul_vec3(mtx,_end);
        imgui.Widget.Spacing();
        i = i + 1;
        end;
      imgui.Widget.TreePop();
    end;
    if (imgui.Widget.Button("Add rail")) then 
      e.rails:push(components.Rail.new(math._Mat4.Mat4_Impl_.mul_vec3(mtx,math._Vec3.Vec3_Impl_._new()),math._Mat4.Mat4_Impl_.mul_vec3(mtx,math._Vec3.Vec3_Impl_._new())));
    end;
  else
    if (imgui.Widget.Button("Add rails")) then 
      e.rails = _hx_tab_array({ }, 0);
    end;
  end;
  imgui.Widget.Spacing();
end
editor.Editor.draw = function() 
  if (not Main.showing_menu(WindowType.EditorUI)) then 
    do return end;
  end;
  editor.Panel.register_panel(editor.UIPanelCategory.Settings,"Map Data",function() 
    if (imgui.Widget.Button("Reload Map")) then 
      World.reload();
      Main.respawn();
    end;
    if (imgui.Widget.Button("Save Map")) then 
      World.save();
    end;
    if (imgui.Widget.Button("Rebuild Octree")) then 
      World.rebuild_octree();
    end;
  end);
  editor.Panel.register_panel(editor.UIPanelCategory.Settings,"Playable Area",function() 
    local _hx_1_ret_status, _hx_1_ret_f1 = imgui.Widget.SliderFloat("Kill Z",World.kill_z,-editor.HeightmapTerrain.HEIGHT_SCALE,0);
    World.kill_z = _hx_1_ret_f1;
  end);
  editor.Panel.register_panel(editor.UIPanelCategory.Entities,"Add",function() 
    if (imgui.Widget.Button("New Entity")) then 
      local e = _hx_e();
      World.entities:push(e);
      editor.Editor.selected = e;
    end;
  end);
  editor.Panel.register_panel(editor.UIPanelCategory.Entities,"Prefab",function() 
    editor.Prefab.draw(editor.Editor.selected);
  end);
  editor.Panel.register_panel(editor.UIPanelCategory.Entities,"Current Tile",function() 
    local _this = editor.Editor.cursor;
    local vt = World.virtual_tile_at(World.to_world(_this.position,_this.tile_x,_this.tile_y));
    local real = vt.world_tile;
    editor.EditTile.draw(real);
    imgui.Widget.Spacing();
    imgui.Widget.SetNextTreeNodeOpen(true,"FirstUseEver");
    if (imgui.Widget.TreeNode("Entities")) then 
      local entities = vt.world_tile.entities;
      local i = 0;
      local _g = 0;
      local _hx_break_0 = false;
      while (_g < entities.length) do 
        repeat 
        local e1 = entities[_g];
        _g = _g + 1;
        if ((e1.drawable ~= nil) and (e1.drawable.filename == Zone.HEIGHTMAP_TILE)) then 
          break;
        end;
        local label;
        if (e1.drawable ~= nil) then 
          label = e1.drawable.filename;
        else
          local _this1 = e1.transform;
          label = Std.string(World.to_world(_this1.position,_this1.tile_x,_this1.tile_y));
        end;
        if (imgui.Widget.Selectable(label .. ("##" .. i),e1 == editor.Editor.selected,nil,0,0)) then 
          if (e1 == editor.Editor.selected) then 
            editor.Editor.selected = nil;
          else
            editor.Editor.selected = e1;
          end;
        end;
        i = i + 1;
        
      until true
      if _hx_break_1 then _hx_break_1 = false; break; end
      end;
      imgui.Widget.TreePop();
    end;
  end);
  editor.Panel.register_panel(editor.UIPanelCategory.Selection,"Selected",function() 
    if ((editor.Editor.selected ~= nil) and (editor.Editor.selected.parent ~= nil)) then 
      editor.Editor.current_locator = editor.Editor.selected.parent.entity;
    end;
    if (editor.Editor.selected ~= nil) then 
      editor.Editor.entity_info(editor.Editor.selected);
      imgui.Widget.Spacing();
      if (imgui.Widget.Button("Delete",0,0)) then 
        World.remove(editor.Editor.selected);
        editor.Editor.selected = nil;
      end;
    else
      imgui.Widget.Text("No entity selected");
    end;
  end);
  local _g1 = 0;
  local _g11 = editor.Panel.panels;
  local _hx_break_0 = false;
  while (_g1 < _g11.length) do 
    repeat 
    local panel = _g11[_g1];
    _g1 = _g1 + 1;
    if (panel.panels.length == 0) then 
      break;
    end;
    if (panel.dock_at ~= nil) then 
      imgui.Window.SetNextDock(panel.dock_at);
    end;
    if (imgui.Window.BeginDock(panel.type[0])) then 
      imgui.Widget.BeginGroup();
      if (panel.panels.length == 0) then 
        imgui.Widget.Text("Nothing to see here.");
      end;
      local _g2 = 0;
      local _g3 = panel.panels;
      local _hx_break_1 = false;
      while (_g2 < _g3.length) do 
        repeat 
        local info = _g3[_g2];
        _g2 = _g2 + 1;
        local label1 = info.label;
        imgui.Widget.SetNextTreeNodeOpen(true,"FirstUseEver");
        if (not imgui.Widget.TreeNode(label1)) then 
          break;
        end;
        info:cb();
        imgui.Widget.TreePop();
        
      until true
      if _hx_break_2 then _hx_break_2 = false; break; end
      end;
      imgui.Widget.EndGroup();
    end;
    panel.panels = _hx_tab_array({ }, 0);
    imgui.Window.EndDock();
    
  until true
  if _hx_break_1 then _hx_break_1 = false; break; end
  end;
end

editor.EntityList.new = {}
editor.EntityList.__name__ = {"editor","EntityList"}
editor.EntityList.collect_r = function(path) 
  local ret = _hx_tab_array({ }, 0);
  local items = love.filesystem.getDirectoryItems(path);
  lua.PairTools.ipairsEach(items,function(i,file) 
    local filename = path .. "/" .. file;
    if (love.filesystem.isFile(filename)) then 
      ret:push(_hx_o({__fields__={filename=true},filename=filename}));
      do return end;
    end;
    if (love.filesystem.isDirectory(filename)) then 
      local merge = editor.EntityList.collect_r(filename);
      local _g = 0;
      while (_g < merge.length) do 
        local v = merge[_g];
        _g = _g + 1;
        ret:push(v);
        end;
      do return end;
    end;
  end);
  do return ret end;
end
editor.EntityList.init = function() 
  editor.EntityList.available_entities = editor.EntityList.collect_r("assets/models");
end

editor.HeightmapTerrain.new = {}
editor.HeightmapTerrain.__name__ = {"editor","HeightmapTerrain"}
editor.HeightmapTerrain.to_iqmfile = function(mesh,indices) 
  local info = _hx_o({__fields__={first=true,last=true,count=true,material=true,name=true},first=1,last=indices,count=indices,material="Material",name="Terrain"});
  local file = _hx_o({__fields__={mesh=true,bounds=true,meshes=true,has_joints=true,has_anims=true,triangles=true},mesh=mesh,bounds=({}),meshes=({info}),has_joints=false,has_anims=false,triangles=nil});
  do return file end;
end
editor.HeightmapTerrain.generate_tile = function(texture,xform,tx,ty) 
  local verts_per_tile = 11;
  local tile_verts_x = verts_per_tile;
  local tile_verts_y = verts_per_tile;
  local w = texture:getWidth();
  local h = texture:getHeight();
  local pw = w / World.tiles_x;
  local ph = h / World.tiles_y;
  local x_offset = tx * pw;
  local y_offset = ty * ph;
  local verts = ({});
  local i = 1;
  local _g1 = 0;
  local _g = tile_verts_y;
  while (_g1 < _g) do 
    _g1 = _g1 + 1;
    local y = _g1 - 1;
    local _g3 = 0;
    local _g2 = tile_verts_x;
    while (_g3 < _g2) do 
      _g3 = _g3 + 1;
      local x = _g3 - 1;
      local x_pct = x / (tile_verts_x - 1);
      local y_pct = y / (tile_verts_y - 1);
      local _hx_1_pixel_r, _hx_1_pixel_g, _hx_1_pixel_b, _hx_1_pixel_a = texture:getPixel(_G.math.fmod((x_offset + (x_pct * pw)), w),_G.math.fmod((y_offset + (y_pct * ph)), h));
      local pos_x = x_pct * World.tile_size;
      local pos_y = y_pct * World.tile_size;
      local pos_z = (_hx_1_pixel_r / 255) * editor.HeightmapTerrain.HEIGHT_SCALE;
      local v = { pos_x, pos_y, pos_z, x_pct, y_pct, 0, -1, 0, 255, 255, 255, 255 }
      verts[i] = v;
      i = i + 1;
      end;
    end;
  local triangles = _hx_tab_array({ }, 0);
  local indices = ({});
  i = 1;
  local dummy = math._Vec3.Vec3_Impl_._new(0,0,0);
  local _g11 = 0;
  local _g4 = tile_verts_y - 1;
  while (_g11 < _g4) do 
    _g11 = _g11 + 1;
    local y1 = _g11 - 1;
    local _g31 = 0;
    local _g21 = tile_verts_x - 1;
    while (_g31 < _g21) do 
      _g31 = _g31 + 1;
      local x1 = _g31 - 1;
      local start = Std.int((y1 * tile_verts_x) + x1) + 1;
      indices[i] = start;
      i = i + 1;
      indices[i] = start + 1;
      i = i + 1;
      indices[i] = start + tile_verts_x;
      i = i + 1;
      indices[i] = start + 1;
      i = i + 1;
      indices[i] = (start + 1) + tile_verts_x;
      i = i + 1;
      indices[i] = start + tile_verts_x;
      i = i + 1;
      local a = verts[indices[i - 6]];
      local b = verts[indices[i - 5]];
      local c = verts[indices[i - 4]];
      local d = verts[indices[i - 2]];
      local t1 = math.Triangle.new(math._Vec3.Vec3_Impl_._new(a[1],a[2],a[3]),math._Vec3.Vec3_Impl_._new(b[1],b[2],b[3]),math._Vec3.Vec3_Impl_._new(c[1],c[2],c[3]),dummy);
      t1.vn = t1:normal();
      local t2 = math.Triangle.new(math._Vec3.Vec3_Impl_._new(b[1],b[2],b[3]),math._Vec3.Vec3_Impl_._new(d[1],d[2],d[3]),math._Vec3.Vec3_Impl_._new(c[1],c[2],c[3]),dummy);
      t2.vn = t2:normal();
      a[5] = t1.vn[1];
      a[6] = t1.vn[2];
      a[7] = t1.vn[3];
      b[5] = t1.vn[1];
      b[6] = t1.vn[2];
      b[7] = t1.vn[3];
      c[5] = t2.vn[1];
      c[6] = t2.vn[2];
      c[7] = t2.vn[3];
      d[5] = t2.vn[1];
      d[6] = t2.vn[2];
      d[7] = t2.vn[3];
      triangles:push(t1);
      triangles:push(t2);
      end;
    end;
  local fmt = {
			{ "VertexPosition", "float", 3 },
			{ "VertexTexCoord", "float", 2 },
			{ "VertexNormal", "float", 3 },
			{ "VertexColor", "byte", 4 }
		}
  local mesh = love.graphics.newMesh(fmt,i - 1,"triangles","static");
  mesh:setVertices(verts);
  mesh:setVertexMap(indices);
  local tile = World.get_tile(tx,ty);
  World.add_triangles(tile,xform,triangles);
  do return editor.HeightmapTerrain.to_iqmfile(mesh,i - 1) end;
end
_hxClasses["editor.UIPanelCategory"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Settings","Entities","Selection"},3)}
editor.UIPanelCategory = _hxClasses["editor.UIPanelCategory"];
editor.UIPanelCategory.Settings = _hx_tab_array({[0]="Settings",0,__enum__ = editor.UIPanelCategory},2)

editor.UIPanelCategory.Entities = _hx_tab_array({[0]="Entities",1,__enum__ = editor.UIPanelCategory},2)

editor.UIPanelCategory.Selection = _hx_tab_array({[0]="Selection",2,__enum__ = editor.UIPanelCategory},2)

editor.UIPanelCategory.__empty_constructs__ = _hx_tab_array({[0] = editor.UIPanelCategory.Settings,editor.UIPanelCategory.Entities,editor.UIPanelCategory.Selection}, 3)

editor.Panel.new = {}
editor.Panel.__name__ = {"editor","Panel"}
editor.Panel.register_panel = function(cat,label,fn) 
  editor.Panel.panels[cat[1]].panels:push(_hx_o({__fields__={label=true,cb=true},label=label,cb=fn}));
end

editor.Prefab.new = {}
editor.Prefab.__name__ = {"editor","Prefab"}
editor.Prefab.draw = function(_sel) 
  editor.Prefab.selected = _sel;
  local _hx_1_v_f1, _hx_1_v_f2 = imgui.Window.GetContentRegionMax();
  local size_0 = _hx_1_v_f1;
  local size_1 = _hx_1_v_f2;
  if (editor.Prefab.group.length > 0) then 
    local _hx_2_ret_status, _hx_2_ret_str = imgui.Widget.InputText("Filename",editor.Prefab.tmp_filename,100);
    editor.Prefab.tmp_filename = _hx_2_ret_str;
    if (imgui.Widget.Checkbox("Keep Positions",editor.Prefab.keep_positions)) then 
      editor.Prefab.keep_positions = not editor.Prefab.keep_positions;
    end;
    imgui.Widget.SameLine(100);
    if (imgui.Widget.Button("Save##save_prefab") and (editor.Prefab.tmp_filename.length > 0)) then 
      editor.Prefab.save(editor.Prefab.tmp_filename);
      editor.Prefab.tmp_filename = "";
      editor.Prefab.keep_positions = false;
      editor.Prefab.clear();
    end;
  end;
  local prefabs = editor.Prefab.get_prefabs();
  local i = 0;
  local _g = 0;
  while (_g < prefabs.length) do 
    local prefab = prefabs[_g];
    _g = _g + 1;
    imgui.Widget.Text(prefab);
    imgui.Widget.SameLine(size_0 - 50);
    if (imgui.Widget.Button("Load##" .. i,50)) then 
      local _this = editor.Editor.cursor;
      editor.Prefab.load(World.to_world(_this.position,_this.tile_x,_this.tile_y),prefab);
    end;
    i = i + 1;
    end;
end
editor.Prefab.collect = function(path) 
  local ret = _hx_tab_array({ }, 0);
  local items = love.filesystem.getDirectoryItems(path);
  lua.PairTools.ipairsEach(items,function(i,file) 
    ret:push(file);
  end);
  do return ret end;
end
editor.Prefab.get_center = function() 
  local center = math._Vec3.Vec3_Impl_._new();
  local _g = 0;
  local _g1 = editor.Prefab.group;
  while (_g < _g1.length) do 
    local e = _g1[_g];
    _g = _g + 1;
    center = math._Vec3.Vec3_Impl_.add(center,e.transform.position);
    end;
  center = math._Vec3.Vec3_Impl_.fdiv(center,editor.Prefab.group.length);
  do return center end;
end
editor.Prefab.is_empty = function() 
  do return editor.Prefab.group.length == 0 end;
end
editor.Prefab.get_prefabs = function() 
  if (editor.Prefab.prefab_cache ~= nil) then 
    do return editor.Prefab.prefab_cache end;
  end;
  local files = editor.Prefab.collect(editor.Prefab.BASE_DIRECTORY);
  editor.Prefab.prefab_cache = files;
  do return files end;
end
editor.Prefab.add = function(e) 
  if ((e.player == nil) and (e.transform ~= nil)) then 
    editor.Prefab.group:push(e);
  end;
end
editor.Prefab.clear = function() 
  editor.Prefab.group = _hx_tab_array({ }, 0);
end
editor.Prefab.load = function(base_position,filename) 
  local _hx_1_saved_contents, _hx_1_saved_size = love.filesystem.read(editor.Prefab.BASE_DIRECTORY .. filename);
  local data = haxe.Json.parse(_hx_1_saved_contents);
  local vtile = World.virtual_tile_at(base_position);
  local tile = vtile.world_tile;
  local rails = _hx_tab_array({ }, 0);
  local position = (function() 
    local _hx_2
    if (data.keep_positions) then 
    _hx_2 = math._Vec3.Vec3_Impl_._new(); else 
    _hx_2 = base_position; end
    return _hx_2
  end )();
  local loc = _hx_o({__fields__={parent=true,transform=true},parent=_hx_o({__fields__={entity=true,name=true},entity=nil,name=filename}),transform=components.Transform.new(position)});
  local _g = 0;
  local _g1 = data.entities;
  while (_g < _g1.length) do 
    local entity = _g1[_g];
    _g = _g + 1;
    local target = _hx_o({__fields__={parent=true},parent=_hx_o({__fields__={entity=true,name=true},entity=loc,name=nil})});
    target.prefab_path = filename;
    local is_static = true;
    local tx = components.Transform.new(math._Vec3.Vec3_Impl_.add(math._Vec3.Vec3_Impl_._new(entity.pos[0],entity.pos[1],entity.pos[2]),position),math._Vec3.Vec3_Impl_._new(),math._Quat.Quat_Impl_._new(entity.rot[0],entity.rot[1],entity.rot[2],entity.rot[3]),math._Vec3.Vec3_Impl_._new(entity.scale[0],entity.scale[1],entity.scale[2]),is_static);
    math._Quat.Quat_Impl_.normalize(tx.orientation);
    tx.tile_x = tile.x;
    tx.tile_y = tile.y;
    tx:update();
    target.transform = tx;
    if (entity.rails.length > 0) then 
      target.rails = _hx_tab_array({ }, 0);
      local _g2 = 0;
      local _g3 = entity.rails;
      while (_g2 < _g3.length) do 
        local rail = _g3[_g2];
        _g2 = _g2 + 1;
        local start = math._Mat4.Mat4_Impl_.mul_vec3(tx.mtx,math._Vec3.Vec3_Impl_._new(rail[0],rail[1],rail[2]));
        local _end = math._Mat4.Mat4_Impl_.mul_vec3(tx.mtx,math._Vec3.Vec3_Impl_._new(rail[3],rail[4],rail[5]));
        local r = components.Rail.new(start,_end);
        target.rails:push(r);
        rails:push(r);
        end;
    end;
    local threshold = 0.0125;
    local _g21 = 0;
    while (_g21 < rails.length) do 
      local k = rails[_g21];
      _g21 = _g21 + 1;
      local _g31 = 0;
      local _hx_break_2 = false;
      while (_g31 < rails.length) do 
        repeat 
        local i = rails[_g31];
        _g31 = _g31 + 1;
        if (k == i) then 
          break;
        end;
        local tmp;
        local a = k.capsule.a;
        local b = i.capsule.a;
        local dx = a[1] - b[1];
        local dy = a[2] - b[2];
        local dz = a[3] - b[3];
        if (not (_G.math.sqrt(((dx * dx) + (dy * dy)) + (dz * dz)) < threshold)) then 
          local a1 = k.capsule.a;
          local b1 = i.capsule.b;
          local dx1 = a1[1] - b1[1];
          local dy1 = a1[2] - b1[2];
          local dz1 = a1[3] - b1[3];
          tmp = _G.math.sqrt(((dx1 * dx1) + (dy1 * dy1)) + (dz1 * dz1)) < threshold;
        else
          tmp = true;
        end;
        if (tmp) then 
          k.prev = i;
        end;
        local tmp1;
        local a2 = k.capsule.b;
        local b2 = i.capsule.a;
        local dx2 = a2[1] - b2[1];
        local dy2 = a2[2] - b2[2];
        local dz2 = a2[3] - b2[3];
        if (not (_G.math.sqrt(((dx2 * dx2) + (dy2 * dy2)) + (dz2 * dz2)) < threshold)) then 
          local a3 = k.capsule.b;
          local b3 = i.capsule.b;
          local dx3 = a3[1] - b3[1];
          local dy3 = a3[2] - b3[2];
          local dz3 = a3[3] - b3[3];
          tmp1 = _G.math.sqrt(((dx3 * dx3) + (dy3 * dy3)) + (dz3 * dz3)) < threshold;
        else
          tmp1 = true;
        end;
        if (tmp1) then 
          k.next = i;
        end;
        
      until true
      if _hx_break_3 then _hx_break_3 = false; break; end
      end;
      end;
    local collidable = Type.createEnumIndex(components.CollisionType,entity.collision,nil);
    if (entity.model.length ~= 0) then 
      target.drawable = components.Drawable.new(entity.model,collidable,components.ShaderType.Basic);
    end;
    World.entities:push(target);
    World.refresh_entity(nil,vtile.world_tile,target,true);
    end;
end
editor.Prefab.save = function(filename) 
  if (editor.Prefab.group.length == 0) then 
    do return end;
  end;
  editor.Prefab.get_prefabs();
  local full_name = filename;
  if (editor.Prefab.keep_positions) then 
    full_name = full_name .. editor.Prefab.FILE_TILE_SUFFIX;
  else
    full_name = full_name .. editor.Prefab.FILE_SUFFIX;
  end;
  editor.Prefab.prefab_cache:push(full_name);
  local data = _hx_o({__fields__={keep_positions=true,entities=true},keep_positions=editor.Prefab.keep_positions,entities=_hx_tab_array({ }, 0)});
  local center = editor.Prefab.get_center();
  if (editor.Prefab.keep_positions) then 
    center = math._Vec3.Vec3_Impl_.scale(center,0);
  end;
  local id = 0;
  local _g = 0;
  local _g1 = editor.Prefab.group;
  while (_g < _g1.length) do 
    local e = _g1[_g];
    _g = _g + 1;
    local _pos = math._Vec3.Vec3_Impl_.sub(e.transform.position,center);
    local _rot = e.transform.orientation;
    local _sca = e.transform.scale;
    local mesh = "";
    local coll = components.CollisionType.None;
    local rail_data = _hx_tab_array({ }, 0);
    if (e.drawable ~= nil) then 
      mesh = e.drawable.filename;
      coll = e.drawable.collision;
    end;
    if (e.rails ~= nil) then 
      local inv = math._Mat4.Mat4_Impl_.copy(e.transform.mtx);
      math._Mat4.Mat4_Impl_.invert(inv);
      local _g2 = 0;
      local _g3 = e.rails;
      while (_g2 < _g3.length) do 
        local rail = _g3[_g2];
        _g2 = _g2 + 1;
        local start = math._Mat4.Mat4_Impl_.mul_vec3(inv,rail.capsule.a);
        local _end = math._Mat4.Mat4_Impl_.mul_vec3(inv,rail.capsule.b);
        rail_data:push(_hx_tab_array({[0]=start[1], start[2], start[3], _end[1], _end[2], _end[3] }, 6));
        end;
    end;
    data.entities:push(_hx_o({__fields__={model=true,id=true,collision=true,pos=true,rot=true,scale=true,rails=true},model=mesh,id=id,collision=coll[1],pos=_hx_tab_array({[0]=_pos[1], _pos[2], _pos[3] }, 3),rot=_hx_tab_array({[0]=_rot[0], _rot[1], _rot[2], _rot[3] }, 4),scale=_hx_tab_array({[0]=_sca[1], _sca[2], _sca[3] }, 3),rails=rail_data}));
    id = id + 1;
    end;
  local out = haxe.Json.stringify(data);
  love.filesystem.createDirectory(editor.Prefab.BASE_DIRECTORY);
  haxe.Log.trace(filename,_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true,customParams=true},fileName="Prefab.hx",lineNumber=272,className="editor.Prefab",methodName="save",customParams=_hx_tab_array({[0]=out }, 1)}));
  love.filesystem.write(editor.Prefab.BASE_DIRECTORY .. full_name,out);
end

haxe.IMap.new = {}
haxe.IMap.__name__ = {"haxe","IMap"}
haxe.IMap.prototype = _hx_a(
  
  '__class__',  haxe.IMap
)

haxe.Json.new = {}
haxe.Json.__name__ = {"haxe","Json"}
haxe.Json.parse = function(text) 
  do return haxe.format.JsonParser.new(text):parseRec() end;
end
haxe.Json.stringify = function(value,replacer,space) 
  do return haxe.format.JsonPrinter.print(value,replacer,space) end;
end

haxe.Log.new = {}
haxe.Log.__name__ = {"haxe","Log"}
haxe.Log.trace = function(v,infos) 
  local str = nil;
  if (infos ~= nil) then 
    str = infos.fileName .. ":" .. infos.lineNumber .. ": " .. Std.string(v);
    if (infos.customParams ~= nil) then 
      str = str .. ("," .. infos.customParams:join(","));
    end;
  else
    str = v;
  end;
  if (str == nil) then 
    str = "null";
  end;
  _hx_print(str);
end

haxe.crypto.Crc32.new = {}
haxe.crypto.Crc32.__name__ = {"haxe","crypto","Crc32"}
haxe.crypto.Crc32.make = function(data) 
  local init = -1;
  local crc = init;
  local b = data.b;
  local _g1 = 0;
  local _g = data.length;
  while (_g1 < _g) do 
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    local tmp = _hx_bit.band((_hx_bit.bxor(crc,b[i])),255);
    local _g2 = 0;
    while (_g2 < 8) do 
      _g2 = _g2 + 1;
      local j = _g2 - 1;
      if ((_hx_bit.band(tmp,1)) == 1) then 
        tmp = _hx_bit.bxor(_hx_bit.rshift(tmp,1),-306674912);
      else
        tmp = _hx_bit.rshift(tmp,1);
      end;
      end;
    crc = _hx_bit.bxor(_hx_bit.rshift(crc,8),tmp);
    end;
  do return _hx_bit.bxor(crc,init) end;
end

haxe.ds.BalancedTree.new = function() 
  local self = _hx_new(haxe.ds.BalancedTree.prototype)
  haxe.ds.BalancedTree.super(self)
  return self
end
haxe.ds.BalancedTree.super = function(self) 
end
haxe.ds.BalancedTree.__name__ = {"haxe","ds","BalancedTree"}
haxe.ds.BalancedTree.prototype = _hx_a(
  'set', function(self,key,value) 
    self.root = self:setLoop(key,value,self.root);
  end,
  'get', function(self,key) 
    local node = self.root;
    while (node ~= nil) do 
      local c = self:compare(key,node.key);
      if (c == 0) then 
        do return node.value end;
      end;
      if (c < 0) then 
        node = node.left;
      else
        node = node.right;
      end;
      end;
    do return nil end
  end,
  'exists', function(self,key) 
    local node = self.root;
    while (node ~= nil) do 
      local c = self:compare(key,node.key);
      if (c == 0) then 
        do return true end;
      else
        if (c < 0) then 
          node = node.left;
        else
          node = node.right;
        end;
      end;
      end;
    do return false end
  end,
  'keys', function(self) 
    local ret = _hx_tab_array({ }, 0);
    self:keysLoop(self.root,ret);
    local _gthis = ret;
    local cur_length = 0;
    do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self) 
      do return cur_length < _gthis.length end;
    end,next=function(self) 
      cur_length = cur_length + 1;
      do return _gthis[cur_length - 1] end;
    end}) end
  end,
  'setLoop', function(self,k,v,node) 
    if (node == nil) then 
      do return haxe.ds.TreeNode.new(nil,k,v,nil) end;
    end;
    local c = self:compare(k,node.key);
    if (c == 0) then 
      do return haxe.ds.TreeNode.new(node.left,k,v,node.right,(function() 
        local _hx_1
        if (node == nil) then 
        _hx_1 = 0; else 
        _hx_1 = node._height; end
        return _hx_1
      end )()) end;
    else
      if (c < 0) then 
        local nl = self:setLoop(k,v,node.left);
        do return self:balance(nl,node.key,node.value,node.right) end;
      else
        local nr = self:setLoop(k,v,node.right);
        do return self:balance(node.left,node.key,node.value,nr) end;
      end;
    end;
  end,
  'keysLoop', function(self,node,acc) 
    if (node ~= nil) then 
      self:keysLoop(node.left,acc);
      acc:push(node.key);
      self:keysLoop(node.right,acc);
    end;
  end,
  'balance', function(self,l,k,v,r) 
    local hl = (function() 
      local _hx_1
      if (l == nil) then 
      _hx_1 = 0; else 
      _hx_1 = l._height; end
      return _hx_1
    end )();
    local hr = (function() 
      local _hx_2
      if (r == nil) then 
      _hx_2 = 0; else 
      _hx_2 = r._height; end
      return _hx_2
    end )();
    if (hl > (hr + 2)) then 
      local _this = l.left;
      local _this1 = l.right;
      if ((function() 
        local _hx_3
        if (_this == nil) then 
        _hx_3 = 0; else 
        _hx_3 = _this._height; end
        return _hx_3
      end )() >= (function() 
        local _hx_4
        if (_this1 == nil) then 
        _hx_4 = 0; else 
        _hx_4 = _this1._height; end
        return _hx_4
      end )()) then 
        do return haxe.ds.TreeNode.new(l.left,l.key,l.value,haxe.ds.TreeNode.new(l.right,k,v,r)) end;
      else
        do return haxe.ds.TreeNode.new(haxe.ds.TreeNode.new(l.left,l.key,l.value,l.right.left),l.right.key,l.right.value,haxe.ds.TreeNode.new(l.right.right,k,v,r)) end;
      end;
    else
      if (hr > (hl + 2)) then 
        local _this2 = r.right;
        local _this3 = r.left;
        if ((function() 
          local _hx_5
          if (_this2 == nil) then 
          _hx_5 = 0; else 
          _hx_5 = _this2._height; end
          return _hx_5
        end )() > (function() 
          local _hx_6
          if (_this3 == nil) then 
          _hx_6 = 0; else 
          _hx_6 = _this3._height; end
          return _hx_6
        end )()) then 
          do return haxe.ds.TreeNode.new(haxe.ds.TreeNode.new(l,k,v,r.left),r.key,r.value,r.right) end;
        else
          do return haxe.ds.TreeNode.new(haxe.ds.TreeNode.new(l,k,v,r.left.left),r.left.key,r.left.value,haxe.ds.TreeNode.new(r.left.right,r.key,r.value,r.right)) end;
        end;
      else
        do return haxe.ds.TreeNode.new(l,k,v,r,(function() 
          local _hx_7
          if (hl > hr) then 
          _hx_7 = hl; else 
          _hx_7 = hr; end
          return _hx_7
        end )() + 1) end;
      end;
    end;
  end,
  'compare', function(self,k1,k2) 
    do return Reflect.compare(k1,k2) end
  end
  ,'__class__',  haxe.ds.BalancedTree
)

haxe.ds.TreeNode.new = function(l,k,v,r,h) 
  local self = _hx_new(haxe.ds.TreeNode.prototype)
  haxe.ds.TreeNode.super(self,l,k,v,r,h)
  return self
end
haxe.ds.TreeNode.super = function(self,l,k,v,r,h) 
  if (h == nil) then 
    h = -1;
  end;
  self.left = l;
  self.key = k;
  self.value = v;
  self.right = r;
  if (h == -1) then 
    local tmp;
    local _this = self.left;
    local _this1 = self.right;
    if ((function() 
      local _hx_1
      if (_this == nil) then 
      _hx_1 = 0; else 
      _hx_1 = _this._height; end
      return _hx_1
    end )() > (function() 
      local _hx_2
      if (_this1 == nil) then 
      _hx_2 = 0; else 
      _hx_2 = _this1._height; end
      return _hx_2
    end )()) then 
      local _this2 = self.left;
      if (_this2 == nil) then 
        tmp = 0;
      else
        tmp = _this2._height;
      end;
    else
      local _this3 = self.right;
      if (_this3 == nil) then 
        tmp = 0;
      else
        tmp = _this3._height;
      end;
    end;
    self._height = tmp + 1;
  else
    self._height = h;
  end;
end
haxe.ds.TreeNode.__name__ = {"haxe","ds","TreeNode"}
haxe.ds.TreeNode.prototype = _hx_a(
  
  '__class__',  haxe.ds.TreeNode
)

haxe.ds.EnumValueMap.new = function() 
  local self = _hx_new(haxe.ds.EnumValueMap.prototype)
  haxe.ds.EnumValueMap.super(self)
  return self
end
haxe.ds.EnumValueMap.super = function(self) 
  haxe.ds.BalancedTree.super(self);
end
haxe.ds.EnumValueMap.__name__ = {"haxe","ds","EnumValueMap"}
haxe.ds.EnumValueMap.__interfaces__ = {haxe.IMap}
haxe.ds.EnumValueMap.prototype = _hx_a(
  'compare', function(self,k1,k2) 
    local d = k1[1] - k2[1];
    if (d ~= 0) then 
      do return d end;
    end;
    local p1 = k1:slice(2);
    local p2 = k2:slice(2);
    if ((p1.length == 0) and (p2.length == 0)) then 
      do return 0 end;
    end;
    do return self:compareArgs(p1,p2) end
  end,
  'compareArgs', function(self,a1,a2) 
    local ld = a1.length - a2.length;
    if (ld ~= 0) then 
      do return ld end;
    end;
    local _g1 = 0;
    local _g = a1.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      local d = self:compareArg(a1[i],a2[i]);
      if (d ~= 0) then 
        do return d end;
      end;
      end;
    do return 0 end
  end,
  'compareArg', function(self,v1,v2) 
    if (Reflect.isEnumValue(v1) and Reflect.isEnumValue(v2)) then 
      do return self:compare(v1,v2) end;
    else
      if (lua.Boot.__instanceof(v1,Array) and lua.Boot.__instanceof(v2,Array)) then 
        do return self:compareArgs(v1,v2) end;
      else
        do return Reflect.compare(v1,v2) end;
      end;
    end;
  end
  ,'__class__',  haxe.ds.EnumValueMap
)
haxe.ds.EnumValueMap.__super__ = haxe.ds.BalancedTree
setmetatable(haxe.ds.EnumValueMap.prototype,{__index=haxe.ds.BalancedTree.prototype})

haxe.ds.GenericCell.new = function(elt,next) 
  local self = _hx_new(haxe.ds.GenericCell.prototype)
  haxe.ds.GenericCell.super(self,elt,next)
  return self
end
haxe.ds.GenericCell.super = function(self,elt,next) 
  self.elt = elt;
  self.next = next;
end
haxe.ds.GenericCell.__name__ = {"haxe","ds","GenericCell"}
haxe.ds.GenericCell.prototype = _hx_a(
  
  '__class__',  haxe.ds.GenericCell
)

haxe.ds.ObjectMap.new = function() 
  local self = _hx_new(haxe.ds.ObjectMap.prototype)
  haxe.ds.ObjectMap.super(self)
  return self
end
haxe.ds.ObjectMap.super = function(self) 
  self.h = ({});
  self.k = ({});
end
haxe.ds.ObjectMap.__name__ = {"haxe","ds","ObjectMap"}
haxe.ds.ObjectMap.__interfaces__ = {haxe.IMap}
haxe.ds.ObjectMap.prototype = _hx_a(
  'set', function(self,key,value) 
    self.h[key] = value;
    self.k[key] = true;
  end,
  'get', function(self,key) 
    do return self.h[key] end
  end,
  'remove', function(self,key) 
    if (self.k[key] == nil) then 
      do return false end;
    end;
    self.k[key] = nil;
    self.h[key] = nil;
    do return true end
  end,
  'keys', function(self) 
    local _gthis = self;
    local cur = next(self.h,nil);
    do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
      local ret = cur;
      cur = next(_gthis.k,cur);
      do return ret end;
    end,hasNext=function(self) 
      do return cur ~= nil end;
    end}) end
  end
  ,'__class__',  haxe.ds.ObjectMap
)

haxe.ds.StringMap.new = function() 
  local self = _hx_new(haxe.ds.StringMap.prototype)
  haxe.ds.StringMap.super(self)
  return self
end
haxe.ds.StringMap.super = function(self) 
  self.v = {}
  self.k = {}
end
haxe.ds.StringMap.__name__ = {"haxe","ds","StringMap"}
haxe.ds.StringMap.__interfaces__ = {haxe.IMap}
haxe.ds.StringMap.prototype = _hx_a(
  'set', function(self,key,value) 
    self.v[key] = value;
    self.k[key] = true;
  end,
  'get', function(self,key) 
    do return self.v[key] end
  end,
  'keys', function(self) 
    local cur = _hx_tab_array({ }, 0);
    for _k,_v in pairs(self.k) do
			if(_v)then cur:push(_k) end
		end;
    do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
      local ret = cur:pop();
      do return ret end;
    end,hasNext=function(self) 
      do return cur.length > 0 end;
    end}) end
  end,
  'iterator', function(self) 
    local _gthis = self;
    local it = self:keys();
    do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self) 
      do return it:hasNext() end;
    end,next=function(self) 
      do return _gthis.v[it:next()] end;
    end}) end
  end
  ,'__class__',  haxe.ds.StringMap
)

haxe.format.JsonParser.new = function(str) 
  local self = _hx_new(haxe.format.JsonParser.prototype)
  haxe.format.JsonParser.super(self,str)
  return self
end
haxe.format.JsonParser.super = function(self,str) 
  self.str = str;
  self.pos = 0;
end
haxe.format.JsonParser.__name__ = {"haxe","format","JsonParser"}
haxe.format.JsonParser.prototype = _hx_a(
  'parseRec', function(self) 
    while (true) do 
      local index = (function() 
      local _hx_obj = self;
      local _hx_fld = 'pos';
      local _ = _hx_obj[_hx_fld];
      _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
       return _;
       end)();
      local c = _G.string.byte(self.str,index + 1);
      local c1 = c;
      if (c1) == 9 or (c1) == 10 or (c1) == 13 or (c1) == 32 then 
      elseif (c1) == 34 then 
        do return self:parseString() end;
      elseif (c1) == 45 or (c1) == 48 or (c1) == 49 or (c1) == 50 or (c1) == 51 or (c1) == 52 or (c1) == 53 or (c1) == 54 or (c1) == 55 or (c1) == 56 or (c1) == 57 then 
        local c2 = c;
        local start = self.pos - 1;
        local minus = c2 == 45;
        local digit = not minus;
        local zero = c2 == 48;
        local point = false;
        local e = false;
        local pm = false;
        local _end = false;
        while (true) do 
          local index1 = (function() 
          local _hx_obj = self;
          local _hx_fld = 'pos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          c2 = _G.string.byte(self.str,index1 + 1);
          local c3 = c2;
          if (c3) == 43 or (c3) == 45 then 
            if (not e or pm) then 
              self:invalidNumber(start);
            end;
            digit = false;
            pm = true;
          elseif (c3) == 46 then 
            if (minus or point) then 
              self:invalidNumber(start);
            end;
            digit = false;
            point = true;
          elseif (c3) == 48 then 
            if (zero and not point) then 
              self:invalidNumber(start);
            end;
            if (minus) then 
              minus = false;
              zero = true;
            end;
            digit = true;
          elseif (c3) == 49 or (c3) == 50 or (c3) == 51 or (c3) == 52 or (c3) == 53 or (c3) == 54 or (c3) == 55 or (c3) == 56 or (c3) == 57 then 
            if (zero and not point) then 
              self:invalidNumber(start);
            end;
            if (minus) then 
              minus = false;
            end;
            digit = true;
            zero = false;
          elseif (c3) == 69 or (c3) == 101 then 
            if ((minus or zero) or e) then 
              self:invalidNumber(start);
            end;
            digit = false;
            e = true;else
          if (not digit) then 
            self:invalidNumber(start);
          end;
          self.pos = self.pos - 1;
          _end = true; end;
          if (_end) then 
            break;
          end;
          end;
        local f = Std.parseFloat(self.str:substr(start,self.pos - start));
        local i = Std.int(f);
        if (i == f) then 
          do return i end;
        else
          do return f end;
        end;
      elseif (c1) == 91 then 
        local arr = _hx_tab_array({ }, 0);
        local comma = nil;
        while (true) do 
          local index2 = (function() 
          local _hx_obj = self;
          local _hx_fld = 'pos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          local c4 = _G.string.byte(self.str,index2 + 1);
          local c5 = c4;
          if (c5) == 9 or (c5) == 10 or (c5) == 13 or (c5) == 32 then 
          elseif (c5) == 44 then 
            if (comma) then 
              comma = false;
            else
              self:invalidChar();
            end;
          elseif (c5) == 93 then 
            if (comma == false) then 
              self:invalidChar();
            end;
            do return arr end;else
          if (comma) then 
            self:invalidChar();
          end;
          self.pos = self.pos - 1;
          arr:push(self:parseRec());
          comma = true; end;
          end;
      elseif (c1) == 102 then 
        local save = self.pos;
        local tmp;
        local tmp1;
        local tmp2;
        local index3 = (function() 
        local _hx_obj = self;
        local _hx_fld = 'pos';
        local _ = _hx_obj[_hx_fld];
        _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
         return _;
         end)();
        if (_G.string.byte(self.str,index3 + 1) == 97) then 
          local index4 = (function() 
          local _hx_obj = self;
          local _hx_fld = 'pos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          tmp2 = _G.string.byte(self.str,index4 + 1) ~= 108;
        else
          tmp2 = true;
        end;
        if (not tmp2) then 
          local index5 = (function() 
          local _hx_obj = self;
          local _hx_fld = 'pos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          tmp1 = _G.string.byte(self.str,index5 + 1) ~= 115;
        else
          tmp1 = true;
        end;
        if (not tmp1) then 
          local index6 = (function() 
          local _hx_obj = self;
          local _hx_fld = 'pos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          tmp = _G.string.byte(self.str,index6 + 1) ~= 101;
        else
          tmp = true;
        end;
        if (tmp) then 
          self.pos = save;
          self:invalidChar();
        end;
        do return false end;
      elseif (c1) == 110 then 
        local save1 = self.pos;
        local tmp3;
        local tmp4;
        local index7 = (function() 
        local _hx_obj = self;
        local _hx_fld = 'pos';
        local _ = _hx_obj[_hx_fld];
        _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
         return _;
         end)();
        if (_G.string.byte(self.str,index7 + 1) == 117) then 
          local index8 = (function() 
          local _hx_obj = self;
          local _hx_fld = 'pos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          tmp4 = _G.string.byte(self.str,index8 + 1) ~= 108;
        else
          tmp4 = true;
        end;
        if (not tmp4) then 
          local index9 = (function() 
          local _hx_obj = self;
          local _hx_fld = 'pos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          tmp3 = _G.string.byte(self.str,index9 + 1) ~= 108;
        else
          tmp3 = true;
        end;
        if (tmp3) then 
          self.pos = save1;
          self:invalidChar();
        end;
        do return nil end;
      elseif (c1) == 116 then 
        local save2 = self.pos;
        local tmp5;
        local tmp6;
        local index10 = (function() 
        local _hx_obj = self;
        local _hx_fld = 'pos';
        local _ = _hx_obj[_hx_fld];
        _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
         return _;
         end)();
        if (_G.string.byte(self.str,index10 + 1) == 114) then 
          local index11 = (function() 
          local _hx_obj = self;
          local _hx_fld = 'pos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          tmp6 = _G.string.byte(self.str,index11 + 1) ~= 117;
        else
          tmp6 = true;
        end;
        if (not tmp6) then 
          local index12 = (function() 
          local _hx_obj = self;
          local _hx_fld = 'pos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          tmp5 = _G.string.byte(self.str,index12 + 1) ~= 101;
        else
          tmp5 = true;
        end;
        if (tmp5) then 
          self.pos = save2;
          self:invalidChar();
        end;
        do return true end;
      elseif (c1) == 123 then 
        local obj = _hx_e();
        local field = nil;
        local comma1 = nil;
        while (true) do 
          local index13 = (function() 
          local _hx_obj = self;
          local _hx_fld = 'pos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          local c6 = _G.string.byte(self.str,index13 + 1);
          local c7 = c6;
          if (c7) == 9 or (c7) == 10 or (c7) == 13 or (c7) == 32 then 
          elseif (c7) == 34 then 
            if (comma1) then 
              self:invalidChar();
            end;
            field = self:parseString();
          elseif (c7) == 44 then 
            if (comma1) then 
              comma1 = false;
            else
              self:invalidChar();
            end;
          elseif (c7) == 58 then 
            if (field == nil) then 
              self:invalidChar();
            end;
            obj[field] = self:parseRec();
            field = nil;
            comma1 = true;
          elseif (c7) == 125 then 
            if ((field ~= nil) or (comma1 == false)) then 
              self:invalidChar();
            end;
            do return obj end;else
          self:invalidChar(); end;
          end;else
      self:invalidChar(); end;
      end;
  end,
  'parseString', function(self) 
    local start = self.pos;
    local buf = nil;
    while (true) do 
      local index = (function() 
      local _hx_obj = self;
      local _hx_fld = 'pos';
      local _ = _hx_obj[_hx_fld];
      _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
       return _;
       end)();
      local c = _G.string.byte(self.str,index + 1);
      if (c == 34) then 
        break;
      end;
      if (c == 92) then 
        if (buf == nil) then 
          buf = StringBuf.new();
        end;
        local s = self.str;
        local len = (self.pos - start) - 1;
        local part = (function() 
          local _hx_1
          if (len == nil) then 
          _hx_1 = s:substr(start); else 
          _hx_1 = s:substr(start,len); end
          return _hx_1
        end )();
        _G.table.insert(buf.b,part);
        local buf1 = buf;
        buf1.length = buf1.length + part.length;
        local index1 = (function() 
        local _hx_obj = self;
        local _hx_fld = 'pos';
        local _ = _hx_obj[_hx_fld];
        _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
         return _;
         end)();
        c = _G.string.byte(self.str,index1 + 1);
        local c1 = c;
        if (c1) == 34 or (c1) == 47 or (c1) == 92 then 
          _G.table.insert(buf.b,_G.string.char(c));
          local buf2 = buf;
          buf2.length = buf2.length + 1;
        elseif (c1) == 98 then 
          _G.table.insert(buf.b,_G.string.char(8));
          local buf3 = buf;
          buf3.length = buf3.length + 1;
        elseif (c1) == 102 then 
          _G.table.insert(buf.b,_G.string.char(12));
          local buf4 = buf;
          buf4.length = buf4.length + 1;
        elseif (c1) == 110 then 
          _G.table.insert(buf.b,_G.string.char(10));
          local buf5 = buf;
          buf5.length = buf5.length + 1;
        elseif (c1) == 114 then 
          _G.table.insert(buf.b,_G.string.char(13));
          local buf6 = buf;
          buf6.length = buf6.length + 1;
        elseif (c1) == 116 then 
          _G.table.insert(buf.b,_G.string.char(9));
          local buf7 = buf;
          buf7.length = buf7.length + 1;
        elseif (c1) == 117 then 
          local uc = Std.parseInt("0x" .. self.str:substr(self.pos,4));
          local tmp = self;
          tmp.pos = tmp.pos + 4;
          if (uc <= 127) then 
            _G.table.insert(buf.b,_G.string.char(uc));
            local buf8 = buf;
            buf8.length = buf8.length + 1;
          else
            if (uc <= 2047) then 
              _G.table.insert(buf.b,_G.string.char(_hx_bit.bor(192,_hx_bit.arshift(uc,6))));
              local buf9 = buf;
              buf9.length = buf9.length + 1;
              _G.table.insert(buf.b,_G.string.char(_hx_bit.bor(128,_hx_bit.band(uc,63))));
              local buf10 = buf;
              buf10.length = buf10.length + 1;
            else
              if (uc <= 65535) then 
                _G.table.insert(buf.b,_G.string.char(_hx_bit.bor(224,_hx_bit.arshift(uc,12))));
                local buf11 = buf;
                buf11.length = buf11.length + 1;
                _G.table.insert(buf.b,_G.string.char(_hx_bit.bor(128,_hx_bit.band(_hx_bit.arshift(uc,6),63))));
                local buf12 = buf;
                buf12.length = buf12.length + 1;
                _G.table.insert(buf.b,_G.string.char(_hx_bit.bor(128,_hx_bit.band(uc,63))));
                local buf13 = buf;
                buf13.length = buf13.length + 1;
              else
                _G.table.insert(buf.b,_G.string.char(_hx_bit.bor(240,_hx_bit.arshift(uc,18))));
                local buf14 = buf;
                buf14.length = buf14.length + 1;
                _G.table.insert(buf.b,_G.string.char(_hx_bit.bor(128,_hx_bit.band(_hx_bit.arshift(uc,12),63))));
                local buf15 = buf;
                buf15.length = buf15.length + 1;
                _G.table.insert(buf.b,_G.string.char(_hx_bit.bor(128,_hx_bit.band(_hx_bit.arshift(uc,6),63))));
                local buf16 = buf;
                buf16.length = buf16.length + 1;
                _G.table.insert(buf.b,_G.string.char(_hx_bit.bor(128,_hx_bit.band(uc,63))));
                local buf17 = buf;
                buf17.length = buf17.length + 1;
              end;
            end;
          end;else
        _G.error("Invalid escape sequence \\" .. _G.string.char(c) .. " at position " .. (self.pos - 1),0); end;
        start = self.pos;
      else
        if (c == nil) then 
          _G.error("Unclosed string",0);
        end;
      end;
      end;
    if (buf == nil) then 
      do return self.str:substr(start,(self.pos - start) - 1) end;
    else
      local s1 = self.str;
      local len1 = (self.pos - start) - 1;
      local part1 = (function() 
        local _hx_2
        if (len1 == nil) then 
        _hx_2 = s1:substr(start); else 
        _hx_2 = s1:substr(start,len1); end
        return _hx_2
      end )();
      _G.table.insert(buf.b,part1);
      local buf18 = buf;
      buf18.length = buf18.length + part1.length;
      do return _G.table.concat(buf.b) end;
    end;
  end,
  'invalidChar', function(self) 
    self.pos = self.pos - 1;
    _G.error("Invalid char " .. _G.string.byte(self.str,self.pos + 1) .. " at position " .. self.pos,0);
  end,
  'invalidNumber', function(self,start) 
    _G.error("Invalid number at position " .. start .. ": " .. self.str:substr(start,self.pos - start),0);
  end
  ,'__class__',  haxe.format.JsonParser
)

haxe.format.JsonPrinter.new = function(replacer,space) 
  local self = _hx_new(haxe.format.JsonPrinter.prototype)
  haxe.format.JsonPrinter.super(self,replacer,space)
  return self
end
haxe.format.JsonPrinter.super = function(self,replacer,space) 
  self.replacer = _hx_funcToField(replacer);
  self.indent = space;
  self.pretty = space ~= nil;
  self.nind = 0;
  self.buf = StringBuf.new();
end
haxe.format.JsonPrinter.__name__ = {"haxe","format","JsonPrinter"}
haxe.format.JsonPrinter.print = function(o,replacer,space) 
  local printer = haxe.format.JsonPrinter.new(replacer,space);
  printer:write("",o);
  do return _G.table.concat(printer.buf.b) end;
end
haxe.format.JsonPrinter.prototype = _hx_a(
  'write', function(self,k,v) 
    if (self.replacer ~= nil) then 
      v = self:replacer(k,v);
    end;
    local _g = Type.typeof(v);
    local _g1 = _g[1];
    if (_g1) == 0 then 
      local _this = self.buf;
      local str = "null";
      _G.table.insert(_this.b,str);
      local _this1 = _this;
      _this1.length = _this1.length + str.length;
    elseif (_g1) == 1 then 
      local _this2 = self.buf;
      local str1 = Std.string(v);
      _G.table.insert(_this2.b,str1);
      local _this3 = _this2;
      _this3.length = _this3.length + str1.length;
    elseif (_g1) == 2 then 
      local _this4 = self.buf;
      local str2;
      local f = v;
      if ((f > -_G.math.huge) and (f < _G.math.huge)) then 
        str2 = v;
      else
        str2 = "null";
      end;
      local str3 = Std.string(str2);
      _G.table.insert(_this4.b,str3);
      local _this5 = _this4;
      _this5.length = _this5.length + str3.length;
    elseif (_g1) == 3 then 
      local _this6 = self.buf;
      local str4 = Std.string(v);
      _G.table.insert(_this6.b,str4);
      local _this7 = _this6;
      _this7.length = _this7.length + str4.length;
    elseif (_g1) == 4 then 
      self:fieldsString(v,Reflect.fields(v));
    elseif (_g1) == 5 then 
      local _this8 = self.buf;
      local str5 = "\"<fun>\"";
      _G.table.insert(_this8.b,str5);
      local _this9 = _this8;
      _this9.length = _this9.length + str5.length;
    elseif (_g1) == 6 then 
      local c = _g[2];
      if (c == String) then 
        self:quote(v);
      else
        if (c == Array) then 
          local v1 = v;
          local _this10 = self.buf;
          _G.table.insert(_this10.b,_G.string.char(91));
          local _this11 = _this10;
          _this11.length = _this11.length + 1;
          local len = v1.length;
          local last = len - 1;
          local _g11 = 0;
          local _g2 = len;
          while (_g11 < _g2) do 
            _g11 = _g11 + 1;
            local i = _g11 - 1;
            if (i > 0) then 
              local _this12 = self.buf;
              _G.table.insert(_this12.b,_G.string.char(44));
              local _this13 = _this12;
              _this13.length = _this13.length + 1;
            else
              self.nind = self.nind + 1;
            end;
            if (self.pretty) then 
              local _this14 = self.buf;
              _G.table.insert(_this14.b,_G.string.char(10));
              local _this15 = _this14;
              _this15.length = _this15.length + 1;
            end;
            if (self.pretty) then 
              local v2 = StringTools.lpad("",self.indent,self.nind * self.indent.length);
              local _this16 = self.buf;
              local str6 = Std.string(v2);
              _G.table.insert(_this16.b,str6);
              local _this17 = _this16;
              _this17.length = _this17.length + str6.length;
            end;
            self:write(i,v1[i]);
            if (i == last) then 
              self.nind = self.nind - 1;
              if (self.pretty) then 
                local _this18 = self.buf;
                _G.table.insert(_this18.b,_G.string.char(10));
                local _this19 = _this18;
                _this19.length = _this19.length + 1;
              end;
              if (self.pretty) then 
                local v3 = StringTools.lpad("",self.indent,self.nind * self.indent.length);
                local _this20 = self.buf;
                local str7 = Std.string(v3);
                _G.table.insert(_this20.b,str7);
                local _this21 = _this20;
                _this21.length = _this21.length + str7.length;
              end;
            end;
            end;
          local _this22 = self.buf;
          _G.table.insert(_this22.b,_G.string.char(93));
          local _this23 = _this22;
          _this23.length = _this23.length + 1;
        else
          if (c == haxe.ds.StringMap) then 
            local v4 = v;
            local o = _hx_e();
            local k1 = v4:keys();
            while (k1:hasNext()) do 
              local k2 = k1:next();
              o[k2] = v4.v[k2];
              end;
            self:fieldsString(o,Reflect.fields(o));
          else
            if (c == Date) then 
              local v5 = v;
              self:quote(lua.Boot.dateStr(v5));
            else
              self:fieldsString(v,Reflect.fields(v));
            end;
          end;
        end;
      end;
    elseif (_g1) == 7 then 
      local i1 = v[1];
      local _this24 = self.buf;
      local str8 = Std.string(i1);
      _G.table.insert(_this24.b,str8);
      local _this25 = _this24;
      _this25.length = _this25.length + str8.length;
    elseif (_g1) == 8 then 
      local _this26 = self.buf;
      local str9 = "\"???\"";
      _G.table.insert(_this26.b,str9);
      local _this27 = _this26;
      _this27.length = _this27.length + str9.length; end;
  end,
  'fieldsString', function(self,v,fields) 
    local _this = self.buf;
    _G.table.insert(_this.b,_G.string.char(123));
    local _this1 = _this;
    _this1.length = _this1.length + 1;
    local len = fields.length;
    local last = len - 1;
    local first = true;
    local _g1 = 0;
    local _g = len;
    local _hx_break_0 = false;
    while (_g1 < _g) do 
      repeat 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      local f = fields[i];
      local value = Reflect.field(v,f);
      if (Reflect.isFunction(value)) then 
        break;
      end;
      if (first) then 
        self.nind = self.nind + 1;
        first = false;
      else
        local _this2 = self.buf;
        _G.table.insert(_this2.b,_G.string.char(44));
        local _this3 = _this2;
        _this3.length = _this3.length + 1;
      end;
      if (self.pretty) then 
        local _this4 = self.buf;
        _G.table.insert(_this4.b,_G.string.char(10));
        local _this5 = _this4;
        _this5.length = _this5.length + 1;
      end;
      if (self.pretty) then 
        local v1 = StringTools.lpad("",self.indent,self.nind * self.indent.length);
        local _this6 = self.buf;
        local str = Std.string(v1);
        _G.table.insert(_this6.b,str);
        local _this7 = _this6;
        _this7.length = _this7.length + str.length;
      end;
      self:quote(f);
      local _this8 = self.buf;
      _G.table.insert(_this8.b,_G.string.char(58));
      local _this9 = _this8;
      _this9.length = _this9.length + 1;
      if (self.pretty) then 
        local _this10 = self.buf;
        _G.table.insert(_this10.b,_G.string.char(32));
        local _this11 = _this10;
        _this11.length = _this11.length + 1;
      end;
      self:write(f,value);
      if (i == last) then 
        self.nind = self.nind - 1;
        if (self.pretty) then 
          local _this12 = self.buf;
          _G.table.insert(_this12.b,_G.string.char(10));
          local _this13 = _this12;
          _this13.length = _this13.length + 1;
        end;
        if (self.pretty) then 
          local v2 = StringTools.lpad("",self.indent,self.nind * self.indent.length);
          local _this14 = self.buf;
          local str1 = Std.string(v2);
          _G.table.insert(_this14.b,str1);
          local _this15 = _this14;
          _this15.length = _this15.length + str1.length;
        end;
      end;
      
    until true
    if _hx_break_1 then _hx_break_1 = false; break; end
    end;
    local _this16 = self.buf;
    _G.table.insert(_this16.b,_G.string.char(125));
    local _this17 = _this16;
    _this17.length = _this17.length + 1;
  end,
  'quote', function(self,s) 
    local _this = self.buf;
    _G.table.insert(_this.b,_G.string.char(34));
    local _this1 = _this;
    _this1.length = _this1.length + 1;
    local i = 0;
    while (true) do 
      i = i + 1;
      local c = _G.string.byte(s,(i - 1) + 1);
      if (c == nil) then 
        break;
      end;
      local c1 = c;
      if (c1) == 8 then 
        local _this2 = self.buf;
        local str = "\\b";
        _G.table.insert(_this2.b,str);
        local _this3 = _this2;
        _this3.length = _this3.length + str.length;
      elseif (c1) == 9 then 
        local _this4 = self.buf;
        local str1 = "\\t";
        _G.table.insert(_this4.b,str1);
        local _this5 = _this4;
        _this5.length = _this5.length + str1.length;
      elseif (c1) == 10 then 
        local _this6 = self.buf;
        local str2 = "\\n";
        _G.table.insert(_this6.b,str2);
        local _this7 = _this6;
        _this7.length = _this7.length + str2.length;
      elseif (c1) == 12 then 
        local _this8 = self.buf;
        local str3 = "\\f";
        _G.table.insert(_this8.b,str3);
        local _this9 = _this8;
        _this9.length = _this9.length + str3.length;
      elseif (c1) == 13 then 
        local _this10 = self.buf;
        local str4 = "\\r";
        _G.table.insert(_this10.b,str4);
        local _this11 = _this10;
        _this11.length = _this11.length + str4.length;
      elseif (c1) == 34 then 
        local _this12 = self.buf;
        local str5 = "\\\"";
        _G.table.insert(_this12.b,str5);
        local _this13 = _this12;
        _this13.length = _this13.length + str5.length;
      elseif (c1) == 92 then 
        local _this14 = self.buf;
        local str6 = "\\\\";
        _G.table.insert(_this14.b,str6);
        local _this15 = _this14;
        _this15.length = _this15.length + str6.length;else
      local _this16 = self.buf;
      _G.table.insert(_this16.b,_G.string.char(c));
      local _this17 = _this16;
      _this17.length = _this17.length + 1; end;
      end;
    local _this18 = self.buf;
    _G.table.insert(_this18.b,_G.string.char(34));
    local _this19 = _this18;
    _this19.length = _this19.length + 1;
  end
  ,'__class__',  haxe.format.JsonPrinter
)

haxe.io.Bytes.new = function(length,b) 
  local self = _hx_new(haxe.io.Bytes.prototype)
  haxe.io.Bytes.super(self,length,b)
  return self
end
haxe.io.Bytes.super = function(self,length,b) 
  self.length = length;
  self.b = b;
end
haxe.io.Bytes.__name__ = {"haxe","io","Bytes"}
haxe.io.Bytes.ofString = function(s) 
  local _g = _hx_tab_array({ }, 0);
  local _g2 = 0;
  local _g1 = s.length;
  while (_g2 < _g1) do 
    _g2 = _g2 + 1;
    local c = _g2 - 1;
    _g:push(_G.string.byte(s,c + 1));
    end;
  local bytes = _g;
  do return haxe.io.Bytes.new(bytes.length,bytes) end;
end
haxe.io.Bytes.prototype = _hx_a(
  
  '__class__',  haxe.io.Bytes
)

haxe.io.Eof.new = {}
haxe.io.Eof.__name__ = {"haxe","io","Eof"}
haxe.io.Eof.prototype = _hx_a(
  'toString', function(self) 
    do return "Eof" end
  end
  ,'__class__',  haxe.io.Eof
)

lua.UserData.new = {}
lua.UserData.__name__ = {"lua","UserData"}

lua.Boot.new = {}
lua.Boot.__name__ = {"lua","Boot"}
lua.Boot.getClass = function(o) 
  if (lua.Boot.__instanceof(o,Array)) then 
    do return Array end;
  else
    local cl = o.__class__;
    if (cl ~= nil) then 
      do return cl end;
    else
      do return nil end;
    end;
  end;
end
lua.Boot.__instanceof = function(o,cl) 
  if (cl == nil) then 
    do return false end;
  end;
  local cl1 = cl;
  if (cl1) == Array then 
    do return lua.Boot.isArray(o) end;
  elseif (cl1) == Bool then 
    do return _G.type(o) == "boolean" end;
  elseif (cl1) == Dynamic then 
    do return true end;
  elseif (cl1) == Float then 
    do return _G.type(o) == "number" end;
  elseif (cl1) == Int then 
    if (_G.type(o) == "number") then 
      do return _hx_bit_clamp(o) == o end;
    else
      do return false end;
    end;
  elseif (cl1) == String then 
    do return _G.type(o) == "string" end;
  elseif (cl1) == _G.table then 
    do return _G.type(o) == "table" end;
  elseif (cl1) == lua.Thread then 
    do return _G.type(o) == "thread" end;
  elseif (cl1) == lua.UserData then 
    do return _G.type(o) == "userdata" end;else
  if (((o ~= nil) and (_G.type(o) == "table")) and (_G.type(cl) == "table")) then 
    if (lua.Boot.extendsOrImplements(lua.Boot.getClass(o),cl)) then 
      do return true end;
    end;
    if ((function() 
      local _hx_1
      if (cl == Class) then 
      _hx_1 = o.__name__ ~= nil; else 
      _hx_1 = false; end
      return _hx_1
    end )()) then 
      do return true end;
    end;
    if ((function() 
      local _hx_2
      if (cl == Enum) then 
      _hx_2 = o.__ename__ ~= nil; else 
      _hx_2 = false; end
      return _hx_2
    end )()) then 
      do return true end;
    end;
    do return o.__enum__ == cl end;
  else
    do return false end;
  end; end;
end
lua.Boot.isArray = function(o) 
  if (_G.type(o) == "table") then 
    if ((o.__enum__ == nil) and (_G.getmetatable(o) ~= nil)) then 
      do return _G.getmetatable(o).__index == Array.prototype end;
    else
      do return false end;
    end;
  else
    do return false end;
  end;
end
lua.Boot.printEnum = function(o,s) 
  if (o.length == 2) then 
    do return o[0] end;
  else
    local str = Std.string(o[0]) .. "(";
    s = s .. "\t";
    local _g1 = 2;
    local _g = o.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      if (i ~= 2) then 
        str = str .. ("," .. lua.Boot.__string_rec(o[i],s));
      else
        str = str .. lua.Boot.__string_rec(o[i],s);
      end;
      end;
    do return str .. ")" end;
  end;
end
lua.Boot.printClassRec = function(c,result,s) 
  if (result == nil) then 
    result = "";
  end;
  local f = lua.Boot.__string_rec;
  for k,v in pairs(c) do if result ~= '' then result = result .. ', ' end result = result .. k .. ':' .. f(v, s.. '	') end;
  do return result end;
end
lua.Boot.__string_rec = function(o,s) 
  if (s == nil) then 
    s = "";
  end;
  local _g = type(o);
  local _g1 = _g;
  if (_g1) == "boolean" then 
    do return tostring(o) end;
  elseif (_g1) == "function" then 
    do return "<function>" end;
  elseif (_g1) == "nil" then 
    do return "null" end;
  elseif (_g1) == "number" then 
    if (o == _G.math.huge) then 
      do return "Infinity" end;
    else
      if (o == -_G.math.huge) then 
        do return "-Infinity" end;
      else
        if (o ~= o) then 
          do return "NaN" end;
        else
          do return tostring(o) end;
        end;
      end;
    end;
  elseif (_g1) == "string" then 
    do return o end;
  elseif (_g1) == "table" then 
    if (o.__enum__ ~= nil) then 
      do return lua.Boot.printEnum(o,s) end;
    else
      if ((o.toString ~= nil) and not lua.Boot.isArray(o)) then 
        do return o:toString() end;
      else
        if (lua.Boot.isArray(o)) then 
          local o2 = o;
          if (s.length > 5) then 
            do return "[...]" end;
          else
            local _g2 = _hx_tab_array({ }, 0);
            local _g11 = 0;
            while (_g11 < o2.length) do 
              local i = o2[_g11];
              _g11 = _g11 + 1;
              _g2:push(lua.Boot.__string_rec(i,s .. 1));
              end;
            do return "[" .. _g2:join(",") .. "]" end;
          end;
        else
          if (o.__class__ ~= nil) then 
            do return "{" .. lua.Boot.printClassRec(o,"",s .. "\t") .. "}" end;
          else
            local fields = lua.Boot.fieldIterator(o);
            local buffer = ({});
            local first = true;
            _G.table.insert(buffer,"{ ");
            local f = fields;
            while (f:hasNext()) do 
              local f1 = f:next();
              if (first) then 
                first = false;
              else
                _G.table.insert(buffer,", ");
              end;
              _G.table.insert(buffer,"" .. Std.string(f1) .. " : " .. Std.string(o[f1]));
              end;
            _G.table.insert(buffer," }");
            do return _G.table.concat(buffer,"") end;
          end;
        end;
      end;
    end;
  elseif (_g1) == "thread" then 
    do return "<thread>" end;
  elseif (_g1) == "userdata" then 
    do return "<userdata>" end;else
  _G.error("Unknown Lua type",0); end;
end
lua.Boot.dateStr = function(date) 
  local m = date:getMonth() + 1;
  local d = date:getDate();
  local h = date:getHours();
  local mi = date:getMinutes();
  local s = date:getSeconds();
  do return date:getFullYear() .. "-" .. ((function() 
    local _hx_1
    if (m < 10) then 
    _hx_1 = "0" .. m; else 
    _hx_1 = "" .. m; end
    return _hx_1
  end )()) .. "-" .. ((function() 
    local _hx_2
    if (d < 10) then 
    _hx_2 = "0" .. d; else 
    _hx_2 = "" .. d; end
    return _hx_2
  end )()) .. " " .. ((function() 
    local _hx_3
    if (h < 10) then 
    _hx_3 = "0" .. h; else 
    _hx_3 = "" .. h; end
    return _hx_3
  end )()) .. ":" .. ((function() 
    local _hx_4
    if (mi < 10) then 
    _hx_4 = "0" .. mi; else 
    _hx_4 = "" .. mi; end
    return _hx_4
  end )()) .. ":" .. ((function() 
    local _hx_5
    if (s < 10) then 
    _hx_5 = "0" .. s; else 
    _hx_5 = "" .. s; end
    return _hx_5
  end )()) end;
end
lua.Boot.strDate = function(s) 
  local _g = s.length;
  local _g1 = _g;
  if (_g1) == 8 then 
    local k = s:split(":");
    local t = _G.os.time(_hx_o({__fields__={year=true,month=true,day=true,hour=true,min=true,sec=true},year=0,month=1,day=1,hour=_G.tonumber(k[0]),min=_G.tonumber(k[1]),sec=_G.tonumber(k[2])}));
    local d = _hx_e();
    _G.setmetatable(d,_hx_o({__fields__={__index=true},__index=Date.prototype}));
    d.t = t / 1000;
    d.d = _G.os.date("*t",Std.int(d.t));
    do return d end;
  elseif (_g1) == 10 then 
    local k1 = s:split("-");
    do return Date.new(_G.tonumber(k1[0]),_G.tonumber(k1[1]) - 1,_G.tonumber(k1[2]),0,0,0) end;
  elseif (_g1) == 19 then 
    local k2 = s:split(" ");
    local y = k2[0]:split("-");
    local t1 = k2[1]:split(":");
    local tmp = _G.tonumber(y[1]) - 1;
    local tmp1 = _G.tonumber(y[2]);
    local tmp2 = _G.tonumber(t1[0]);
    local tmp3 = _G.tonumber(t1[1]);
    local tmp4 = _G.tonumber(t1[2]);
    do return Date.new(y[0],tmp,tmp1,tmp2,tmp3,tmp4) end;else
  _G.error("Invalid date format : " .. s,0); end;
end
lua.Boot.extendsOrImplements = function(cl1,cl2) 
  if ((cl1 == nil) or (cl2 == nil)) then 
    do return false end;
  else
    if (cl1 == cl2) then 
      do return true end;
    else
      if (cl1.__interfaces__ ~= nil) then 
        local intf = cl1.__interfaces__;
        local _g1 = 1;
        local _g = _hx_table.maxn(intf) + 1;
        while (_g1 < _g) do 
          _g1 = _g1 + 1;
          local i = _g1 - 1;
          if (lua.Boot.extendsOrImplements(intf[i],cl2)) then 
            do return true end;
          end;
          end;
      end;
    end;
  end;
  do return lua.Boot.extendsOrImplements(cl1.__super__,cl2) end;
end
lua.Boot.fieldIterator = function(o) 
  local tbl = (function() 
    local _hx_1
    if (o.__fields__ ~= nil) then 
    _hx_1 = o.__fields__; else 
    _hx_1 = o; end
    return _hx_1
  end )();
  local cur = _G.pairs(tbl);
  local next_valid = function(tbl1,val) 
    while (lua.Boot.hiddenFields[val] ~= nil) do 
      val = cur(tbl1,val);
      end;
    do return val end;
  end;
  local cur_val = next_valid(tbl,cur(tbl,nil));
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local ret = cur_val;
    cur_val = next_valid(tbl,cur(tbl,cur_val));
    do return ret end;
  end,hasNext=function(self) 
    do return cur_val ~= nil end;
  end}) end;
end

lua.Thread.new = {}
lua.Thread.__name__ = {"lua","Thread"}

lua.PairTools.new = {}
lua.PairTools.__name__ = {"lua","PairTools"}
lua.PairTools.ipairsEach = function(table,func) 
  for i,v in _G.ipairs(table) do func(i,v) end;
end

math.Bounds.new = function(center,size) 
  local self = _hx_new(math.Bounds.prototype)
  math.Bounds.super(self,center,size)
  return self
end
math.Bounds.super = function(self,center,size) 
  self.center = center;
  self.size = size;
  self.min = math._Vec3.Vec3_Impl_.sub(center,math._Vec3.Vec3_Impl_.fdiv(size,2));
  self.max = math._Vec3.Vec3_Impl_.add(center,math._Vec3.Vec3_Impl_.fdiv(size,2));
end
math.Bounds.__name__ = {"math","Bounds"}
math.Bounds.from_extents = function(min,max) 
  local size = math._Vec3.Vec3_Impl_.sub(max,min);
  local center = math._Vec3.Vec3_Impl_.add(min,math._Vec3.Vec3_Impl_.fdiv(size,2));
  do return math.Bounds.new(center,size) end;
end
math.Bounds.prototype = _hx_a(
  
  '__class__',  math.Bounds
)

math.Capsule.new = function(a,b,radius) 
  local self = _hx_new(math.Capsule.prototype)
  math.Capsule.super(self,a,b,radius)
  return self
end
math.Capsule.super = function(self,a,b,radius) 
  self.a = a;
  self.b = b;
  self.radius = radius;
end
math.Capsule.__name__ = {"math","Capsule"}
math.Capsule.prototype = _hx_a(
  
  '__class__',  math.Capsule
)

math.Intersect.new = {}
math.Intersect.__name__ = {"math","Intersect"}
math.Intersect.aabb_frustum = function(aabb,frustum) 
  local box = ({});
  box[1] = aabb.min;
  box[2] = aabb.max;
  local n = 6;
  local planes = ({});
  planes[1] = frustum.left;
  planes[2] = frustum.right;
  planes[3] = frustum.bottom;
  planes[4] = frustum.top;
  planes[5] = frustum.near;
  planes[6] = frustum.far;
  local _g1 = 1;
  local _g = n;
  while (_g1 < _g) do 
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    local p = planes[i + 1];
    local px;
    local py;
    local pz;
    if (p[0] > 0.0) then 
      px = 2;
    else
      px = 1;
    end;
    if (p[1] > 0.0) then 
      py = 2;
    else
      py = 1;
    end;
    if (p[2] > 0.0) then 
      pz = 2;
    else
      pz = 1;
    end;
    local dot = ((p[0] * box[px][1]) + (p[1] * box[py][2])) + (p[2] * box[pz][3]);
    if (dot < -p[3]) then 
      do return false end;
    end;
    end;
  do return true end;
end
math.Intersect.ray_aabb = function(ray,aabb) 
  local _self = ray.direction;
  local dir = math._Vec3.Vec3_Impl_._new(_self[1],_self[2],_self[3]);
  math._Vec3.Vec3_Impl_.normalize(dir);
  local dirfrac = math._Vec3.Vec3_Impl_._new(1 / dir[1],1 / dir[2],1 / dir[3]);
  local t1 = (aabb.min[1] - ray.position[1]) * dirfrac[1];
  local t2 = (aabb.max[1] - ray.position[1]) * dirfrac[1];
  local t3 = (aabb.min[2] - ray.position[2]) * dirfrac[2];
  local t4 = (aabb.max[2] - ray.position[2]) * dirfrac[2];
  local t5 = (aabb.min[3] - ray.position[3]) * dirfrac[3];
  local t6 = (aabb.max[3] - ray.position[3]) * dirfrac[3];
  local tmin = _G.math.max(_G.math.max(_G.math.min(t1,t2),_G.math.min(t3,t4)),_G.math.min(t5,t6));
  local tmax = _G.math.min(_G.math.min(_G.math.max(t1,t2),_G.math.max(t3,t4)),_G.math.max(t5,t6));
  if (tmax < 0) then 
    do return nil end;
  end;
  if (tmin > tmax) then 
    do return nil end;
  end;
  do return _hx_o({__fields__={point=true,distance=true},point=math._Vec3.Vec3_Impl_.add(ray.position,math._Vec3.Vec3_Impl_.scale(ray.direction,tmin)),distance=tmin}) end;
end
math.Intersect.ray_triangle = function(ray,triangle) 
  local e1 = math._Vec3.Vec3_Impl_.sub(triangle.v1,triangle.v0);
  local e2 = math._Vec3.Vec3_Impl_.sub(triangle.v2,triangle.v0);
  local h = math._Vec3.Vec3_Impl_.cross(ray.direction,e2);
  local a = ((h[1] * e1[1]) + (h[2] * e1[2])) + (h[3] * e1[3]);
  if (_G.math.abs(a) <= math.Intersect.EPSILON) then 
    do return nil end;
  end;
  local f = 1 / a;
  local s = math._Vec3.Vec3_Impl_.sub(ray.position,triangle.v0);
  local u = (((s[1] * h[1]) + (s[2] * h[2])) + (s[3] * h[3])) * f;
  if ((u < 0) or (u > 1)) then 
    do return nil end;
  end;
  local q = math._Vec3.Vec3_Impl_.cross(s,e1);
  local a1 = ray.direction;
  local v = (((a1[1] * q[1]) + (a1[2] * q[2])) + (a1[3] * q[3])) * f;
  if ((v < 0) or ((u + v) > 1)) then 
    do return nil end;
  end;
  local t = (((q[1] * e2[1]) + (q[2] * e2[2])) + (q[3] * e2[3])) * f;
  if (t >= math.Intersect.EPSILON) then 
    do return _hx_o({__fields__={point=true,distance=true},point=math._Vec3.Vec3_Impl_.add(ray.position,math._Vec3.Vec3_Impl_.scale(ray.direction,t)),distance=t}) end;
  end;
  do return nil end;
end
math.Intersect.capsule_capsule = function(c1,c2) 
  local ret = math.Intersect.closest_point_segment_segment(c1.a,c1.b,c2.a,c2.b);
  local radius = c1.radius + c2.radius;
  if (ret.dist2 <= (radius * radius)) then 
    do return _hx_o({__fields__={p1=true,p2=true},p1=ret.p1,p2=ret.p2}) end;
  end;
  do return nil end;
end
math.Intersect.closest_point_segment_segment = function(p1,p2,p3,p4) 
  local epsilon = 1.19209290e-07;
  local c1;
  local c2;
  local s;
  local t;
  local d1 = math._Vec3.Vec3_Impl_.sub(p2,p1);
  local d2 = math._Vec3.Vec3_Impl_.sub(p4,p3);
  local r = math._Vec3.Vec3_Impl_.sub(p1,p3);
  local a = ((d1[1] * d1[1]) + (d1[2] * d1[2])) + (d1[3] * d1[3]);
  local e = ((d2[1] * d2[1]) + (d2[2] * d2[2])) + (d2[3] * d2[3]);
  local f = ((d2[1] * r[1]) + (d2[2] * r[2])) + (d2[3] * r[3]);
  if ((a <= epsilon) and (e <= epsilon)) then 
    c1 = p1;
    c2 = p3;
    s = 0;
    t = 0;
    local a1 = math._Vec3.Vec3_Impl_.sub(c1,c2);
    local b = math._Vec3.Vec3_Impl_.sub(c1,c2);
    do return _hx_o({__fields__={p1=true,p2=true,dist2=true,s=true,t=true},p1=c1,p2=c2,dist2=((a1[1] * b[1]) + (a1[2] * b[2])) + (a1[3] * b[3]),s=s,t=t}) end;
  end;
  if (a <= epsilon) then 
    s = 0;
    t = math.Utils.clamp(f / e,0.0,1.0);
  else
    local c = ((d1[1] * r[1]) + (d1[2] * r[2])) + (d1[3] * r[3]);
    if (e <= epsilon) then 
      s = math.Utils.clamp(-c / a,0.0,1.0);
      t = 0;
    else
      local b1 = ((d1[1] * d2[1]) + (d1[2] * d2[2])) + (d1[3] * d2[3]);
      local denom = (a * e) - (b1 * b1);
      if (_G.math.abs(denom) > 0) then 
        s = math.Utils.clamp(((b1 * f) - (c * e)) / denom,0.0,1.0);
      else
        s = 0;
      end;
      t = ((b1 * s) + f) / e;
      if (t < 0) then 
        s = math.Utils.clamp(-c / a,0.0,1.0);
        t = 0;
      else
        if (t > 1) then 
          s = math.Utils.clamp((b1 - c) / a,0.0,1.0);
          t = 1;
        end;
      end;
    end;
  end;
  c1 = math._Vec3.Vec3_Impl_.add(p1,math._Vec3.Vec3_Impl_.scale(d1,s));
  c2 = math._Vec3.Vec3_Impl_.add(p3,math._Vec3.Vec3_Impl_.scale(d2,t));
  local a2 = math._Vec3.Vec3_Impl_.sub(c1,c2);
  local b2 = math._Vec3.Vec3_Impl_.sub(c1,c2);
  do return _hx_o({__fields__={p1=true,p2=true,dist2=true,s=true,t=true},p1=c1,p2=c2,dist2=((a2[1] * b2[1]) + (a2[2] * b2[2])) + (a2[3] * b2[3]),s=s,t=t}) end;
end

math._Mat4.Mat4_Impl_.new = {}
math._Mat4.Mat4_Impl_.__name__ = {"math","_Mat4","Mat4_Impl_"}
math._Mat4.Mat4_Impl_.identity = function(this1) 
  local _g = 0;
  while (_g < 15) do 
    _g = _g + 1;
    local i = _g - 1;
    this1[i] = 0;
    end;
  local _g1 = 0;
  while (_g1 < 3) do 
    _g1 = _g1 + 1;
    local i1 = _g1 - 1;
    this1[i1 + (i1 * 4)] = 1;
    end;
end
math._Mat4.Mat4_Impl_.scale = function(s) 
  local data = _hx_tab_array({[0]=s[1], 0, 0, 0, 0, s[2], 0, 0, 0, 0, s[3], 0, 0, 0, 0, 1 }, 16);
  local this1;
  if (data == nil) then 
    this1 = ({0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0});
    this1[0] = 1;
  else
    this1 = data;
  end;
  do return this1 end;
end
math._Mat4.Mat4_Impl_.translate = function(t) 
  local data = _hx_tab_array({[0]=1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, t[1], t[2], t[3], 1 }, 16);
  local this1;
  if (data == nil) then 
    this1 = ({0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0});
    this1[0] = 1;
  else
    this1 = data;
  end;
  do return this1 end;
end
math._Mat4.Mat4_Impl_.from_srt = function(translate,rotate,scale) 
  local _tx = translate[1];
  local _ty = translate[2];
  local _tz = translate[3];
  local _ax = rotate[1];
  local _ay = rotate[2];
  local _az = rotate[3];
  local _sx = scale[1];
  local _sy = scale[2];
  local _sz = scale[3];
  local sx = _G.math.sin(_ax);
  local sy = _G.math.sin(_ay);
  local sz = _G.math.sin(_az);
  local cx = _G.math.cos(_ax);
  local cy = _G.math.cos(_ay);
  local cz = _G.math.cos(_az);
  local sxsz = sx * sz;
  local cycz = cy * cz;
  local data = _hx_tab_array({[0]=_sx * (cycz - (sxsz * sy)), (_sx * -cx) * sz, _sx * ((cz * sy) + (cy * sxsz)), 0.0, _sy * (((cz * sx) * sy) + (cy * sz)), (_sy * cx) * cz, _sy * ((sy * sz) - (cycz * sx)), 0.0, (_sz * -cx) * sy, _sz * sx, (_sz * cx) * cy, 0.0, _tx, _ty, _tz, 1.0 }, 16);
  local this1;
  if (data == nil) then 
    this1 = ({0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0});
    this1[0] = 1;
  else
    this1 = data;
  end;
  do return this1 end;
end
math._Mat4.Mat4_Impl_.look_at = function(eye,at,up) 
  local forward = math._Vec3.Vec3_Impl_.sub(at,eye);
  math._Vec3.Vec3_Impl_.normalize(forward);
  local side = math._Vec3.Vec3_Impl_.cross(forward,up);
  math._Vec3.Vec3_Impl_.normalize(side);
  local new_up = math._Vec3.Vec3_Impl_.cross(side,forward);
  local data = _hx_tab_array({[0]=side[1], new_up[1], -forward[1], 0, side[2], new_up[2], -forward[2], 0, side[3], new_up[3], -forward[3], 0, -(((side[1] * eye[1]) + (side[2] * eye[2])) + (side[3] * eye[3])), -(((new_up[1] * eye[1]) + (new_up[2] * eye[2])) + (new_up[3] * eye[3])), ((forward[1] * eye[1]) + (forward[2] * eye[2])) + (forward[3] * eye[3]), 1 }, 16);
  local this1;
  if (data == nil) then 
    this1 = ({0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0});
    this1[0] = 1;
  else
    this1 = data;
  end;
  do return this1 end;
end
math._Mat4.Mat4_Impl_.invert = function(this1) 
  local this2;
  this2 = ({0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0});
  this2[0] = 1;
  local out = this2;
  local v = ((((((this1[5] * this1[10]) * this1[15]) - ((this1[5] * this1[11]) * this1[14])) - ((this1[9] * this1[6]) * this1[15])) + ((this1[9] * this1[7]) * this1[14])) + ((this1[13] * this1[6]) * this1[11])) - ((this1[13] * this1[7]) * this1[10]);
  out[0] = v;
  local v1 = ((((((-this1[1] * this1[10]) * this1[15]) + ((this1[1] * this1[11]) * this1[14])) + ((this1[9] * this1[2]) * this1[15])) - ((this1[9] * this1[3]) * this1[14])) - ((this1[13] * this1[2]) * this1[11])) + ((this1[13] * this1[3]) * this1[10]);
  out[1] = v1;
  local v2 = ((((((this1[1] * this1[6]) * this1[15]) - ((this1[1] * this1[7]) * this1[14])) - ((this1[5] * this1[2]) * this1[15])) + ((this1[5] * this1[3]) * this1[14])) + ((this1[13] * this1[2]) * this1[7])) - ((this1[13] * this1[3]) * this1[6]);
  out[2] = v2;
  local v3 = ((((((-this1[1] * this1[6]) * this1[11]) + ((this1[1] * this1[7]) * this1[10])) + ((this1[5] * this1[2]) * this1[11])) - ((this1[5] * this1[3]) * this1[10])) - ((this1[9] * this1[2]) * this1[7])) + ((this1[9] * this1[3]) * this1[6]);
  out[3] = v3;
  local v4 = ((((((-this1[4] * this1[10]) * this1[15]) + ((this1[4] * this1[11]) * this1[14])) + ((this1[8] * this1[6]) * this1[15])) - ((this1[8] * this1[7]) * this1[14])) - ((this1[12] * this1[6]) * this1[11])) + ((this1[12] * this1[7]) * this1[10]);
  out[4] = v4;
  local v5 = ((((((this1[0] * this1[10]) * this1[15]) - ((this1[0] * this1[11]) * this1[14])) - ((this1[8] * this1[2]) * this1[15])) + ((this1[8] * this1[3]) * this1[14])) + ((this1[12] * this1[2]) * this1[11])) - ((this1[12] * this1[3]) * this1[10]);
  out[5] = v5;
  local v6 = ((((((-this1[0] * this1[6]) * this1[15]) + ((this1[0] * this1[7]) * this1[14])) + ((this1[4] * this1[2]) * this1[15])) - ((this1[4] * this1[3]) * this1[14])) - ((this1[12] * this1[2]) * this1[7])) + ((this1[12] * this1[3]) * this1[6]);
  out[6] = v6;
  local v7 = ((((((this1[0] * this1[6]) * this1[11]) - ((this1[0] * this1[7]) * this1[10])) - ((this1[4] * this1[2]) * this1[11])) + ((this1[4] * this1[3]) * this1[10])) + ((this1[8] * this1[2]) * this1[7])) - ((this1[8] * this1[3]) * this1[6]);
  out[7] = v7;
  local v8 = ((((((this1[4] * this1[9]) * this1[15]) - ((this1[4] * this1[11]) * this1[13])) - ((this1[8] * this1[5]) * this1[15])) + ((this1[8] * this1[7]) * this1[13])) + ((this1[12] * this1[5]) * this1[11])) - ((this1[12] * this1[7]) * this1[9]);
  out[8] = v8;
  local v9 = ((((((-this1[0] * this1[9]) * this1[15]) + ((this1[0] * this1[11]) * this1[13])) + ((this1[8] * this1[1]) * this1[15])) - ((this1[8] * this1[3]) * this1[13])) - ((this1[12] * this1[1]) * this1[11])) + ((this1[12] * this1[3]) * this1[9]);
  out[9] = v9;
  local v10 = ((((((this1[0] * this1[5]) * this1[15]) - ((this1[0] * this1[7]) * this1[13])) - ((this1[4] * this1[1]) * this1[15])) + ((this1[4] * this1[3]) * this1[13])) + ((this1[12] * this1[1]) * this1[7])) - ((this1[12] * this1[3]) * this1[5]);
  out[10] = v10;
  local v11 = ((((((-this1[0] * this1[5]) * this1[11]) + ((this1[0] * this1[7]) * this1[9])) + ((this1[4] * this1[1]) * this1[11])) - ((this1[4] * this1[3]) * this1[9])) - ((this1[8] * this1[1]) * this1[7])) + ((this1[8] * this1[3]) * this1[5]);
  out[11] = v11;
  local v12 = ((((((-this1[4] * this1[9]) * this1[14]) + ((this1[4] * this1[10]) * this1[13])) + ((this1[8] * this1[5]) * this1[14])) - ((this1[8] * this1[6]) * this1[13])) - ((this1[12] * this1[5]) * this1[10])) + ((this1[12] * this1[6]) * this1[9]);
  out[12] = v12;
  local v13 = ((((((this1[0] * this1[9]) * this1[14]) - ((this1[0] * this1[10]) * this1[13])) - ((this1[8] * this1[1]) * this1[14])) + ((this1[8] * this1[2]) * this1[13])) + ((this1[12] * this1[1]) * this1[10])) - ((this1[12] * this1[2]) * this1[9]);
  out[13] = v13;
  local v14 = ((((((-this1[0] * this1[5]) * this1[14]) + ((this1[0] * this1[6]) * this1[13])) + ((this1[4] * this1[1]) * this1[14])) - ((this1[4] * this1[2]) * this1[13])) - ((this1[12] * this1[1]) * this1[6])) + ((this1[12] * this1[2]) * this1[5]);
  out[14] = v14;
  local v15 = ((((((this1[0] * this1[5]) * this1[10]) - ((this1[0] * this1[6]) * this1[9])) - ((this1[4] * this1[1]) * this1[10])) + ((this1[4] * this1[2]) * this1[9])) + ((this1[8] * this1[1]) * this1[6])) - ((this1[8] * this1[2]) * this1[5]);
  out[15] = v15;
  local det = (((this1[0] * out[0]) + (this1[1] * out[4])) + (this1[2] * out[8])) + (this1[3] * out[12]);
  if (det == 0) then 
    do return end;
  end;
  det = 1 / det;
  local _g = 0;
  while (_g < 15) do 
    _g = _g + 1;
    local i = _g - 1;
    this1[i] = out[i] * det;
    end;
end
math._Mat4.Mat4_Impl_.transpose = function(this1) 
  local _g = _hx_tab_array({ }, 0);
  local _g1 = 0;
  while (_g1 < 15) do 
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    _g:push(this1[i]);
    end;
  local tmp = _g;
  this1[1] = tmp[4];
  this1[2] = tmp[8];
  this1[3] = tmp[12];
  this1[4] = tmp[1];
  this1[6] = tmp[9];
  this1[7] = tmp[13];
  this1[8] = tmp[2];
  this1[9] = tmp[6];
  this1[11] = tmp[14];
  this1[12] = tmp[3];
  this1[13] = tmp[7];
  this1[14] = tmp[11];
end
math._Mat4.Mat4_Impl_.from_angle_axis = function(angle,axis) 
  local _self = axis;
  local l = ((_self[1] * _self[1]) + (_self[2] * _self[2])) + (_self[3] * _self[3]);
  if (l == 0) then 
    local this1;
    this1 = ({0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0});
    this1[0] = 1;
    do return this1 end;
  end;
  l = _G.math.sqrt(l);
  local x = axis[1] / l;
  local y = axis[2] / l;
  local z = axis[3] / l;
  local c = _G.math.cos(angle);
  local s = _G.math.sin(angle);
  local data = _hx_tab_array({[0]=((x * x) * (1 - c)) + c, ((y * x) * (1 - c)) + (z * s), ((x * z) * (1 - c)) - (y * s), 0, ((x * y) * (1 - c)) - (z * s), ((y * y) * (1 - c)) + c, ((y * z) * (1 - c)) + (x * s), 0, ((x * z) * (1 - c)) + (y * s), ((y * z) * (1 - c)) - (x * s), ((z * z) * (1 - c)) + c, 0, 0, 0, 0, 1 }, 16);
  local this2;
  if (data == nil) then 
    this2 = ({0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0});
    this2[0] = 1;
  else
    this2 = data;
  end;
  do return this2 end;
end
math._Mat4.Mat4_Impl_.from_ortho = function(left,right,top,bottom,near,far) 
  local data = _hx_tab_array({[0]=2 / (right - left), 0, 0, 0, 0, 2 / (top - bottom), 0, 0, 0, 0, -2 / (far - near), 0, -((right + left) / (right - left)), -((top + bottom) / (top - bottom)), -((far + near) / (far - near)), 1 }, 16);
  local this1;
  if (data == nil) then 
    this1 = ({0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0});
    this1[0] = 1;
  else
    this1 = data;
  end;
  do return this1 end;
end
math._Mat4.Mat4_Impl_.from_perspective = function(fovy,aspect,near,far) 
  local t = _G.math.tan(_G.math.rad(fovy) / 2);
  local data = _hx_tab_array({[0]=1 / (t * aspect), 0, 0, 0, 0, 1 / t, 0, 0, 0, 0, -(far + near) / (far - near), -1, 0, 0, -((2 * far) * near) / (far - near), 0 }, 16);
  local this1;
  if (data == nil) then 
    this1 = ({0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0});
    this1[0] = 1;
  else
    this1 = data;
  end;
  do return this1 end;
end
math._Mat4.Mat4_Impl_.set_clips = function(this1,near,far) 
  this1[10] = -(far + near) / (far - near);
  this1[14] = -((2 * far) * near) / (far - near);
end
math._Mat4.Mat4_Impl_.from_cpml = function(t) 
  local data = _hx_tab_array({[0]=t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8], t[9], t[10], t[11], t[12], t[13], t[14], t[15], t[16] }, 16);
  local this1;
  if (data == nil) then 
    this1 = ({0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0});
    this1[0] = 1;
  else
    this1 = data;
  end;
  do return this1 end;
end
math._Mat4.Mat4_Impl_.copy = function(this1) 
  local this2;
  this2 = ({0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0});
  this2[0] = 1;
  local out = this2;
  local _g = 0;
  while (_g < 15) do 
    _g = _g + 1;
    local i = _g - 1;
    local v = this1[i];
    out[i] = v;
    end;
  do return out end;
end
math._Mat4.Mat4_Impl_.to_vec4s = function(this1) 
  local a = this1;
  
			do return {
				{ a[0],  a[1],  a[2],  a[3]  },
				{ a[4],  a[5],  a[6],  a[7]  },
				{ a[8],  a[9],  a[10], a[11] },
				{ a[12], a[13], a[14], a[15] }
			} end
		;
  do return ({}) end;
end
math._Mat4.Mat4_Impl_.to_frustum = function(this1,infinite) 
  if (infinite == nil) then 
    infinite = false;
  end;
  local left = math._Vec4.Vec4_Impl_._new(this1[3] + this1[0],this1[7] + this1[4],this1[11] + this1[8],this1[15] + this1[12]);
  math._Vec4.Vec4_Impl_.normalize(left);
  local right = math._Vec4.Vec4_Impl_._new(this1[3] - this1[0],this1[7] - this1[4],this1[11] - this1[8],this1[15] - this1[12]);
  math._Vec4.Vec4_Impl_.normalize(right);
  local bottom = math._Vec4.Vec4_Impl_._new(this1[3] + this1[1],this1[7] + this1[5],this1[11] + this1[9],this1[15] + this1[13]);
  math._Vec4.Vec4_Impl_.normalize(bottom);
  local top = math._Vec4.Vec4_Impl_._new(this1[3] - this1[1],this1[7] - this1[5],this1[11] - this1[9],this1[15] - this1[13]);
  math._Vec4.Vec4_Impl_.normalize(top);
  local near = math._Vec4.Vec4_Impl_._new(this1[3] + this1[2],this1[7] + this1[6],this1[11] + this1[10],this1[15] + this1[14]);
  math._Vec4.Vec4_Impl_.normalize(near);
  local far = nil;
  if (not infinite) then 
    far = math._Vec4.Vec4_Impl_._new(this1[3] - this1[2],this1[7] - this1[6],this1[11] - this1[10],this1[15] - this1[14]);
    math._Vec4.Vec4_Impl_.normalize(far);
  end;
  local this2 = _hx_o({__fields__={left=true,right=true,bottom=true,top=true,near=true,far=true},left=left,right=right,bottom=bottom,top=top,near=near,far=far});
  do return this2 end;
end
math._Mat4.Mat4_Impl_.mul = function(this1,b) 
  local this2;
  this2 = ({0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0});
  this2[0] = 1;
  local out = this2;
  local a = this1;
  local v = (((a[0] * b[0]) + (a[1] * b[4])) + (a[2] * b[8])) + (a[3] * b[12]);
  out[0] = v;
  local v1 = (((a[0] * b[1]) + (a[1] * b[5])) + (a[2] * b[9])) + (a[3] * b[13]);
  out[1] = v1;
  local v2 = (((a[0] * b[2]) + (a[1] * b[6])) + (a[2] * b[10])) + (a[3] * b[14]);
  out[2] = v2;
  local v3 = (((a[0] * b[3]) + (a[1] * b[7])) + (a[2] * b[11])) + (a[3] * b[15]);
  out[3] = v3;
  local v4 = (((a[4] * b[0]) + (a[5] * b[4])) + (a[6] * b[8])) + (a[7] * b[12]);
  out[4] = v4;
  local v5 = (((a[4] * b[1]) + (a[5] * b[5])) + (a[6] * b[9])) + (a[7] * b[13]);
  out[5] = v5;
  local v6 = (((a[4] * b[2]) + (a[5] * b[6])) + (a[6] * b[10])) + (a[7] * b[14]);
  out[6] = v6;
  local v7 = (((a[4] * b[3]) + (a[5] * b[7])) + (a[6] * b[11])) + (a[7] * b[15]);
  out[7] = v7;
  local v8 = (((a[8] * b[0]) + (a[9] * b[4])) + (a[10] * b[8])) + (a[11] * b[12]);
  out[8] = v8;
  local v9 = (((a[8] * b[1]) + (a[9] * b[5])) + (a[10] * b[9])) + (a[11] * b[13]);
  out[9] = v9;
  local v10 = (((a[8] * b[2]) + (a[9] * b[6])) + (a[10] * b[10])) + (a[11] * b[14]);
  out[10] = v10;
  local v11 = (((a[8] * b[3]) + (a[9] * b[7])) + (a[10] * b[11])) + (a[11] * b[15]);
  out[11] = v11;
  local v12 = (((a[12] * b[0]) + (a[13] * b[4])) + (a[14] * b[8])) + (a[15] * b[12]);
  out[12] = v12;
  local v13 = (((a[12] * b[1]) + (a[13] * b[5])) + (a[14] * b[9])) + (a[15] * b[13]);
  out[13] = v13;
  local v14 = (((a[12] * b[2]) + (a[13] * b[6])) + (a[14] * b[10])) + (a[15] * b[14]);
  out[14] = v14;
  local v15 = (((a[12] * b[3]) + (a[13] * b[7])) + (a[14] * b[11])) + (a[15] * b[15]);
  out[15] = v15;
  do return out end;
end
math._Mat4.Mat4_Impl_.mul_vec3 = function(this1,b) 
  do return math._Vec3.Vec3_Impl_._new((((b[1] * this1[0]) + (b[2] * this1[4])) + (b[3] * this1[8])) + this1[12],(((b[1] * this1[1]) + (b[2] * this1[5])) + (b[3] * this1[9])) + this1[13],(((b[1] * this1[2]) + (b[2] * this1[6])) + (b[3] * this1[10])) + this1[14]) end;
end
math._Mat4.Mat4_Impl_.equal = function(this1,that) 
  local _g = 0;
  while (_g < 15) do 
    _g = _g + 1;
    local i = _g - 1;
    if (_G.math.abs(this1[i] - that[i]) > 1.0e-5) then 
      do return false end;
    end;
    end;
  do return true end;
end

math.Node.new = function(baseLength,minSize,looseness,center) 
  local self = _hx_new(math.Node.prototype)
  math.Node.super(self,baseLength,minSize,looseness,center)
  return self
end
math.Node.super = function(self,baseLength,minSize,looseness,center) 
  self.numObjectsAllowed = 8;
  self.children = _hx_tab_array({ }, 0);
  self.objects = _hx_tab_array({ }, 0);
  self.baseLength = baseLength;
  self.minSize = minSize;
  self.looseness = looseness;
  self.center = center;
  self.adjLength = self.looseness * self.baseLength;
  self.size = math._Vec3.Vec3_Impl_._new(self.adjLength,self.adjLength,self.adjLength);
  self.bounds = math.Bounds.new(self.center,self.size);
  local quarter = self.baseLength / 4;
  local childActualLength = (self.baseLength / 2) * self.looseness;
  local childActualSize = math._Vec3.Vec3_Impl_._new(childActualLength,childActualLength,childActualLength);
  self.childBounds = _hx_tab_array({[0]=math.Bounds.new(math._Vec3.Vec3_Impl_.add(self.center,math._Vec3.Vec3_Impl_._new(-quarter,quarter,-quarter)),childActualSize), math.Bounds.new(math._Vec3.Vec3_Impl_.add(self.center,math._Vec3.Vec3_Impl_._new(quarter,quarter,-quarter)),childActualSize), math.Bounds.new(math._Vec3.Vec3_Impl_.add(self.center,math._Vec3.Vec3_Impl_._new(-quarter,quarter,quarter)),childActualSize), math.Bounds.new(math._Vec3.Vec3_Impl_.add(self.center,math._Vec3.Vec3_Impl_._new(quarter,quarter,quarter)),childActualSize), math.Bounds.new(math._Vec3.Vec3_Impl_.add(self.center,math._Vec3.Vec3_Impl_._new(-quarter,-quarter,-quarter)),childActualSize), math.Bounds.new(math._Vec3.Vec3_Impl_.add(self.center,math._Vec3.Vec3_Impl_._new(quarter,-quarter,-quarter)),childActualSize), math.Bounds.new(math._Vec3.Vec3_Impl_.add(self.center,math._Vec3.Vec3_Impl_._new(-quarter,-quarter,quarter)),childActualSize), math.Bounds.new(math._Vec3.Vec3_Impl_.add(self.center,math._Vec3.Vec3_Impl_._new(quarter,-quarter,quarter)),childActualSize) }, 8);
end
math.Node.__name__ = {"math","Node"}
math.Node.prototype = _hx_a(
  'add', function(self,obj,objBounds) 
    local outer = self.bounds;
    if (not ((((((outer.min[1] <= objBounds.min[1]) and (outer.max[1] >= objBounds.max[1])) and (outer.min[2] <= objBounds.min[2])) and (outer.max[2] >= objBounds.max[2])) and (outer.min[3] <= objBounds.min[3])) and (outer.max[3] >= objBounds.max[3]))) then 
      do return false end;
    end;
    if ((self.objects.length < self.numObjectsAllowed) or ((self.baseLength / 2) < self.minSize)) then 
      self.objects:push(_hx_o({__fields__={data=true,bounds=true},data=obj,bounds=objBounds}));
    else
      local best_fit_child = -1;
      if (self.children.length == 0) then 
        self:split();
        if (self.children.length == 0) then 
          haxe.Log.trace("Child creation failed for an unknown reason. Early exit.",_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Octree.hx",lineNumber=111,className="math.Node",methodName="add"}));
          do return false end;
        end;
        local i = self.objects.length - 1;
        while (i >= 0) do 
          local object = self.objects[i];
          local objBounds1 = object.bounds;
          best_fit_child = ((function() 
            local _hx_1
            if (objBounds1.center[1] <= self.center[1]) then 
            _hx_1 = 0; else 
            _hx_1 = 1; end
            return _hx_1
          end )() + (function() 
            local _hx_2
            if (objBounds1.center[2] >= self.center[2]) then 
            _hx_2 = 0; else 
            _hx_2 = 4; end
            return _hx_2
          end )()) + (function() 
            local _hx_3
            if (objBounds1.center[3] <= self.center[3]) then 
            _hx_3 = 0; else 
            _hx_3 = 2; end
            return _hx_3
          end )();
          local outer1 = self.children[best_fit_child].bounds;
          local inner = object.bounds;
          if ((((((outer1.min[1] <= inner.min[1]) and (outer1.max[1] >= inner.max[1])) and (outer1.min[2] <= inner.min[2])) and (outer1.max[2] >= inner.max[2])) and (outer1.min[3] <= inner.min[3])) and (outer1.max[3] >= inner.max[3])) then 
            self.children[best_fit_child]:add(object.data,object.bounds);
            self.objects:splice(i,1);
          end;
          i = i - 1;
          end;
      end;
      best_fit_child = ((function() 
        local _hx_4
        if (objBounds.center[1] <= self.center[1]) then 
        _hx_4 = 0; else 
        _hx_4 = 1; end
        return _hx_4
      end )() + (function() 
        local _hx_5
        if (objBounds.center[2] >= self.center[2]) then 
        _hx_5 = 0; else 
        _hx_5 = 4; end
        return _hx_5
      end )()) + (function() 
        local _hx_6
        if (objBounds.center[3] <= self.center[3]) then 
        _hx_6 = 0; else 
        _hx_6 = 2; end
        return _hx_6
      end )();
      local outer2 = self.children[best_fit_child].bounds;
      if ((((((outer2.min[1] <= objBounds.min[1]) and (outer2.max[1] >= objBounds.max[1])) and (outer2.min[2] <= objBounds.min[2])) and (outer2.max[2] >= objBounds.max[2])) and (outer2.min[3] <= objBounds.min[3])) and (outer2.max[3] >= objBounds.max[3])) then 
        self.children[best_fit_child]:add(obj,objBounds);
      else
        self.objects:push(_hx_o({__fields__={data=true,bounds=true},data=obj,bounds=objBounds}));
      end;
    end;
    do return true end
  end,
  'get_colliding', function(self,checkBounds,results) 
    local a = self.bounds;
    if (not ((((((a.min[1] <= checkBounds.max[1]) and (a.max[1] >= checkBounds.min[1])) and (a.min[2] <= checkBounds.max[2])) and (a.max[2] >= checkBounds.min[2])) and (a.min[3] <= checkBounds.max[3])) and (a.max[3] >= checkBounds.min[3]))) then 
      do return end;
    end;
    local _g = 0;
    local _g1 = self.objects;
    while (_g < _g1.length) do 
      local object = _g1[_g];
      _g = _g + 1;
      local a1 = object.bounds;
      if ((((((a1.min[1] <= checkBounds.max[1]) and (a1.max[1] >= checkBounds.min[1])) and (a1.min[2] <= checkBounds.max[2])) and (a1.max[2] >= checkBounds.min[2])) and (a1.min[3] <= checkBounds.max[3])) and (a1.max[3] >= checkBounds.min[3])) then 
        results:push(object.data);
      end;
      end;
    local _g2 = 0;
    local _g11 = self.children;
    while (_g2 < _g11.length) do 
      local child = _g11[_g2];
      _g2 = _g2 + 1;
      child:get_colliding(checkBounds,results);
      end;
  end,
  'cast_ray', function(self,ray,func,depth) 
    if (math.Intersect.ray_aabb(ray,self.bounds) ~= nil) then 
      if (self.objects.length > 0) then 
        if (func(ray,self.objects)) then 
          do return true end;
        end;
      end;
      local _g = 0;
      local _g1 = self.children;
      while (_g < _g1.length) do 
        local child = _g1[_g];
        _g = _g + 1;
        if (child:cast_ray(ray,func,depth + 1)) then 
          do return true end;
        end;
        end;
    end;
    do return false end
  end,
  'set_children', function(self,childOctrees) 
    if (childOctrees.length ~= 8) then 
      haxe.Log.trace("Child octree array must be length 8. Was length: " .. Std.string(childOctrees.length),_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Octree.hx",lineNumber=290,className="math.Node",methodName="set_children"}));
      do return end;
    end;
    self.children = childOctrees;
  end,
  'split', function(self) 
    if (self.children.length > 0) then 
      do return end;
    end;
    local quarter = self.baseLength / 4;
    local newLength = self.baseLength / 2;
    self.children:push(math.Node.new(newLength,self.minSize,self.looseness,math._Vec3.Vec3_Impl_.add(self.center,math._Vec3.Vec3_Impl_._new(-quarter,quarter,-quarter))));
    self.children:push(math.Node.new(newLength,self.minSize,self.looseness,math._Vec3.Vec3_Impl_.add(self.center,math._Vec3.Vec3_Impl_._new(quarter,quarter,-quarter))));
    self.children:push(math.Node.new(newLength,self.minSize,self.looseness,math._Vec3.Vec3_Impl_.add(self.center,math._Vec3.Vec3_Impl_._new(-quarter,quarter,quarter))));
    self.children:push(math.Node.new(newLength,self.minSize,self.looseness,math._Vec3.Vec3_Impl_.add(self.center,math._Vec3.Vec3_Impl_._new(quarter,quarter,quarter))));
    self.children:push(math.Node.new(newLength,self.minSize,self.looseness,math._Vec3.Vec3_Impl_.add(self.center,math._Vec3.Vec3_Impl_._new(-quarter,-quarter,-quarter))));
    self.children:push(math.Node.new(newLength,self.minSize,self.looseness,math._Vec3.Vec3_Impl_.add(self.center,math._Vec3.Vec3_Impl_._new(quarter,-quarter,-quarter))));
    self.children:push(math.Node.new(newLength,self.minSize,self.looseness,math._Vec3.Vec3_Impl_.add(self.center,math._Vec3.Vec3_Impl_._new(-quarter,-quarter,quarter))));
    self.children:push(math.Node.new(newLength,self.minSize,self.looseness,math._Vec3.Vec3_Impl_.add(self.center,math._Vec3.Vec3_Impl_._new(quarter,-quarter,quarter))));
  end
  ,'__class__',  math.Node
)

math.Octree.new = function(initialWorldSize,initialWorldPos,minNodeSize,looseness) 
  local self = _hx_new(math.Octree.prototype)
  math.Octree.super(self,initialWorldSize,initialWorldPos,minNodeSize,looseness)
  return self
end
math.Octree.super = function(self,initialWorldSize,initialWorldPos,minNodeSize,looseness) 
  if (looseness == nil) then 
    looseness = 1.0;
  end;
  if (minNodeSize == nil) then 
    minNodeSize = 1.0;
  end;
  if (minNodeSize > initialWorldSize) then 
    haxe.Log.trace("Minimum node size must be at least as big as the initial world size. Was: " .. Std.string(minNodeSize) .. " Adjusted to: " .. Std.string(initialWorldSize),_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Octree.hx",lineNumber=475,className="math.Octree",methodName="new"}));
    minNodeSize = initialWorldSize;
  end;
  self.count = 0;
  self.initialSize = initialWorldSize;
  self.minSize = minNodeSize;
  self.looseness = math.Utils.clamp(looseness,1,2);
  local _self = initialWorldPos;
  self.rootNode = math.Node.new(self.initialSize,self.minSize,self.looseness,math._Vec3.Vec3_Impl_._new(_self[1],_self[2],_self[3]));
end
math.Octree.__name__ = {"math","Octree"}
math.Octree.prototype = _hx_a(
  'get_root_pos_index', function(self,xDir,yDir,zDir) 
    local result = (function() 
      local _hx_1
      if (xDir > 0) then 
      _hx_1 = 1; else 
      _hx_1 = 0; end
      return _hx_1
    end )();
    if (yDir < 0) then 
      do return result + 4 end;
    end;
    if (zDir > 0) then 
      do return result + 2 end;
    end;
    do return result end
  end,
  'add', function(self,obj,objBounds) 
    local count = 0;
    while (not self.rootNode:add(obj,objBounds)) do 
      count = count + 1;
      self:grow(math._Vec3.Vec3_Impl_.sub(objBounds.center,self.rootNode.center));
      if (count > 20) then 
        haxe.Log.trace("Aborted Add operation as it seemed to be going on forever (" .. Std.string(count - 1) .. ") attempts at growing the octree.",_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Octree.hx",lineNumber=511,className="math.Octree",methodName="add"}));
        do return end;
      end;
      local tmp = self;
      tmp.count = tmp.count + 1;
      end;
  end,
  'get_colliding', function(self,checkBounds) 
    local results = _hx_tab_array({ }, 0);
    self.rootNode:get_colliding(checkBounds,results);
    do return results end
  end,
  'cast_ray', function(self,ray,func) 
    do return self.rootNode:cast_ray(ray,func,1) end
  end,
  'grow', function(self,direction) 
    local xDirection = (function() 
      local _hx_1
      if (direction[1] >= 0) then 
      _hx_1 = 1; else 
      _hx_1 = -1; end
      return _hx_1
    end )();
    local yDirection = (function() 
      local _hx_2
      if (direction[2] >= 0) then 
      _hx_2 = 1; else 
      _hx_2 = -1; end
      return _hx_2
    end )();
    local zDirection = (function() 
      local _hx_3
      if (direction[3] >= 0) then 
      _hx_3 = 1; else 
      _hx_3 = -1; end
      return _hx_3
    end )();
    local oldRoot = self.rootNode;
    local half = self.rootNode.baseLength / 2;
    local newLength = self.rootNode.baseLength * 2;
    local newCenter = math._Vec3.Vec3_Impl_.add(self.rootNode.center,math._Vec3.Vec3_Impl_._new(xDirection * half,yDirection * half,zDirection * half));
    self.rootNode = math.Node.new(newLength,self.minSize,self.looseness,newCenter);
    local rootPos = self:get_root_pos_index(xDirection,yDirection,zDirection);
    local children = _hx_tab_array({ }, 0);
    local _g = 0;
    while (_g < 8) do 
      _g = _g + 1;
      local i = _g - 1;
      if (i == rootPos) then 
        children[i] = oldRoot;
      else
        if ((_G.math.fmod(i, 2)) == 0) then 
          xDirection = -1;
        else
          xDirection = 1;
        end;
        if (i > 3) then 
          yDirection = -1;
        else
          yDirection = 1;
        end;
        if ((i < 2) or ((i > 3) and (i < 6))) then 
          zDirection = -1;
        else
          zDirection = 1;
        end;
        children[i] = math.Node.new(self.rootNode.baseLength,self.minSize,self.looseness,math._Vec3.Vec3_Impl_.add(newCenter,math._Vec3.Vec3_Impl_._new(xDirection * half,yDirection * half,zDirection * half)));
      end;
      end;
    self.rootNode:set_children(children);
  end
  ,'__class__',  math.Octree
)

math.Plane.new = function(a,b) 
  local self = _hx_new(math.Plane.prototype)
  math.Plane.super(self,a,b)
  return self
end
math.Plane.super = function(self,a,b) 
  local _self = a;
  self.origin = math._Vec3.Vec3_Impl_._new(_self[1],_self[2],_self[3]);
  local self1 = b;
  self.normal = math._Vec3.Vec3_Impl_._new(self1[1],self1[2],self1[3]);
  self.equation = math._Vec4.Vec4_Impl_._new(b[1],b[2],b[3],-(((b[1] * a[1]) + (b[2] * a[2])) + (b[3] * a[3])));
end
math.Plane.__name__ = {"math","Plane"}
math.Plane.from_triangle = function(a,b,c) 
  local ba = math._Vec3.Vec3_Impl_.sub(b,a);
  local ca = math._Vec3.Vec3_Impl_.sub(c,a);
  local temp = math._Vec3.Vec3_Impl_.cross(ba,ca);
  math._Vec3.Vec3_Impl_.normalize(temp);
  local plane = math.Plane.new(a,temp);
  local v = temp[1];
  plane.equation[0] = v;
  local v1 = temp[2];
  plane.equation[1] = v1;
  local v2 = temp[3];
  plane.equation[2] = v2;
  local v3 = -(((temp[1] * a[1]) + (temp[2] * a[2])) + (temp[3] * a[3]));
  plane.equation[3] = v3;
  do return plane end;
end
math.Plane.prototype = _hx_a(
  'signed_distance', function(self,base_point) 
    local b = self.normal;
    do return (((base_point[1] * b[1]) + (base_point[2] * b[2])) + (base_point[3] * b[3])) + self.equation[3] end
  end,
  'is_front_facing', function(self,direction) 
    local a = self.normal;
    local f = ((a[1] * direction[1]) + (a[2] * direction[2])) + (a[3] * direction[3]);
    if (f <= 0.0) then 
      do return true end;
    end;
    do return false end
  end
  ,'__class__',  math.Plane
)

math._Quat.Quat_Impl_.new = {}
math._Quat.Quat_Impl_.__name__ = {"math","_Quat","Quat_Impl_"}
math._Quat.Quat_Impl_._new = function(x,y,z,w) 
  if (w == nil) then 
    w = 1;
  end;
  if (z == nil) then 
    z = 0;
  end;
  if (y == nil) then 
    y = 0;
  end;
  if (x == nil) then 
    x = 0;
  end;
  local this1;
  local this2 = ({length = 4});
  this1 = this2;
  this1[0] = x;
  this1[1] = y;
  this1[2] = z;
  this1[3] = w;
  do return this1 end;
end
math._Quat.Quat_Impl_.length = function(this1) 
  do return _G.math.sqrt((((this1[0] * this1[0]) + (this1[1] * this1[1])) + (this1[2] * this1[2])) + (this1[3] * this1[3])) end;
end
math._Quat.Quat_Impl_.normalize = function(this1) 
  local l = math._Quat.Quat_Impl_.length(this1);
  if (l == 0) then 
    this1[3] = 1;
    do return end;
  end;
  this1[0] = this1[0] / l;
  this1[1] = this1[1] / l;
  this1[2] = this1[2] / l;
  this1[3] = this1[3] / l;
end
math._Quat.Quat_Impl_.to_euler = function(this1) 
  local x = (1 - (2 * _G.math.pow(this1[1],2))) - (2 * _G.math.pow(this1[2],2));
  local tmp = _G.math.atan2(((2 * this1[1]) * this1[3]) - ((2 * this1[0]) * this1[2]),x);
  local tmp1 = _G.math.asin(((2 * this1[0]) * this1[1]) + ((2 * this1[2]) * this1[3]));
  local x1 = (1 - (2 * _G.math.pow(this1[0],2))) - (2 * _G.math.pow(this1[2],2));
  do return math._Vec3.Vec3_Impl_._new(tmp,tmp1,_G.math.atan2(((2 * this1[0]) * this1[3]) - ((2 * this1[1]) * this1[2]),x1)) end;
end
math._Quat.Quat_Impl_.from_direction = function(normal,up) 
  local u = (function() 
    local _hx_1
    if (up == nil) then 
    _hx_1 = math._Vec3.Vec3_Impl_._new(0,0,1); else 
    _hx_1 = up; end
    return _hx_1
  end )();
  local _self = normal;
  local n = math._Vec3.Vec3_Impl_._new(_self[1],_self[2],_self[3]);
  math._Vec3.Vec3_Impl_.normalize(n);
  local a = math._Vec3.Vec3_Impl_.cross(u,n);
  local d = ((u[1] * n[1]) + (u[2] * n[2])) + (u[3] * n[3]);
  do return math._Quat.Quat_Impl_._new(a[1],a[2],a[3],d + 1) end;
end
math._Quat.Quat_Impl_.from_euler = function(eul) 
  local heading = eul[1];
  local attitude = eul[2];
  local bank = eul[3];
  local c1 = _G.math.cos(heading * 0.5);
  local s1 = _G.math.sin(heading * 0.5);
  local c2 = _G.math.cos(attitude * 0.5);
  local s2 = _G.math.sin(attitude * 0.5);
  local c3 = _G.math.cos(bank * 0.5);
  local s3 = _G.math.sin(bank * 0.5);
  local c1c2 = c1 * c2;
  local s1s2 = s1 * s2;
  do return math._Quat.Quat_Impl_._new((c1c2 * s3) + (s1s2 * c3),((s1 * c2) * c3) + ((c1 * s2) * s3),((c1 * s2) * c3) - ((s1 * c2) * s3),(c1c2 * c3) - (s1s2 * s3)) end;
end
math._Quat.Quat_Impl_.to_angle_axis = function(this1) 
  local a = math._Quat.Quat_Impl_._new(this1[0],this1[1],this1[2],this1[3]);
  if ((a[3] > 1) or (a[3] < -1)) then 
    math._Quat.Quat_Impl_.normalize(a);
  end;
  local x = 0;
  local y = 0;
  local z = 0;
  local angle = 2 * _G.math.acos(a[3]);
  local s = _G.math.sqrt(1 - (a[3] * a[3]));
  if (s < 0.995) then 
    x = a[0];
    y = a[1];
    z = a[2];
  else
    x = a[0] / s;
    y = a[1] / s;
    z = a[2] / s;
  end;
  do return _hx_o({__fields__={angle=true,axis=true},angle=angle,axis=math._Vec3.Vec3_Impl_._new(x,y,z)}) end;
end
math._Quat.Quat_Impl_.from_angle_axis = function(angle,axis) 
  local s = _G.math.sin(angle * 0.5);
  local c = _G.math.cos(angle * 0.5);
  do return math._Quat.Quat_Impl_._new(axis[1] * s,axis[2] * s,axis[3] * s,c) end;
end
math._Quat.Quat_Impl_.add = function(this1,other) 
  do return math._Quat.Quat_Impl_._new(this1[0] + other[0],this1[1] + other[1],this1[2] + other[2],this1[3] + other[3]) end;
end
math._Quat.Quat_Impl_.sub = function(this1,other) 
  do return math._Quat.Quat_Impl_._new(this1[0] - other[0],this1[1] - other[1],this1[2] - other[2],this1[3] - other[3]) end;
end
math._Quat.Quat_Impl_.neg = function(this1) 
  do return math._Quat.Quat_Impl_._new(-this1[0],-this1[1],-this1[2],-this1[3]) end;
end
math._Quat.Quat_Impl_.mul = function(this1,other) 
  do return math._Quat.Quat_Impl_._new((((this1[0] * other[3]) + (this1[3] * other[0])) + (this1[1] * other[2])) - (this1[2] * other[1]),(((this1[1] * other[3]) + (this1[3] * other[1])) + (this1[2] * other[0])) - (this1[0] * other[2]),(((this1[2] * other[3]) + (this1[3] * other[2])) + (this1[0] * other[1])) - (this1[1] * other[0]),(((this1[3] * other[3]) - (this1[0] * other[0])) - (this1[1] * other[1])) - (this1[2] * other[2])) end;
end
math._Quat.Quat_Impl_.mul_vec3 = function(this1,other) 
  local qv = math._Vec3.Vec3_Impl_._new(this1[0],this1[1],this1[2]);
  local uv = math._Vec3.Vec3_Impl_.cross(qv,other);
  local uuv = math._Vec3.Vec3_Impl_.cross(qv,uv);
  do return math._Vec3.Vec3_Impl_.add(other,math._Vec3.Vec3_Impl_.scale(math._Vec3.Vec3_Impl_.add(math._Vec3.Vec3_Impl_.scale(uv,this1[3]),uuv),2)) end;
end
math._Quat.Quat_Impl_.scale = function(this1,s) 
  do return math._Quat.Quat_Impl_._new(this1[0] * s,this1[1] * s,this1[2] * s,this1[3] * s) end;
end
math._Quat.Quat_Impl_.lerp = function(a,b,t) 
  local result = math._Quat.Quat_Impl_.add(a,math._Quat.Quat_Impl_.scale(math._Quat.Quat_Impl_.sub(b,a),t));
  math._Quat.Quat_Impl_.normalize(result);
  do return result end;
end
math._Quat.Quat_Impl_.slerp = function(a,b,t) 
  local d = (((a[0] * b[0]) + (a[1] * b[1])) + (a[2] * b[2])) + (a[3] * b[3]);
  if (d < 0) then 
    a = math._Quat.Quat_Impl_.neg(a);
    d = -d;
  end;
  if (d > 0.995) then 
    do return math._Quat.Quat_Impl_.lerp(a,b,t) end;
  end;
  d = _G.math.min(_G.math.max(d,-1),1);
  local c = math._Quat.Quat_Impl_.sub(b,math._Quat.Quat_Impl_.scale(a,d));
  math._Quat.Quat_Impl_.normalize(c);
  local theta = _G.math.acos(d) * t;
  do return math._Quat.Quat_Impl_.add(math._Quat.Quat_Impl_.scale(a,_G.math.cos(theta)),math._Quat.Quat_Impl_.scale(c,_G.math.sin(theta))) end;
end

math.Ray.new = function(p,d) 
  local self = _hx_new(math.Ray.prototype)
  math.Ray.super(self,p,d)
  return self
end
math.Ray.super = function(self,p,d) 
  self.position = p;
  self.direction = d;
end
math.Ray.__name__ = {"math","Ray"}
math.Ray.prototype = _hx_a(
  
  '__class__',  math.Ray
)

math.Triangle.new = function(a,b,c,n) 
  local self = _hx_new(math.Triangle.prototype)
  math.Triangle.super(self,a,b,c,n)
  return self
end
math.Triangle.super = function(self,a,b,c,n) 
  self.v0 = a;
  self.v1 = b;
  self.v2 = c;
  self.vn = n;
end
math.Triangle.__name__ = {"math","Triangle"}
math.Triangle.prototype = _hx_a(
  'normal', function(self) 
    local ba = math._Vec3.Vec3_Impl_.sub(self.v1,self.v0);
    local ca = math._Vec3.Vec3_Impl_.sub(self.v2,self.v0);
    local n = math._Vec3.Vec3_Impl_.cross(ba,ca);
    math._Vec3.Vec3_Impl_.normalize(n);
    do return n end
  end
  ,'__class__',  math.Triangle
)

math.Utils.new = {}
math.Utils.__name__ = {"math","Utils"}
math.Utils.round = function(value,precision) 
  if (precision ~= nil) then 
    do return math.Utils.round(value / precision) * precision end;
  end;
  if (value >= 0) then 
    do return _G.math.floor(value + 0.5) end;
  else
    do return _G.math.ceil(value - 0.5) end;
  end;
end
math.Utils.wrap = function(v,limit) 
  if (v < 0) then 
    v = v + (math.Utils.round((-v / limit) + 1) * limit);
  end;
  do return _G.math.fmod(v, limit) end;
end
math.Utils.clamp = function(v,low,high) 
  do return _G.math.max(_G.math.min(v,high),low) end;
end
math.Utils.rotate_bounds = function(mtx,min,max) 
  local verts = _hx_tab_array({[0]=math._Mat4.Mat4_Impl_.mul_vec3(mtx,math._Vec3.Vec3_Impl_._new(min[1],min[2],max[3])), math._Mat4.Mat4_Impl_.mul_vec3(mtx,math._Vec3.Vec3_Impl_._new(max[1],min[2],max[3])), math._Mat4.Mat4_Impl_.mul_vec3(mtx,math._Vec3.Vec3_Impl_._new(min[1],max[2],max[3])), math._Mat4.Mat4_Impl_.mul_vec3(mtx,math._Vec3.Vec3_Impl_._new(max[1],min[2],min[3])), math._Mat4.Mat4_Impl_.mul_vec3(mtx,math._Vec3.Vec3_Impl_._new(max[1],max[2],min[3])), math._Mat4.Mat4_Impl_.mul_vec3(mtx,math._Vec3.Vec3_Impl_._new(min[1],max[2],min[3])) }, 6);
  local new_min = math._Mat4.Mat4_Impl_.mul_vec3(mtx,min);
  local new_max = math._Mat4.Mat4_Impl_.mul_vec3(mtx,max);
  local _g = 0;
  while (_g < verts.length) do 
    local v = verts[_g];
    _g = _g + 1;
    new_min = math._Vec3.Vec3_Impl_.min(new_min,v);
    new_max = math._Vec3.Vec3_Impl_.max(new_max,v);
    end;
  do return _hx_o({__fields__={min=true,max=true},min=new_min,max=new_max}) end;
end

math._Vec2.Vec2_Impl_.new = {}
math._Vec2.Vec2_Impl_.__name__ = {"math","_Vec2","Vec2_Impl_"}
math._Vec2.Vec2_Impl_.scale = function(this1,b) 
  local this2;
  local this3 = ({length = 2});
  this2 = this3;
  this2[0] = this1[0] * b;
  this2[1] = this1[1] * b;
  do return this2 end;
end
math._Vec2.Vec2_Impl_.length = function(this1) 
  do return _G.math.sqrt((this1[0] * this1[0]) + (this1[1] * this1[1])) end;
end
math._Vec2.Vec2_Impl_.normalize = function(this1) 
  local l = (this1[0] * this1[0]) + (this1[1] * this1[1]);
  if (l == 0) then 
    do return end;
  end;
  l = _G.math.sqrt(l);
  local _g = this1;
  _g[0] = _g[0] / l;
  local _g1 = this1;
  _g1[1] = _g1[1] / l;
end
math._Vec2.Vec2_Impl_.angle_to = function(this1,other) 
  if (other ~= nil) then 
    do return _G.math.atan2(this1[1] - other[1],this1[0] - other[0]) end;
  end;
  do return _G.math.atan2(this1[1],this1[0]) end;
end

math._Vec4.Vec4_Impl_.new = {}
math._Vec4.Vec4_Impl_.__name__ = {"math","_Vec4","Vec4_Impl_"}
math._Vec4.Vec4_Impl_._new = function(a,b,c,d) 
  if (d == nil) then 
    d = 0;
  end;
  if (c == nil) then 
    c = 0;
  end;
  if (b == nil) then 
    b = 0;
  end;
  if (a == nil) then 
    a = 0;
  end;
  local this1;
  local this2 = ({length = 4});
  this1 = this2;
  this1[0] = a;
  this1[1] = b;
  this1[2] = c;
  this1[3] = d;
  do return this1 end;
end
math._Vec4.Vec4_Impl_.normalize = function(this1) 
  local l = (((this1[0] * this1[0]) + (this1[1] * this1[1])) + (this1[2] * this1[2])) + (this1[3] * this1[3]);
  if (l == 0) then 
    do return end;
  end;
  l = _G.math.sqrt(l);
  local _g = 0;
  while (_g < 4) do 
    _g = _g + 1;
    local i = _g - 1;
    local _g1 = i;
    local _g2 = this1;
    _g2[_g1] = _g2[_g1] / l;
    end;
end

render.Grass.new = {}
render.Grass.__name__ = {"render","Grass"}
render.Grass.scatter = function(instances,camera,models,tile_offset,seed,count,min,max,density,scale_range) 
  local buffer = (max - min) / 3;
  local proj = math._Mat4.Mat4_Impl_.copy(camera.projection);
  math._Mat4.Mat4_Impl_.set_clips(proj,0.1,(max + buffer) / 10);
  local frustum = math._Mat4.Mat4_Impl_.to_frustum(math._Mat4.Mat4_Impl_.mul(camera.view,proj));
  Profiler.push_block("grass tri query",nil,_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Grass.hx",lineNumber=34,className="render.Grass",methodName="scatter"}));
  local range = math._Vec3.Vec3_Impl_._new(scale_range,scale_range,scale_range);
  local tris = World.get_triangles(math._Vec3.Vec3_Impl_.sub(camera.position,range),math._Vec3.Vec3_Impl_.add(camera.position,range));
  Profiler.pop_block(_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Grass.hx",lineNumber=38,className="render.Grass",methodName="scatter"}));
  Profiler.push_block("grass scatter",nil,_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Grass.hx",lineNumber=40,className="render.Grass",methodName="scatter"}));
  local p = math._Vec3.Vec3_Impl_._new(0,0,0);
  local wu = math._Vec3.Vec3_Impl_._new(0,0,1);
  local _g = 0;
  local _hx_break_0 = false;
  while (_g < tris.length) do 
    repeat 
    local tri = tris[_g];
    _g = _g + 1;
    local p0 = tri.v0;
    local p1 = tri.v1;
    local p2 = tri.v2;
    local n = tri.vn;
    local up = ((n[1] * wu[1]) + (n[2] * wu[2])) + (n[3] * wu[3]);
    if (up < 0.5) then 
      break;
    end;
    local blade_limit = 250;
    local blade_scale = 1.0;
    local ab = math._Vec3.Vec3_Impl_.sub(p0,p1);
    local ac = math._Vec3.Vec3_Impl_.sub(p0,p2);
    local pg = math._Vec3.Vec3_Impl_.cross(ab,ac);
    local samples = Std.int(((math._Vec3.Vec3_Impl_.length(pg) / 2.0) * density) * blade_scale);
    samples = Std.int(_G.math.min(samples,blade_limit));
    if (render.Grass.scale_samples) then 
      local falloff = 0.5;
      local b = camera.position;
      local dx = p0[1] - b[1];
      local dy = p0[2] - b[2];
      local dz = p0[3] - b[3];
      local td = _G.math.sqrt(((dx * dx) + (dy * dy)) + (dz * dz));
      local b1 = camera.position;
      local dx1 = p1[1] - b1[1];
      local dy1 = p1[2] - b1[2];
      local dz1 = p1[3] - b1[3];
      td = _G.math.min(td,_G.math.sqrt(((dx1 * dx1) + (dy1 * dy1)) + (dz1 * dz1)));
      local b2 = camera.position;
      local dx2 = p2[1] - b2[1];
      local dy2 = p2[2] - b2[2];
      local dz2 = p2[3] - b2[3];
      td = _G.math.min(td,_G.math.sqrt(((dx2 * dx2) + (dy2 * dy2)) + (dz2 * dz2)));
      td = _G.math.min(1.0 - (td / scale_range),1);
      td = _G.math.pow(td,falloff);
      samples = Std.int(samples * td);
    end;
    local rng = love.math.newRandomGenerator(seed);
    local _g2 = 0;
    local _g1 = samples;
    local _hx_break_1 = false;
    while (_g2 < _g1) do 
      repeat 
      _g2 = _g2 + 1;
      local i = _g2 - 1;
      local u = rng:random();
      local v = (1.0 - u) * rng:random();
      local w = (1 - u) - v;
      local v1 = ((u * p0[1]) + (v * p1[1])) + (w * p2[1]);
      p[1] = v1;
      local v2 = ((u * p0[2]) + (v * p1[2])) + (w * p2[2]);
      p[2] = v2;
      local v3 = ((u * p0[3]) + (v * p1[3])) + (w * p2[3]);
      p[3] = v3;
      local b3 = camera.position;
      local dx3 = p[1] - b3[1];
      local dy3 = p[2] - b3[2];
      local dz3 = p[3] - b3[3];
      local d = _G.math.sqrt(((dx3 * dx3) + (dy3 * dy3)) + (dz3 * dz3));
      if ((d >= (max + buffer)) or (d < min)) then 
        break;
      end;
      local sc = _G.math.sqrt(1 - (d / (scale_range / 2)));
      sc = sc * ((up - 0.5) * 2);
      if (d > max) then 
        sc = sc * (1.0 - ((d - max) / buffer));
      end;
      if (sc < 0.1) then 
        break;
      end;
      local model = models[_G.math.fmod(i, models.length)];
      if (instances.length <= count) then 
        local t = ({});
        t[1] = p[1];
        t[2] = p[2];
        t[3] = p[3];
        t[4] = sc;
        t[5] = model;
        instances:push(t);
      else
        instances[count][1] = p[1];
        instances[count][2] = p[2];
        instances[count][3] = p[3];
        instances[count][4] = sc;
        instances[count][5] = model;
      end;
      count = count + 1;
      
    until true
    if _hx_break_2 then _hx_break_2 = false; break; end
    end;
    
  until true
  if _hx_break_1 then _hx_break_1 = false; break; end
  end;
  Profiler.pop_block(_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Grass.hx",lineNumber=121,className="render.Grass",methodName="scatter"}));
  do return count end;
end

systems.Animation.new = function(_fixed_tick) 
  local self = _hx_new(systems.Animation.prototype)
  systems.Animation.super(self,_fixed_tick)
  return self
end
systems.Animation.super = function(self,_fixed_tick) 
  System.super(self,_fixed_tick);
end
systems.Animation.__name__ = {"systems","Animation"}
systems.Animation.prototype = _hx_a(
  'filter', function(self,e) 
    do return e.animation ~= nil end
  end,
  'process', function(self,e,dt) 
    local anim = e.animation;
    if (anim.timeline ~= nil) then 
      anim.timeline:update(dt);
      local _g_t;
      local _g_max;
      local _g_i = 1;
      _g_t = anim.timeline.timeline;
      _g_max = _hx_table.maxn(_g_t);
      while (_g_i <= _g_max) do 
        _g_i = _g_i + 1;
        local track = _g_t[_g_i - 1];
        local anim1 = anim.timeline.animations[track.name];
        if (track.frame ~= track.marker) then 
          track.marker = track.frame;
          local marker = anim1.markers[track.frame];
          if (marker ~= nil) then 
            haxe.Log.trace("event",_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true,customParams=true},fileName="Animation.hx",lineNumber=24,className="systems.Animation",methodName="process",customParams=_hx_tab_array({[0]=marker }, 1)}));
          end;
        end;
        end;
    end;
  end
  ,'__class__',  systems.Animation
)
systems.Animation.__super__ = System
setmetatable(systems.Animation.prototype,{__index=System.prototype})

systems.Audio.new = function(_fixed_tick) 
  local self = _hx_new(systems.Audio.prototype)
  systems.Audio.super(self,_fixed_tick)
  return self
end
systems.Audio.super = function(self,_fixed_tick) 
  System.super(self,_fixed_tick);
end
systems.Audio.__name__ = {"systems","Audio"}
systems.Audio.prototype = _hx_a(
  'filter', function(self,entity) 
    if (entity.player ~= nil) then 
      self.player = entity;
    end;
    do return entity.sound ~= nil end
  end,
  'update', function(self,entities,dt) 
    if (self.player == nil) then 
      love.audio.setPosition(0,0,0);
      love.audio.setVelocity(0,0,0);
      love.audio.setDistanceModel("none");
      do return end;
    end;
    local vel = self.player.transform.velocity;
    local _this = self.player.transform;
    local pos = World.to_world(_this.position,_this.tile_x,_this.tile_y);
    love.audio.setDistanceModel("inverse");
    love.audio.setPosition(pos[1],pos[2],pos[3]);
    love.audio.setVelocity(vel[1],vel[2],vel[3]);
    local _g = 0;
    while (_g < entities.length) do 
      local e = entities[_g];
      _g = _g + 1;
      local tx = e.transform;
      local loaded = e.sound.loaded;
      local epos = World.to_world(tx.position,tx.tile_x,tx.tile_y);
      local evel = tx.velocity;
      local source = loaded:iterator();
      while (source:hasNext()) do 
        local source1 = source:next();
        source1:setPosition(epos[1],epos[2],epos[3]);
        source1:setVelocity(evel[1],evel[2],evel[3]);
        end;
      end;
  end
  ,'__class__',  systems.Audio
)
systems.Audio.__super__ = System
setmetatable(systems.Audio.prototype,{__index=System.prototype})

systems.Hud.new = function(_fixed_tick) 
  local self = _hx_new(systems.Hud.prototype)
  systems.Hud.super(self,_fixed_tick)
  return self
end
systems.Hud.super = function(self,_fixed_tick) 
  System.super(self,_fixed_tick);
end
systems.Hud.__name__ = {"systems","Hud"}
systems.Hud.draw = function() 
  love.graphics.setBlendMode("alpha","alphamultiply");
  love.graphics.setColor(255.0,255.0,255.0,255.0);
  local _g = 0;
  local _g1 = systems.Hud.layers;
  while (_g < _g1.length) do 
    local layer = _g1[_g];
    _g = _g + 1;
    local _g2 = 0;
    while (_g2 < layer.length) do 
      local actor = layer[_g2];
      _g2 = _g2 + 1;
      local state = actor.actual;
      end;
    end;
  if (systems.Hud.subtitle_active) then 
    imgui.Widget.Text(systems.Hud.subtitle_queue[0].text);
    imgui.Widget.Value("opacity",systems.Hud.subtitle_opacity);
    love.graphics.setColor(0.,0.,0.,systems.Hud.subtitle_opacity * 255.0);
    local sub = systems.Hud.subtitle_queue[0].text;
    love.graphics.print(sub,Std.int((ui.Anchor.get_left() + ui.Anchor.get_right()) / 2),ui.Anchor.get_bottom());
  end;
end
systems.Hud.prototype = _hx_a(
  'filter', function(self,entity) 
    do return false end
  end,
  'update', function(self,entities,dt) 
    local _g = 0;
    local _g1 = systems.Hud.layers;
    while (_g < _g1.length) do 
      local layer = _g1[_g];
      _g = _g + 1;
      local _g2 = 0;
      while (_g2 < layer.length) do 
        local actor = layer[_g2];
        _g2 = _g2 + 1;
        actor:update(dt);
        end;
      end;
    if (not systems.Hud.subtitle_active and (systems.Hud.subtitle_queue.length > 0)) then 
      TimerScript.add(function(wait) 
        local sub = systems.Hud.subtitle_queue[0];
        systems.Hud.subtitle_active = true;
        systems.Hud.subtitle_opacity = 1;
        wait(sub.duration);
        systems.Hud.subtitle_opacity = 0;
        systems.Hud.subtitle_queue:pop();
        systems.Hud.subtitle_active = false;
      end);
    end;
    TimerScript.update(dt);
  end
  ,'__class__',  systems.Hud
)
systems.Hud.__super__ = System
setmetatable(systems.Hud.prototype,{__index=System.prototype})

systems.Loader.new = function(_fixed_tick) 
  local self = _hx_new(systems.Loader.prototype)
  systems.Loader.super(self,_fixed_tick)
  return self
end
systems.Loader.super = function(self,_fixed_tick) 
  self.audio_sources = utils.CacheResource.new(systems.Loader.load_source);
  self.static_meshes = utils.CacheResource.new(systems.Loader.load_mesh);
  System.super(self,_fixed_tick);
end
systems.Loader.__name__ = {"systems","Loader"}
systems.Loader.convert = function(t) 
  local tris = _hx_tab_array({ }, 0);
  lua.PairTools.ipairsEach(t,function(i,v) 
    local v0 = math._Vec3.Vec3_Impl_._new(v[1].position[1],v[1].position[2],v[1].position[3]);
    local v1 = math._Vec3.Vec3_Impl_._new(v[2].position[1],v[2].position[2],v[2].position[3]);
    local v2 = math._Vec3.Vec3_Impl_._new(v[3].position[1],v[3].position[2],v[3].position[3]);
    local t1 = math.Triangle.new(v0,v1,v2,math._Vec3.Vec3_Impl_._new());
    t1.vn = t1:normal();
    tris:push(t1);
  end);
  do return tris end;
end
systems.Loader.load_mesh = function(filename,options) 
  Log.write(Level.System,"load mesh " .. filename);
  do return iqm.Iqm.load(filename,options.save_triangles,false) end;
end
systems.Loader.load_source = function(filename,ignore) 
  do return love.audio.newSource(filename) end;
end
systems.Loader.prototype = _hx_a(
  'filter', function(self,e) 
    if (e.drawable ~= nil) then 
      do return true end;
    end;
    do return false end
  end,
  'process', function(self,e,dt) 
    if (e.sound ~= nil) then 
      if (e.sound.loaded == nil) then 
        e.sound.loaded = haxe.ds.StringMap.new();
        local k = e.sound.sounds:keys();
        while (k:hasNext()) do 
          local k1 = k:next();
          local this1 = e.sound.loaded;
          local this2 = e.sound.sounds;
          local v = self.audio_sources:load(this2.v[k1],false);
          local _this = this1;
          _this.v[k1] = v;
          _this.k[k1] = true;
          end;
      end;
    end;
    if (e.drawable ~= nil) then 
      if (e.drawable.mesh == nil) then 
        local actor = e.drawable.collision == components.CollisionType.Triangle;
        e.drawable.mesh = self.static_meshes:load(e.drawable.filename,_hx_o({__fields__={save_triangles=true},save_triangles=actor}));
        if (actor) then 
          local tris = systems.Loader.convert(e.drawable.mesh.triangles);
          local this3;
          this3 = ({0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0});
          this3[0] = 1;
          local xform = this3;
          e.transform:update();
          if (e.transform ~= nil) then 
            xform = math._Mat4.Mat4_Impl_.mul(xform,math._Mat4.Mat4_Impl_.scale(e.transform.scale));
            local a = math._Quat.Quat_Impl_.to_angle_axis(e.transform.orientation);
            xform = math._Mat4.Mat4_Impl_.mul(xform,math._Mat4.Mat4_Impl_.from_angle_axis(a.angle,a.axis));
            xform = math._Mat4.Mat4_Impl_.mul(xform,math._Mat4.Mat4_Impl_.translate(e.transform.position));
          end;
          local tile = World.get_tile(e.transform.tile_x,e.transform.tile_y);
          World.add_triangles(tile,xform,tris);
        end;
      end;
    end;
    if (e.attachments ~= nil) then 
      local _g = 0;
      local _g1 = e.attachments;
      while (_g < _g1.length) do 
        local attach = _g1[_g];
        _g = _g + 1;
        if (attach.mesh == nil) then 
          Log.write(Level.System,"load mesh " .. attach.filename);
          attach.mesh = iqm.Iqm.load(attach.filename);
        end;
        end;
    end;
    if (e.animation ~= nil) then 
      if (e.animation.timeline == nil) then 
        local data = iqm.Iqm.load_anims(e.animation.filename);
        e.animation.timeline = anim9.Anim9.new(data);
        local tl = e.animation.timeline;
        if ((tl ~= nil) and (e.animation.anims.length > 0)) then 
          local _g2 = 0;
          local _g11 = e.animation.anims;
          while (_g2 < _g11.length) do 
            local f = _g11[_g2];
            _g2 = _g2 + 1;
            tl:add_animation(iqm.Iqm.load_anims(f));
            end;
        end;
        if (tl ~= nil) then 
          local run = tl:new_track("skate");
          tl:play(run);
        else
          for k, v in pairs(data.frames) do print(k, v) end;
        end;
      end;
    end;
  end
  ,'__class__',  systems.Loader
)
systems.Loader.__super__ = System
setmetatable(systems.Loader.prototype,{__index=System.prototype})

systems.Movement.new = function(_fixed_tick) 
  local self = _hx_new(systems.Movement.prototype)
  systems.Movement.super(self,_fixed_tick)
  return self
end
systems.Movement.super = function(self,_fixed_tick) 
  self.cached = haxe.ds.ObjectMap.new();
  System.super(self,_fixed_tick);
end
systems.Movement.__name__ = {"systems","Movement"}
systems.Movement.prototype = _hx_a(
  'filter', function(self,e) 
    if ((e.transform ~= nil) and not e.transform.is_static) then 
      do return true end;
    end;
    do return false end
  end,
  'remove', function(self,e) 
    self.cached:remove(e);
  end,
  'update_cache', function(self,e,last_tile) 
    local d = e.drawable;
    local mtx = e.transform.mtx;
    local add = false;
    if (self.cached.k[e] == nil) then 
      local this1 = self.cached;
      local v = math._Mat4.Mat4_Impl_.copy(mtx);
      local _this = this1;
      _this.h[e] = v;
      _this.k[e] = true;
      add = true;
    else
      if (math._Mat4.Mat4_Impl_.equal(self.cached.h[e],mtx)) then 
        do return end;
      else
        local this2 = self.cached;
        local v1 = math._Mat4.Mat4_Impl_.copy(mtx);
        local _this1 = this2;
        _this1.h[e] = v1;
        _this1.k[e] = true;
      end;
    end;
    local current_tile = World.get_tile(e.transform.tile_x,e.transform.tile_y);
    if ((last_tile ~= current_tile) or add) then 
      World.refresh_entity(last_tile,current_tile,e,add);
    end;
  end,
  'process', function(self,e,dt) 
    local _self = e.transform.velocity;
    if ((((_self[1] * _self[1]) + (_self[2] * _self[2])) + (_self[3] * _self[3])) > 0) then 
      local e1 = e.transform.position;
      local tmp = math._Vec3.Vec3_Impl_.scale(e.transform.velocity,dt);
      e.transform.position = math._Vec3.Vec3_Impl_.add(e1,tmp);
      if (e.player == nil) then 
        e.transform.velocity = math._Vec3.Vec3_Impl_.scale(e.transform.velocity,0);
      end;
    end;
    local old_tile = World.get_tile(e.transform.tile_x,e.transform.tile_y);
    e.transform:update();
    if (e.camera ~= nil) then 
      local _this = e.transform;
      local tmp1 = World.to_world(_this.position,_this.tile_x,_this.tile_y);
      e.camera.position = tmp1;
    end;
    local d = e.drawable;
    if ((d ~= nil) and (d.mesh ~= nil)) then 
      self:update_cache(e,old_tile);
    end;
  end
  ,'__class__',  systems.Movement
)
systems.Movement.__super__ = System
setmetatable(systems.Movement.prototype,{__index=System.prototype})

systems.RailsHelper.new = {}
systems.RailsHelper.__name__ = {"systems","RailsHelper"}
systems.RailsHelper.get_tile_rails = function(player) 
  local rails = _hx_tab_array({ }, 0);
  local _this = player.transform;
  local vtiles = World.get_adjacent_tiles(World.to_world(_this.position,_this.tile_x,_this.tile_y));
  local _g = 0;
  while (_g < vtiles.length) do 
    local vtile = vtiles[_g];
    _g = _g + 1;
    local _this1 = player.transform;
    local vtile1 = World.virtual_tile_at(World.to_world(_this1.position,_this1.tile_x,_this1.tile_y));
    local tile = vtile1.world_tile;
    local _g1 = 0;
    local _g2 = tile.entities;
    while (_g1 < _g2.length) do 
      local e = _g2[_g1];
      _g1 = _g1 + 1;
      if (e.rails ~= nil) then 
        local _g3 = 0;
        local _g4 = e.rails;
        while (_g3 < _g4.length) do 
          local rail = _g4[_g3];
          _g3 = _g3 + 1;
          local r = rail:copy();
          r.mtx = e.transform.mtx;
          r.capsule.a = r.capsule.a;
          r.capsule.b = r.capsule.b;
          rails:push(r);
          end;
      end;
      end;
    end;
  do return rails end;
end
systems.RailsHelper.closest_end_of_rail = function(position,rail) 
  local near = rail.capsule.a;
  local far = rail.capsule.b;
  local closest = rail.prev;
  local a = rail.capsule.a;
  local dx = a[1] - position[1];
  local dy = a[2] - position[2];
  local dz = a[3] - position[3];
  local tmp = _G.math.sqrt(((dx * dx) + (dy * dy)) + (dz * dz));
  local a1 = rail.capsule.b;
  local dx1 = a1[1] - position[1];
  local dy1 = a1[2] - position[2];
  local dz1 = a1[3] - position[3];
  if (tmp > _G.math.sqrt(((dx1 * dx1) + (dy1 * dy1)) + (dz1 * dz1))) then 
    do return _hx_o({__fields__={near=true,far=true,closest=true},near=far,far=near,closest=rail.next}) end;
  end;
  do return _hx_o({__fields__={near=true,far=true,closest=true},near=near,far=far,closest=closest}) end;
end
systems.RailsHelper.transfer_rail = function(player,rail) 
  local _this = player.transform;
  local data = systems.RailsHelper.closest_end_of_rail(World.to_world(_this.position,_this.tile_x,_this.tile_y),rail);
  if (data.closest ~= nil) then 
    local velocity = math._Vec3.Vec3_Impl_.sub(math._Vec3.Vec3_Impl_.fdiv(math._Vec3.Vec3_Impl_.add(data.closest.capsule.a,data.closest.capsule.b),2),data.near);
    math._Vec3.Vec3_Impl_.normalize(velocity);
    velocity = math._Vec3.Vec3_Impl_.scale(velocity,math._Vec3.Vec3_Impl_.length(player.transform.velocity));
    player.transform.position = World.to_local(data.near);
    player.transform.velocity = velocity;
    player.player.rail = data.closest;
    do return true end;
  end;
  do return false end;
end
systems.RailsHelper.scan_for_rail = function(player,rails) 
  local reject = player.player.rail;
  local _this = player.transform;
  local ppos = World.to_world(_this.position,_this.tile_x,_this.tile_y);
  local player_capsule = math.Capsule.new(ppos,ppos,player.player.rail_attach_radius);
  local _g = 0;
  local _hx_break_0 = false;
  while (_g < rails.length) do 
    repeat 
    local rail = rails[_g];
    _g = _g + 1;
    if (rail == reject) then 
      break;
    end;
    local result = math.Intersect.capsule_capsule(player_capsule,rail.capsule);
    if (result ~= nil) then 
      local _self = player.transform.velocity;
      local velocity = math._Vec3.Vec3_Impl_._new(_self[1],_self[2],_self[3]);
      math._Vec3.Vec3_Impl_.normalize(velocity);
      local to_rail = math._Vec3.Vec3_Impl_.sub(result.p2,ppos);
      math._Vec3.Vec3_Impl_.normalize(to_rail);
      local power = ((to_rail[1] * velocity[1]) + (to_rail[2] * velocity[2])) + (to_rail[3] * velocity[3]);
      if (power < 0) then 
        _hx_break_1 = true; break;
      end;
      local direction = math._Vec3.Vec3_Impl_.sub(rail.capsule.b,rail.capsule.a);
      local new_velocity = math._Vec3.Vec3_Impl_.project_on(player.transform.velocity,direction);
      local nvl = math._Vec3.Vec3_Impl_.length(new_velocity);
      if ((nvl < (math._Vec3.Vec3_Impl_.length(player.transform.velocity) / 5)) or (nvl < player.player.rail_stick_min)) then 
        _hx_break_1 = true; break;
      end;
      if (reject ~= nil) then 
        local rail_center = math._Vec3.Vec3_Impl_.fdiv(math._Vec3.Vec3_Impl_.add(rail.capsule.a,rail.capsule.b),2);
        new_velocity = math._Vec3.Vec3_Impl_.sub(rail_center,result.p2);
        math._Vec3.Vec3_Impl_.normalize(new_velocity);
        new_velocity = math._Vec3.Vec3_Impl_.scale(new_velocity,math._Vec3.Vec3_Impl_.length(player.transform.velocity));
      end;
      player.transform.velocity = new_velocity;
      player.transform.position = World.to_local(result.p2);
      player.player.rail = rail;
      do return true end;
    end;
    
  until true
  if _hx_break_1 then _hx_break_1 = false; break; end
  end;
  do return false end;
end

systems.PlayerController.new = function(_fixed_tick) 
  local self = _hx_new(systems.PlayerController.prototype)
  systems.PlayerController.super(self,_fixed_tick)
  return self
end
systems.PlayerController.super = function(self,_fixed_tick) 
  System.super(self,_fixed_tick);
end
systems.PlayerController.__name__ = {"systems","PlayerController"}
systems.PlayerController.mouse_moved = function(dx,dy) 
  systems.PlayerController.mx = dx;
  systems.PlayerController.my = dy;
end
systems.PlayerController.calc_jump = function(h,xh,vx,max) 
  local g = ((-2 * h) * _G.math.pow(vx,2)) / _G.math.pow(xh,2);
  local v0 = ((2 * h) * vx) / xh;
  local th = xh / vx;
  if (vx < 0.25) then 
    th = xh / max;
    g = (-2 * h) / _G.math.pow(th,2);
    v0 = -g * th;
  end;
  do return _hx_o({__fields__={g=true,v0=true,th=true},g=g,v0=v0,th=th}) end;
end
systems.PlayerController.jump = function(player,t) 
  local h = 2.5;
  local xh = 5;
  local speed = 1;
  local vx = _G.math.abs(player.jump.speed);
  local p0 = player.jump.z_offset;
  local r = systems.PlayerController.calc_jump(h,xh,vx,player.speed);
  local g = r.g;
  local v0 = r.v0;
  local th = r.th;
  if (player.jump.falling) then 
    speed = 1;
    t = t + th;
    p0 = p0 - h;
  else
    if ((t > th) and (vx > 0)) then 
      speed = 1;
    end;
  end;
  xh = xh / speed;
  local thh = th;
  r = systems.PlayerController.calc_jump(h,xh,vx,player.speed);
  g = r.g;
  v0 = r.v0;
  th = r.th;
  t = t - (thh - th);
  do return _hx_o({__fields__={z=true,h=true},z=(((g / 2) * _G.math.pow(t,2)) + (v0 * t)) + p0,h=h}) end;
end
systems.PlayerController.prototype = _hx_a(
  'filter', function(self,e) 
    if ((e.player ~= nil) and (e.transform ~= nil)) then 
      do return true end;
    end;
    do return false end
  end,
  'adjust_camera', function(self,e) 
    do return end
  end,
  'update_animation', function(self,e,move,accel,dt) 
    if ((e.animation == nil) or (e.animation.timeline == nil)) then 
      do return end;
    end;
    local tl = e.animation.timeline;
    local p = e.player;
    local ml = math._Vec3.Vec3_Impl_.length(accel);
    if (not p.on_ground) then 
      local fall = p:get_track(tl,"fall");
      local jump = p:get_track(tl,"jump");
      if (not tl:find_track(fall) and not tl:find_track(jump)) then 
        tl:reset();
        tl:play(fall);
      end;
      do return end;
    end;
    if (p.rail ~= nil) then 
      if (p.trick_state ~= components.TrickState.None) then 
        do return end;
      end;
      local gr = p:get_track(tl,"grind");
      if (not tl:find_track(gr)) then 
        tl:transition(gr,0.15);
      end;
    else
      if ((ml > 0.975) and (math._Vec3.Vec3_Impl_.length(e.transform.velocity) > 5)) then 
        local rt = p:get_track(tl,"skate");
        if (not tl:find_track(rt)) then 
          tl:transition(rt,0.2);
        end;
      else
        if (ml > 0.05) then 
          local st = p:get_track(tl,"slow");
          if (not tl:find_track(st)) then 
            tl:transition(st,0.2);
          end;
        else
          local it = p:get_track(tl,"idle");
          if (not tl:find_track(it)) then 
            tl:transition(it,0.2);
          end;
        end;
      end;
    end;
  end,
  'update_camera', function(self,e,dt) 
    if (e.camera == nil) then 
      do return end;
    end;
    e.camera:rotate_xy(systems.PlayerController.mx,-systems.PlayerController.my);
    systems.PlayerController.mx = 0;
    systems.PlayerController.my = 0;
    local sens = 500 * dt;
    local rstick = GameInput.view_xy();
    local v = rstick[1] * -1;
    rstick[1] = v;
    e.camera:rotate_xy(rstick[0] * sens,rstick[1] * sens);
    systems.Render.camera = e.camera;
  end,
  'process', function(self,e,dt) 
    local tmp = systems.PlayerController;
    tmp.now = tmp.now + dt;
    if (imgui.Input.GetWantCaptureKeyboard()) then 
      do return end;
    end;
    self:update_camera(e,dt);
    local stick = GameInput.move_xy();
    local move = math._Vec3.Vec3_Impl_._new(stick[0],stick[1],0);
    local tmp1 = not e.player.on_ground;
    local ml = math._Vec3.Vec3_Impl_.length(move);
    if (math._Vec3.Vec3_Impl_.length(move) > 1) then 
      math._Vec3.Vec3_Impl_.normalize(move);
      ml = 1;
      local v = move[1];
      stick[0] = v;
      local v1 = move[2];
      stick[1] = v1;
    end;
    move = math._Vec3.Vec3_Impl_.scale(move,-1);
    local _this = GameInput.input_state:get(Action.Jump);
    local tmp2;
    local tmp3;
    local threshold = _this.deadzone;
    if (_G.math.abs(_this.value) >= threshold) then 
      tmp3 = _this.pressed >= 0;
    else
      tmp3 = false;
    end;
    if (tmp3) then 
      tmp2 = _this.first_update;
    else
      tmp2 = false;
    end;
    if (tmp2) then 
      if (not e.player.jump.jumping and e.player.on_ground) then 
        if ((e.animation ~= nil) and (e.animation.timeline ~= nil)) then 
          local tl = e.animation.timeline;
          local jump = e.player:get_track(tl,"jump");
          local fall = e.player:get_track(tl,"fall");
          jump.callback = function() 
            tl:reset();
            tl:play(fall);
          end;
        end;
        e.player.rail = nil;
        e.player.on_ground = false;
        local _g = e.transform.velocity;
        local v2 = _g[3] + 7.5;
        _g[3] = v2;
        local _g1 = e.transform.position;
        local v3 = _g1[3] + (e.transform.velocity[3] * dt);
        _g1[3] = v3;
      end;
    end;
    local tmp4 = (not e.player.jump.jumping and not e.player.jump.falling) and not e.player.on_ground;
    local snap_cancel = false;
    local weight = e.player.turn_weight;
    local accel = e.player.accel;
    self:update_animation(e,move,accel,dt);
    local nudge = 0.0001;
    local this1;
    local this2 = ({length = 2});
    this1 = this2;
    this1[0] = accel[1];
    this1[1] = accel[2] + nudge;
    local angle = math._Vec2.Vec2_Impl_.angle_to(this1) + (_G.math.pi / 2);
    local move_orientation = math._Quat.Quat_Impl_.mul(e.camera.orientation,math._Quat.Quat_Impl_.from_angle_axis(angle,math._Vec3.Vec3_Impl_._new(0,0,1)));
    move_orientation[0] = 0;
    move_orientation[1] = 0;
    math._Quat.Quat_Impl_.normalize(move_orientation);
    local move_direction = math._Quat.Quat_Impl_.mul_vec3(move_orientation,math._Vec3.Vec3_Impl_._new(0,-1,0));
    if (math._Vec3.Vec3_Impl_.length(move) > 0) then 
      local snap_to = math._Quat.Quat_Impl_.mul(e.camera.orientation,math._Quat.Quat_Impl_.from_angle_axis(angle,math._Vec3.Vec3_Impl_._new(0,0,1)));
      if (e.transform.snap) then 
        local current = math._Quat.Quat_Impl_.mul_vec3(e.transform.snap_to,math._Vec3.Vec3_Impl_._new(0,-1,0));
        local next = math._Quat.Quat_Impl_.mul_vec3(snap_to,math._Vec3.Vec3_Impl_._new(0,-1,0));
        local b = e.camera.direction;
        local from = ((current[1] * b[1]) + (current[2] * b[2])) + (current[3] * b[3]);
        local b1 = e.camera.direction;
        local to = ((next[1] * b1[1]) + (next[2] * b1[2])) + (next[3] * b1[3]);
        if ((from ~= to) and ((_G.math.abs(from) - _G.math.abs(to)) == 0)) then 
          local this3 = e.transform.snap_to;
          local tmp5 = math._Quat.Quat_Impl_._new(this3[0],this3[1],this3[2],this3[3]);
          e.transform.orientation = tmp5;
        end;
      end;
      e.transform.snap = true;
      e.transform.snap_to = snap_to;
      e.transform.slerp = 0;
    end;
    if (e.transform.snap) then 
      e.transform.orientation = math._Quat.Quat_Impl_.slerp(e.transform.orientation,e.transform.snap_to,16 * dt);
      e.transform.orientation[0] = 0;
      e.transform.orientation[1] = 0;
      math._Quat.Quat_Impl_.normalize(e.transform.orientation);
      local e1 = e.transform;
      e1.slerp = e1.slerp + dt;
      if (e.transform.slerp >= 0.5) then 
        e.transform.slerp = 0;
        e.transform.snap = false;
        local this4 = e.transform.snap_to;
        this4[0] = 0;
        this4[1] = 0;
        this4[2] = 0;
        this4[3] = 1;
      end;
    end;
    if (e.transform.snap and snap_cancel) then 
      local this5 = e.transform.snap_to;
      local tmp6 = math._Quat.Quat_Impl_._new(this5[0],this5[1],this5[2],this5[3]);
      e.transform.orientation = tmp6;
      e.transform.orientation[0] = 0;
      e.transform.orientation[1] = 0;
      math._Quat.Quat_Impl_.normalize(e.transform.orientation);
      e.transform.slerp = 0;
      e.transform.snap = false;
      local this6 = e.transform.snap_to;
      this6[0] = 0;
      this6[1] = 0;
      this6[2] = 0;
      this6[3] = 1;
    end;
    if (systems.PlayerController.follow_camera) then 
      e.camera.orientation = math._Quat.Quat_Impl_.slerp(e.camera.orientation,e.transform.orientation,dt * 2);
      local tmp7 = math._Quat.Quat_Impl_.mul_vec3(e.camera.orientation,math._Vec3.Vec3_Impl_._new(0,-1,0));
      e.camera.direction = tmp7;
    end;
    if (ml > 0) then 
      if (math._Vec3.Vec3_Impl_.length(e.player.accel) <= ml) then 
        local e2 = e.player.accel;
        local tmp8 = math._Vec3.Vec3_Impl_.scale(math._Vec3.Vec3_Impl_.scale(move,dt),weight);
        e.player.accel = math._Vec3.Vec3_Impl_.add(e2,tmp8);
        math._Vec3.Vec3_Impl_.trim(e.player.accel,ml);
      end;
    else
      e.player.accel = math._Vec3.Vec3_Impl_.scale(e.player.accel,1.0 - (dt * weight));
    end;
    if (math._Vec3.Vec3_Impl_.length(e.player.accel) > 1) then 
      math._Vec3.Vec3_Impl_.normalize(e.player.accel);
    end;
    local old_position = e.transform.position;
    local friction = e.player.friction;
    if (e.player.rail == nil) then 
      local e3 = e.transform.velocity;
      local tmp9 = math._Vec3.Vec3_Impl_.fdiv(math._Vec3.Vec3_Impl_.scale(math._Vec3.Vec3_Impl_.scale(move_direction,ml),e.player.speed),e.player.mass);
      e.transform.velocity = math._Vec3.Vec3_Impl_.add(e3,tmp9);
    end;
    if (((e.player.rail == nil) or e.player.jump.jumping) or e.player.jump.falling) then 
      local magnet = math._Vec3.Vec3_Impl_._new(0,0,-10);
      if (e.player.on_ground) then 
        local v4 = magnet[3] * 0.1;
        magnet[3] = v4;
      end;
      local new_z = e.transform.position[3];
      local radius = e.player.radius;
      local visual_offset = math._Vec3.Vec3_Impl_._new(0,0,radius[3]);
      local _this1 = e.transform;
      local diff = math._Vec3.Vec3_Impl_.sub(e.transform.position,World.to_world(_this1.position,_this1.tile_x,_this1.tile_y));
      local gravity = math._Vec3.Vec3_Impl_._new(0,0,new_z - e.transform.position[3]);
      local _this2 = e.transform;
      local packet = collision.CollisionPacket.from_entity(math._Vec3.Vec3_Impl_.add(World.to_world(_this2.position,_this2.tile_x,_this2.tile_y),visual_offset),math._Vec3.Vec3_Impl_.scale(e.transform.velocity,dt),radius);
      Profiler.push_block("player collision",_Profiler.SegmentColor_Impl_.Player,_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="PlayerController.hx",lineNumber=540,className="systems.PlayerController",methodName="process"}));
      collision.Response.update(packet,math._Vec3.Vec3_Impl_.add(gravity,math._Vec3.Vec3_Impl_.scale(magnet,dt)));
      Profiler.pop_block(_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="PlayerController.hx",lineNumber=542,className="systems.PlayerController",methodName="process"}));
      local tmp10 = math._Vec3.Vec3_Impl_.sub(packet.r3_position,visual_offset);
      e.transform.position = math._Vec3.Vec3_Impl_.add(tmp10,diff);
      e.transform.velocity = math._Vec3.Vec3_Impl_.fdiv(packet.r3_velocity,dt);
      e.player.on_ground = packet.grounded;
    end;
    if (e.player.rail ~= nil) then 
      friction = e.player.rail.friction;
      e.player.on_ground = true;
    end;
    local cd = 1;
    local tmp11;
    local _this3 = GameInput.input_state:get(Action.TrickA);
    local tmp12;
    local tmp13;
    local threshold1 = _this3.deadzone;
    if (_G.math.abs(_this3.value) >= threshold1) then 
      tmp13 = _this3.pressed >= 0;
    else
      tmp13 = false;
    end;
    if (tmp13) then 
      tmp12 = _this3.first_update;
    else
      tmp12 = false;
    end;
    if (tmp12) then 
      tmp11 = e.player.trick_cooldown == 0;
    else
      tmp11 = false;
    end;
    if (tmp11) then 
      e.player.trick_cooldown = cd;
      if (not e.player.on_ground) then 
        Signal.emit("animation-air-trick-a",_hx_o({__fields__={e=true},e=e}));
      else
        Signal.emit("animation-rail-trick-a",_hx_o({__fields__={e=true},e=e}));
      end;
    end;
    local tmp14;
    local _this4 = GameInput.input_state:get(Action.TrickB);
    local tmp15;
    local tmp16;
    local threshold2 = _this4.deadzone;
    if (_G.math.abs(_this4.value) >= threshold2) then 
      tmp16 = _this4.pressed >= 0;
    else
      tmp16 = false;
    end;
    if (tmp16) then 
      tmp15 = _this4.first_update;
    else
      tmp15 = false;
    end;
    if (tmp15) then 
      tmp14 = e.player.trick_cooldown == 0;
    else
      tmp14 = false;
    end;
    if (tmp14) then 
      e.player.trick_cooldown = cd;
      if (not e.player.on_ground) then 
        Signal.emit("animation-air-trick-b",_hx_o({__fields__={e=true},e=e}));
      else
        Signal.emit("animation-rail-trick-b",_hx_o({__fields__={e=true},e=e}));
      end;
    end;
    if (e.player.on_ground) then 
      e.player.jump.jumping = false;
      e.player.jump.falling = false;
    end;
    e.transform.velocity = math._Vec3.Vec3_Impl_.scale(e.transform.velocity,1 - (friction * dt));
    if ((e.player.on_ground and (ml == 0)) and (math._Vec3.Vec3_Impl_.length(e.transform.velocity) < 0.1)) then 
      e.transform.velocity = math._Vec3.Vec3_Impl_.scale(e.transform.velocity,0);
      e.transform.position = old_position;
    end;
    local _this5 = e.transform;
    local ppos = World.to_world(_this5.position,_this5.tile_x,_this5.tile_y);
    local player_capsule = math.Capsule.new(ppos,ppos,e.player.rail_attach_radius);
    Debug.capsule(player_capsule,1,0,0);
    if ((e.player.rail == nil) and not e.player.on_ground) then 
      systems.RailsHelper.scan_for_rail(e,systems.RailsHelper.get_tile_rails(e));
      if (e.player.rail ~= nil) then 
        e.player.on_ground = true;
        e.player.jump.jumping = false;
        e.player.jump.falling = false;
        e.transform:update();
      end;
    else
      if (e.player.rail ~= nil) then 
        local cap_result = math.Intersect.capsule_capsule(player_capsule,e.player.rail.capsule);
        local _this6 = e.transform;
        local result = systems.RailsHelper.closest_end_of_rail(World.to_world(_this6.position,_this6.tile_x,_this6.tile_y),e.player.rail);
        local rail_direction = math._Vec3.Vec3_Impl_.sub(result.far,result.near);
        math._Vec3.Vec3_Impl_.normalize(rail_direction);
        local _this7 = e.transform;
        local direction = math._Vec3.Vec3_Impl_.sub(result.near,World.to_world(_this7.position,_this7.tile_x,_this7.tile_y));
        math._Vec3.Vec3_Impl_.normalize(direction);
        if ((((rail_direction[1] * direction[1]) + (rail_direction[2] * direction[2])) + (rail_direction[3] * direction[3])) > 0) then 
          cap_result = nil;
        end;
        local transfer = false;
        if (cap_result == nil) then 
          transfer = systems.RailsHelper.transfer_rail(e,e.player.rail);
        end;
        if ((cap_result == nil) and not transfer) then 
          e.player.rail = nil;
        end;
        if (math._Vec3.Vec3_Impl_.length(e.transform.velocity) < e.player.rail_stick_min) then 
          e.player.rail = nil;
        end;
      end;
    end;
    self:adjust_camera(e);
  end
  ,'__class__',  systems.PlayerController
)
systems.PlayerController.__super__ = System
setmetatable(systems.PlayerController.prototype,{__index=System.prototype})

systems.Render.new = function(_fixed_tick) 
  local self = _hx_new(systems.Render.prototype)
  systems.Render.super(self,_fixed_tick)
  return self
end
systems.Render.super = function(self,_fixed_tick) 
  System.super(self,_fixed_tick);
end
systems.Render.__name__ = {"systems","Render"}
systems.Render.resize = function(w,h) 
  systems.Render.main_canvas = love3d.Love3d.new_canvas(w,h,"rg11b10f",systems.Render.game_aa,true);
end
systems.Render.gui_resize = function(w,h) 
  systems.Render.canvases = _hx_tab_array({[0]=love3d.Love3d.new_canvas(w,h,"rg11b10f",systems.Render.game_aa,true), love3d.Love3d.new_canvas(w,h,"rg11b10f",systems.Render.game_aa,false) }, 2);
end
systems.Render.init = function() 
  love.graphics.setBackgroundColor(89,157,220);
  love3d.Love3d.import();
  Debug.init();
  systems.Render.resize(love.graphics.getWidth(),love.graphics.getHeight());
  systems.Render.gui_resize(2,2);
  systems.Render.swap = _hx_o({__fields__={r=true,g=true,b=true},r=systems.Render.r,g=systems.Render.g,b=systems.Render.b});
  systems.Render.grid = iqm.Iqm.load("assets/models/debug/unit-grid.iqm");
  systems.Render.cube = iqm.Iqm.load("assets/models/debug/unit-cube.iqm");
  systems.Render.sphere = iqm.Iqm.load("assets/models/debug/unit-sphere.iqm");
  systems.Render.cylinder = iqm.Iqm.load("assets/models/debug/unit-cylinder.iqm");
  systems.Render.grass = iqm.Iqm.load("assets/models/tall-grass.iqm").mesh;
  systems.Render.short_grass = iqm.Iqm.load("assets/models/short-grass.iqm").mesh;
  local _hx_expected_result = {}
  local _hx_status, _hx_result = pcall(function() 
  
      systems.Render.shaders = _hx_o({__fields__={basic=true,sky=true,post=true,debug=true,edit=true,terrain=true,grass=true},basic=love.graphics.newShader("assets/shaders/basic.glsl"),sky=love.graphics.newShader("assets/shaders/sky.glsl"),post=love.graphics.newShader("assets/shaders/post.glsl"),debug=love.graphics.newShader("assets/shaders/debug.glsl"),edit=love.graphics.newShader("assets/shaders/edit.glsl"),terrain=love.graphics.newShader("assets/shaders/terrain.glsl"),grass=love.graphics.newShader("assets/shaders/grass.glsl")});
     return _hx_expected_result end)
   if not _hx_status then 
    local _hx_1 = _hx_result
    if( lua.Boot.__instanceof(_hx_1,String) ) then 
      local err = _hx_1
      haxe.Log.trace(err,_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Render.hx",lineNumber=129,className="systems.Render",methodName="init"}));
    else _G.error(_hx_1)
    end
   elseif _hx_result ~= _hx_expected_result then return _hx_result end;
  local flags = { mipmaps = true }
  systems.Render.texture = love.graphics.newImage("assets/textures/terrain.png",flags);
  systems.Render.texture:setWrap("repeat","repeat");
  systems.Render.texture:setMipmapFilter("linear",0.9);
  systems.Render.texture:setFilter("linear","linear",16);
end
systems.Render.prototype = _hx_a(
  'filter', function(self,e) 
    if (e.transform ~= nil) then 
      do return true end;
    end;
    do return false end
  end,
  'send_uniforms', function(self,shader) 
    local w = love.graphics.getWidth();
    local h = love.graphics.getHeight();
    local this1;
    this1 = ({0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0});
    this1[0] = 1;
    local view = this1;
    local proj = math._Mat4.Mat4_Impl_.from_ortho(-w / 2,w / 2,h / 2,-h / 2,-500,500);
    if (systems.Render.camera ~= nil) then 
      view = systems.Render.camera.view;
      proj = systems.Render.camera.projection;
      local curve = 1.0;
      local threshold = 0.1;
      if (curve > threshold) then 
        curve = 1;
      else
        if (curve > 0) then 
          curve = curve / threshold;
        end;
      end;
      local data = math._Vec3.Vec3_Impl_._new(systems.Render.camera.near,_G.math.max(systems.Render.camera.far * curve,systems.Render.camera.near + 75),0);
      local result = _hx_box_mr(_hx_table.pack(shader:getExternVariable("u_clips")), {"type", "components", "arrayelements"});
      if ((result ~= nil) and (result.type ~= nil)) then 
        shader:send("u_clips",data);
      end;
      local data1 = systems.Render.camera.far / 20;
      local result1 = _hx_box_mr(_hx_table.pack(shader:getExternVariable("u_curvature")), {"type", "components", "arrayelements"});
      if ((result1 ~= nil) and (result1.type ~= nil)) then 
        shader:send("u_curvature",data1);
      end;
    end;
    local view_rot = math._Mat4.Mat4_Impl_.copy(view);
    view_rot[14] = 0;
    view_rot[13] = 0;
    view_rot[12] = 0;
    local inv = math._Mat4.Mat4_Impl_.mul(view_rot,proj);
    math._Mat4.Mat4_Impl_.invert(inv);
    local ld = GameTime.sun_direction;
    local data2 = math._Vec3.Vec3_Impl_._new(GameTime.sun_brightness,2.0 * GameTime.sun_brightness,3.0 * GameTime.sun_brightness);
    local result2 = _hx_box_mr(_hx_table.pack(shader:getExternVariable("u_fog_color")), {"type", "components", "arrayelements"});
    if ((result2 ~= nil) and (result2.type ~= nil)) then 
      shader:send("u_fog_color",data2);
    end;
    local result3 = _hx_box_mr(_hx_table.pack(shader:getExternVariable("u_light_direction")), {"type", "components", "arrayelements"});
    if ((result3 ~= nil) and (result3.type ~= nil)) then 
      shader:send("u_light_direction",ld);
    end;
    local data3 = GameTime.sun_brightness;
    local result4 = _hx_box_mr(_hx_table.pack(shader:getExternVariable("u_light_intensity")), {"type", "components", "arrayelements"});
    if ((result4 ~= nil) and (result4.type ~= nil)) then 
      shader:send("u_light_intensity",data3);
    end;
    local data4 = math._Mat4.Mat4_Impl_.to_vec4s(view);
    local result5 = _hx_box_mr(_hx_table.pack(shader:getExternVariable("u_view")), {"type", "components", "arrayelements"});
    if ((result5 ~= nil) and (result5.type ~= nil)) then 
      shader:send("u_view",data4);
    end;
    local data5 = math._Mat4.Mat4_Impl_.to_vec4s(proj);
    local result6 = _hx_box_mr(_hx_table.pack(shader:getExternVariable("u_projection")), {"type", "components", "arrayelements"});
    if ((result6 ~= nil) and (result6.type ~= nil)) then 
      shader:send("u_projection",data5);
    end;
    local data6 = math._Mat4.Mat4_Impl_.to_vec4s(inv);
    local result7 = _hx_box_mr(_hx_table.pack(shader:getExternVariable("u_inv_view_proj")), {"type", "components", "arrayelements"});
    if ((result7 ~= nil) and (result7.type ~= nil)) then 
      shader:send("u_inv_view_proj",data6);
    end;
  end,
  'render_game', function(self,c,entities,viewport,debug_draw) 
    Profiler.marker("",_Profiler.SegmentColor_Impl_.Render,_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Render.hx",lineNumber=198,className="systems.Render",methodName="render_game"}));
    local w = viewport.w;
    local h = viewport.h;
    if (systems.Render.camera ~= nil) then 
      systems.Render.camera:update(w,h);
    end;
    local vtiles = World.visible_tiles;
    Profiler.push_block("entity draw",_Profiler.SegmentColor_Impl_.Render,_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Render.hx",lineNumber=223,className="systems.Render",methodName="render_game"}));
    love.graphics.setCanvas(c);
    love.graphics.setShader(systems.Render.shaders.sky);
    self:send_uniforms(systems.Render.shaders.sky);
    love3d.Love3d.set_depth_write(false);
    love.graphics.rectangle("fill",-1,-1,2,2);
    love3d.Love3d.set_depth_test("less");
    love3d.Love3d.set_depth_write(true);
    love3d.Love3d.set_culling("back");
    love.graphics.setShader(systems.Render.shaders.terrain);
    self:send_uniforms(systems.Render.shaders.terrain);
    love.graphics.setShader(systems.Render.shaders.basic);
    self:send_uniforms(systems.Render.shaders.basic);
    love3d.Love3d.clear();
    love.graphics.setBlendMode("replace","premultiplied");
    local far = (function() 
      local _hx_1
      if (systems.Render.camera ~= nil) then 
      _hx_1 = systems.Render.camera.far; else 
      _hx_1 = 200; end
      return _hx_1
    end )();
    local pos = (function() 
      local _hx_2
      if (systems.Render.camera ~= nil) then 
      _hx_2 = systems.Render.camera.position; else 
      _hx_2 = math._Vec3.Vec3_Impl_._new(); end
      return _hx_2
    end )();
    local mtx = math._Mat4.Mat4_Impl_.mul(math._Mat4.Mat4_Impl_.scale(math._Vec3.Vec3_Impl_._new(far,far,1)),math._Mat4.Mat4_Impl_.translate(math._Vec3.Vec3_Impl_._new(pos[1],pos[2],World.kill_z)));
    local shader = systems.Render.shaders.basic;
    love.graphics.setShader(shader);
    local data = math._Mat4.Mat4_Impl_.to_vec4s(mtx);
    local result = _hx_box_mr(_hx_table.pack(shader:getExternVariable("u_model")), {"type", "components", "arrayelements"});
    if ((result ~= nil) and (result.type ~= nil)) then 
      shader:send("u_model",data);
    end;
    local inv = math._Mat4.Mat4_Impl_.copy(mtx);
    math._Mat4.Mat4_Impl_.invert(inv);
    math._Mat4.Mat4_Impl_.transpose(inv);
    local data1 = math._Mat4.Mat4_Impl_.to_vec4s(inv);
    local result1 = _hx_box_mr(_hx_table.pack(shader:getExternVariable("u_normal_mtx")), {"type", "components", "arrayelements"});
    if ((result1 ~= nil) and (result1.type ~= nil)) then 
      shader:send("u_normal_mtx",data1);
    end;
    love.graphics.draw(systems.Render.grid.mesh);
    love.graphics.setShader(systems.Render.shaders.basic);
    local last_shader = components.ShaderType.Basic;
    local wire_only = systems.Render.wire_mode;
    local _g = 0;
    while (_g < vtiles.length) do 
      local vt = vtiles[_g];
      _g = _g + 1;
      local tile = vt.world_tile;
      local drawables = tile.entities:filter((function() 
        do return function(e) 
          if (e.drawable ~= nil) then 
            do return e.transform ~= nil end;
          else
            do return false end;
          end;
        end end;
      end)());
      local scale = World.tile_size;
      local tile_offset = math._Vec3.Vec3_Impl_._new(scale * vt.x,scale * vt.y,0.0);
      local _g1 = 0;
      local _hx_break_1 = false;
      while (_g1 < drawables.length) do 
        repeat 
        local e1 = drawables[_g1];
        _g1 = _g1 + 1;
        local d = _hx_tab_array({[0]=e1.drawable }, 1);
        local xform = e1.transform;
        if (d[0].mesh == nil) then 
          break;
        end;
        local shader1 = (function() 
          local _hx_3
          if (d[0].shader == components.ShaderType.Terrain) then 
          _hx_3 = systems.Render.shaders.terrain; else 
          _hx_3 = systems.Render.shaders.basic; end
          return _hx_3
        end )();
        if (d[0].shader ~= last_shader) then 
          local _g2 = haxe.ds.EnumValueMap.new();
          _g2:set(components.ShaderType.Basic,systems.Render.shaders.basic);
          _g2:set(components.ShaderType.Terrain,systems.Render.shaders.terrain);
          local st = _g2;
          love.graphics.setShader(st:get(d[0].shader));
        end;
        last_shader = d[0].shader;
        local this1;
        this1 = ({0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0});
        this1[0] = 1;
        local mtx1 = this1;
        local _self = xform.scale;
        if ((((_self[1] * _self[1]) + (_self[2] * _self[2])) + (_self[3] * _self[3])) > 0) then 
          mtx1 = math._Mat4.Mat4_Impl_.mul(mtx1,math._Mat4.Mat4_Impl_.scale(xform.scale));
        end;
        local a = math._Quat.Quat_Impl_.to_angle_axis(xform.orientation);
        mtx1 = math._Mat4.Mat4_Impl_.mul(mtx1,math._Mat4.Mat4_Impl_.from_angle_axis(a.angle,a.axis));
        mtx1 = math._Mat4.Mat4_Impl_.mul(mtx1,math._Mat4.Mat4_Impl_.translate(math._Vec3.Vec3_Impl_.add(xform.position,tile_offset)));
        if (e1.rails ~= nil) then 
          local _g21 = 0;
          local _g3 = e1.rails;
          while (_g21 < _g3.length) do 
            local rail = _g3[_g21];
            _g21 = _g21 + 1;
            Debug.capsule(rail.capsule,1,0,1);
            end;
        end;
        local data2 = math._Mat4.Mat4_Impl_.to_vec4s(mtx1);
        local result2 = _hx_box_mr(_hx_table.pack(shader1:getExternVariable("u_model")), {"type", "components", "arrayelements"});
        if ((result2 ~= nil) and (result2.type ~= nil)) then 
          shader1:send("u_model",data2);
        end;
        local inv1 = math._Mat4.Mat4_Impl_.copy(mtx1);
        math._Mat4.Mat4_Impl_.invert(inv1);
        math._Mat4.Mat4_Impl_.transpose(inv1);
        local data3 = math._Mat4.Mat4_Impl_.to_vec4s(inv1);
        local result3 = _hx_box_mr(_hx_table.pack(shader1:getExternVariable("u_normal_mtx")), {"type", "components", "arrayelements"});
        if ((result3 ~= nil) and (result3.type ~= nil)) then 
          shader1:send("u_normal_mtx",data3);
        end;
        local animated = (e1.animation ~= nil) and (e1.animation.timeline ~= nil);
        if (d[0].shader == components.ShaderType.Basic) then 
          shader1:send("u_rigged",(function() 
            local _hx_4
            if (animated) then 
            _hx_4 = 1; else 
            _hx_4 = 0; end
            return _hx_4
          end )());
          if (animated) then 
            local tl = e1.animation.timeline;
            shader1:send("u_pose",_hx_table.unpack(tl.current_pose));
          end;
        end;
        if (d[0].shader == components.ShaderType.Terrain) then 
          d[0].mesh.mesh:setTexture(systems.Render.texture);
        end;
        lua.PairTools.ipairsEach(d[0].mesh.meshes,(function(d1) 
          do return function(i,m) 
            local mesh = d1[0].mesh.mesh;
            mesh:setDrawRange(m.first,m.last);
            if (debug_draw or wire_only) then 
              love3d.Love3d.set_culling(nil);
              love.graphics.setColor(0.,0.,0.,255.0);
              love.graphics.setWireframe(true);
              love.graphics.draw(mesh);
              love.graphics.setColor(255.0,255.0,255.0,255.0);
              love.graphics.setWireframe(false);
              love3d.Love3d.set_culling("back");
            end;
            if (not wire_only) then 
              love.graphics.draw(mesh);
            end;
          end end;
        end)(d));
        if (debug_draw) then 
          local bounds = d[0].mesh.bounds.base;
          local min = math._Vec3.Vec3_Impl_._new(bounds.min[1],bounds.min[2],bounds.min[3]);
          local max = math._Vec3.Vec3_Impl_._new(bounds.max[1],bounds.max[2],bounds.max[3]);
          local xform_bounds = math.Utils.rotate_bounds(mtx1,min,max);
          Debug.aabb(xform_bounds.min,xform_bounds.max,0,1,1);
        end;
        if ((e1.attachments ~= nil) and animated) then 
          local tl1 = e1.animation.timeline;
          local _g22 = 0;
          local _g31 = e1.attachments;
          while (_g22 < _g31.length) do 
            local attach = _hx_tab_array({[0]=_g31[_g22] }, 1);
            _g22 = _g22 + 1;
            local m1 = math._Mat4.Mat4_Impl_.from_cpml(tl1.current_matrices[attach[0].bone]);
            local data4 = _hx_tab_array({[0]=1, 0, 0, 0, 0, 0, -1, 0, 0, 1, 0, 0, attach[0].offset[1], attach[0].offset[3], -attach[0].offset[2], 1 }, 16);
            local this2;
            if (data4 == nil) then 
              this2 = ({0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0});
              this2[0] = 1;
            else
              this2 = data4;
            end;
            local flip = this2;
            local am = math._Mat4.Mat4_Impl_.mul(math._Mat4.Mat4_Impl_.mul(flip,m1),mtx1);
            if (debug_draw) then 
              local bounds1 = attach[0].mesh.bounds.base;
              local min1 = math._Vec3.Vec3_Impl_._new(bounds1.min[1],bounds1.min[2],bounds1.min[3]);
              local max1 = math._Vec3.Vec3_Impl_._new(bounds1.max[1],bounds1.max[2],bounds1.max[3]);
              local xform_bounds1 = math.Utils.rotate_bounds(am,min1,max1);
              Debug.aabb(xform_bounds1.min,xform_bounds1.max,0,0,1);
            end;
            shader1:send("u_model",math._Mat4.Mat4_Impl_.to_vec4s(am));
            shader1:send("u_rigged",0);
            local inv2 = math._Mat4.Mat4_Impl_.copy(am);
            math._Mat4.Mat4_Impl_.invert(inv2);
            math._Mat4.Mat4_Impl_.transpose(inv2);
            local data5 = math._Mat4.Mat4_Impl_.to_vec4s(inv2);
            local result4 = _hx_box_mr(_hx_table.pack(shader1:getExternVariable("u_normal_mtx")), {"type", "components", "arrayelements"});
            if ((result4 ~= nil) and (result4.type ~= nil)) then 
              shader1:send("u_normal_mtx",data5);
            end;
            lua.PairTools.ipairsEach(attach[0].mesh.meshes,(function(attach1) 
              do return function(i1,m2) 
                local mesh1 = attach1[0].mesh.mesh;
                mesh1:setDrawRange(m2.first,m2.last);
                if (debug_draw or wire_only) then 
                  love3d.Love3d.set_culling(nil);
                  love.graphics.setColor(0.,0.,0.,255.0);
                  love.graphics.setWireframe(true);
                  love.graphics.draw(mesh1);
                  love.graphics.setColor(255.0,255.0,255.0,255.0);
                  love.graphics.setWireframe(false);
                  love3d.Love3d.set_culling("back");
                end;
                if (not wire_only) then 
                  love.graphics.draw(mesh1);
                end;
              end end;
            end)(attach));
            end;
        end;
        
      until true
      if _hx_break_2 then _hx_break_2 = false; break; end
      end;
      end;
    Profiler.pop_block(_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Render.hx",lineNumber=396,className="systems.Render",methodName="render_game"}));
    local this3 = math._Vec3.Vec3_Impl_._new(0.25,0.75,0.0);
    Profiler.push_block("grass",this3,_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Render.hx",lineNumber=398,className="systems.Render",methodName="render_game"}));
    local count = 0;
    if (systems.Render.grass_enabled) then 
      local models = _hx_tab_array({[0]=systems.Render.short_grass, systems.Render.short_grass, systems.Render.short_grass, systems.Render.short_grass, systems.Render.short_grass, systems.Render.grass }, 6);
      local _g4 = 0;
      while (_g4 < vtiles.length) do 
        local vt1 = vtiles[_g4];
        _g4 = _g4 + 1;
        local scale1 = World.tile_size;
        count = render.Grass.scatter(systems.Render.instances,systems.Render.camera,models,math._Vec3.Vec3_Impl_._new(scale1 * vt1.x,scale1 * vt1.y,0.0),systems.Render.grass_seed,count,0,systems.Render.grass_range,systems.Render.grass_density,systems.Render.grass_range);
        end;
    end;
    local this4 = math._Vec3.Vec3_Impl_._new(0.1,0.5,0.0);
    Profiler.push_block("grass draw",this4,_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Render.hx",lineNumber=414,className="systems.Render",methodName="render_game"}));
    local gs = systems.Render.shaders.grass;
    love.graphics.setShader(gs);
    self:send_uniforms(gs);
    local data6 = systems.Render.now;
    local result5 = _hx_box_mr(_hx_table.pack(gs:getExternVariable("u_time")), {"type", "components", "arrayelements"});
    if ((result5 ~= nil) and (result5.type ~= nil)) then 
      gs:send("u_time",data6);
    end;
    local result6 = _hx_box_mr(_hx_table.pack(gs:getExternVariable("u_speed")), {"type", "components", "arrayelements"});
    if ((result6 ~= nil) and (result6.type ~= nil)) then 
      gs:send("u_speed",1);
    end;
    local result7 = _hx_box_mr(_hx_table.pack(gs:getExternVariable("u_wind_force")), {"type", "components", "arrayelements"});
    if ((result7 ~= nil) and (result7.type ~= nil)) then 
      gs:send("u_wind_force",0.5);
    end;
    love3d.Love3d.set_culling("back");
    local _g11 = 0;
    local _g5 = count;
    while (_g11 < _g5) do 
      _g11 = _g11 + 1;
      local i2 = _g11 - 1;
      local instance = systems.Render.instances[i2];
      gs:send("u_instance",instance);
      love.graphics.draw(instance[5]);
      end;
    Profiler.pop_block(_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Render.hx",lineNumber=429,className="systems.Render",methodName="render_game"}));
    Profiler.pop_block(_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Render.hx",lineNumber=430,className="systems.Render",methodName="render_game"}));
    local this5 = math._Vec3.Vec3_Impl_._new(0.25,0.25,0.25);
    Profiler.push_block("debug draw",this5,_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Render.hx",lineNumber=432,className="systems.Render",methodName="render_game"}));
    love.graphics.setWireframe(true);
    love.graphics.setShader(systems.Render.shaders.debug);
    self:send_uniforms(systems.Render.shaders.debug);
    local shader2 = systems.Render.shaders.debug;
    local data7 = math._Vec3.Vec3_Impl_._new(systems.Render.r,systems.Render.g,systems.Render.b);
    local result8 = _hx_box_mr(_hx_table.pack(shader2:getExternVariable("u_white_point")), {"type", "components", "arrayelements"});
    if ((result8 ~= nil) and (result8.type ~= nil)) then 
      shader2:send("u_white_point",data7);
    end;
    local shader3 = systems.Render.shaders.debug;
    local data8 = systems.Render.exposure;
    local result9 = _hx_box_mr(_hx_table.pack(shader3:getExternVariable("u_exposure")), {"type", "components", "arrayelements"});
    if ((result9 ~= nil) and (result9.type ~= nil)) then 
      shader3:send("u_exposure",data8);
    end;
    love3d.Love3d.set_culling(nil);
    local shader4 = systems.Render.shaders.debug;
    local this6;
    this6 = ({0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0});
    this6[0] = 1;
    local data9 = math._Mat4.Mat4_Impl_.to_vec4s(this6);
    local result10 = _hx_box_mr(_hx_table.pack(shader4:getExternVariable("u_model")), {"type", "components", "arrayelements"});
    if ((result10 ~= nil) and (result10.type ~= nil)) then 
      shader4:send("u_model",data9);
    end;
    Debug.draw(false);
    love.graphics.setWireframe(false);
    love.graphics.setBlendMode("alpha","alphamultiply");
    local caps = Debug.clear_capsules();
    local shader5 = systems.Render.shaders.debug;
    love.graphics.setShader(shader5);
    local _g6 = 0;
    while (_g6 < caps.length) do 
      local cap_data = caps[_g6];
      _g6 = _g6 + 1;
      love.graphics.setColor(cap_data.r * 255.0,cap_data.g * 255.0,cap_data.b * 255.0,127.5);
      local capsule = cap_data.capsule;
      local capsule1 = capsule.a;
      local radius = capsule.radius;
      local mtx2 = math._Mat4.Mat4_Impl_.mul(math._Mat4.Mat4_Impl_.scale(math._Vec3.Vec3_Impl_._new(radius,radius,radius)),math._Mat4.Mat4_Impl_.translate(capsule1));
      local data10 = math._Mat4.Mat4_Impl_.to_vec4s(mtx2);
      local result11 = _hx_box_mr(_hx_table.pack(shader5:getExternVariable("u_model")), {"type", "components", "arrayelements"});
      if ((result11 ~= nil) and (result11.type ~= nil)) then 
        shader5:send("u_model",data10);
      end;
      love.graphics.draw(systems.Render.sphere.mesh);
      local capsule2 = capsule.b;
      local radius1 = capsule.radius;
      mtx2 = math._Mat4.Mat4_Impl_.mul(math._Mat4.Mat4_Impl_.scale(math._Vec3.Vec3_Impl_._new(radius1,radius1,radius1)),math._Mat4.Mat4_Impl_.translate(capsule2));
      local data11 = math._Mat4.Mat4_Impl_.to_vec4s(mtx2);
      local result12 = _hx_box_mr(_hx_table.pack(shader5:getExternVariable("u_model")), {"type", "components", "arrayelements"});
      if ((result12 ~= nil) and (result12.type ~= nil)) then 
        shader5:send("u_model",data11);
      end;
      love.graphics.draw(systems.Render.sphere.mesh);
      local dir = math._Vec3.Vec3_Impl_.sub(capsule.b,capsule.a);
      math._Vec3.Vec3_Impl_.normalize(dir);
      local rot = math._Quat.Quat_Impl_.from_direction(dir);
      math._Quat.Quat_Impl_.normalize(rot);
      local a1 = capsule.a;
      local b = capsule.b;
      local dx = a1[1] - b[1];
      local dy = a1[2] - b[2];
      local dz = a1[3] - b[3];
      local length = _G.math.sqrt(((dx * dx) + (dy * dy)) + (dz * dz));
      local s = math._Vec3.Vec3_Impl_._new(capsule.radius,capsule.radius,length / 2);
      local t = math._Vec3.Vec3_Impl_.fdiv(math._Vec3.Vec3_Impl_.add(capsule.a,capsule.b),2);
      local mtx3 = math._Mat4.Mat4_Impl_.scale(s);
      local a2 = math._Quat.Quat_Impl_.to_angle_axis(rot);
      mtx2 = math._Mat4.Mat4_Impl_.mul(math._Mat4.Mat4_Impl_.mul(mtx3,math._Mat4.Mat4_Impl_.from_angle_axis(a2.angle,a2.axis)),math._Mat4.Mat4_Impl_.translate(t));
      local data12 = math._Mat4.Mat4_Impl_.to_vec4s(mtx2);
      local result13 = _hx_box_mr(_hx_table.pack(shader5:getExternVariable("u_model")), {"type", "components", "arrayelements"});
      if ((result13 ~= nil) and (result13.type ~= nil)) then 
        shader5:send("u_model",data12);
      end;
      love.graphics.draw(systems.Render.cylinder.mesh);
      end;
    Profiler.pop_block(_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Render.hx",lineNumber=499,className="systems.Render",methodName="render_game"}));
    love.graphics.setWireframe(false);
    love.graphics.setShader();
    love3d.Love3d.set_depth_test();
    love.graphics.setCanvas();
    love.graphics.setShader();
  end,
  'setup_post', function(self) 
    love.graphics.setShader(systems.Render.shaders.post);
    if (systems.Render.ab) then 
      local shader = systems.Render.shaders.post;
      local data = math._Vec3.Vec3_Impl_._new(systems.Render.swap.r,systems.Render.swap.g,systems.Render.swap.b);
      local result = _hx_box_mr(_hx_table.pack(shader:getExternVariable("u_white_point")), {"type", "components", "arrayelements"});
      if ((result ~= nil) and (result.type ~= nil)) then 
        shader:send("u_white_point",data);
      end;
    else
      local shader1 = systems.Render.shaders.post;
      local data1 = math._Vec3.Vec3_Impl_._new(systems.Render.r,systems.Render.g,systems.Render.b);
      local result1 = _hx_box_mr(_hx_table.pack(shader1:getExternVariable("u_white_point")), {"type", "components", "arrayelements"});
      if ((result1 ~= nil) and (result1.type ~= nil)) then 
        shader1:send("u_white_point",data1);
      end;
    end;
    local shader2 = systems.Render.shaders.post;
    local data2 = systems.Render.exposure;
    local result2 = _hx_box_mr(_hx_table.pack(shader2:getExternVariable("u_exposure")), {"type", "components", "arrayelements"});
    if ((result2 ~= nil) and (result2.type ~= nil)) then 
      shader2:send("u_exposure",data2);
    end;
    local shader3 = systems.Render.shaders.post;
    local data3 = systems.Render.vignette;
    local result3 = _hx_box_mr(_hx_table.pack(shader3:getExternVariable("u_vignette")), {"type", "components", "arrayelements"});
    if ((result3 ~= nil) and (result3.type ~= nil)) then 
      shader3:send("u_vignette",data3);
    end;
    love.graphics.setColor(255.0,255.0,255.0,255.0);
  end,
  'draw_game_view', function(self,vp,entities,submit_view) 
    local _gthis = self;
    if (not submit_view) then 
      self:render_game(systems.Render.main_canvas,entities,vp,false);
      do return end;
    end;
    self:render_game(systems.Render.canvases[0],entities,vp,false);
    local c = systems.Render.canvases[1];
    c:renderTo(function() 
      _gthis:setup_post();
      love.graphics.draw(systems.Render.canvases[0]);
      love.graphics.setShader();
    end);
    imgui.Widget.SetCursorPos(vp.x,vp.y);
    imgui.Widget.Image(c,vp.w,vp.h,0,0,1,1);
  end,
  'update', function(self,entities,dt) 
    local tmp = systems.Render;
    tmp.now = tmp.now + dt;
    local w = love.graphics.getWidth();
    local h = love.graphics.getHeight();
    editor.Panel.register_panel(editor.UIPanelCategory.Settings,"Post Processing",function() 
      imgui.Widget.BeginGroup();
      if (imgui.Widget.Checkbox("##ab",not systems.Render.ab)) then 
        systems.Render.ab = not systems.Render.ab;
      end;
      imgui.Widget.SameLine();
      if (systems.Render.ab) then 
        imgui.Style.PushStyleColor("Text",1,1,1,0.5);
      end;
      local _hx_1_ret_status, _hx_1_ret_f1, _hx_1_ret_f2, _hx_1_ret_f3 = imgui.Widget.DragFloat3("White Point",systems.Render.r,systems.Render.g,systems.Render.b,0.1,0.5,20);
      if (not systems.Render.ab) then 
        systems.Render.r = _hx_1_ret_f1;
        systems.Render.g = _hx_1_ret_f2;
        systems.Render.b = _hx_1_ret_f3;
      end;
      if (systems.Render.ab) then 
        imgui.Style.PopStyleColor();
      end;
      imgui.Widget.EndGroup();
      local r2 = _hx_box_mr(_hx_table.pack(imgui.Widget.SliderFloat("Exposure",systems.Render.exposure,-5,5)), {"status", "f1"});
      systems.Render.exposure = r2.f1;
      r2 = _hx_box_mr(_hx_table.pack(imgui.Widget.SliderFloat("Vignette",systems.Render.vignette,0,1)), {"status", "f1"});
      systems.Render.vignette = r2.f1;
    end);
    editor.Panel.register_panel(editor.UIPanelCategory.Settings,"Grass",function() 
      if (imgui.Widget.Checkbox("Draw Grass",systems.Render.grass_enabled)) then 
        systems.Render.grass_enabled = not systems.Render.grass_enabled;
      end;
      local rf = _hx_box_mr(_hx_table.pack(imgui.Widget.SliderFloat("Range",systems.Render.grass_range,0,200)), {"status", "f1"});
      systems.Render.grass_range = rf.f1;
      rf = _hx_box_mr(_hx_table.pack(imgui.Widget.SliderFloat("Density",systems.Render.grass_density,0,10)), {"status", "f1"});
      systems.Render.grass_density = rf.f1;
      local _hx_2_ri_status, _hx_2_ri_i1 = imgui.Widget.SliderInt("Seed",systems.Render.grass_seed,0,100);
      systems.Render.grass_seed = _hx_2_ri_i1;
    end);
    editor.Panel.register_panel(editor.UIPanelCategory.Settings,"Display",function() 
      if (imgui.Widget.Checkbox("Wireframe",systems.Render.wire_mode)) then 
        systems.Render.wire_mode = not systems.Render.wire_mode;
      end;
    end);
    local editing = false;
    if (Main.showing_menu(WindowType.EditorUI)) then 
      editing = true;
    end;
    local cx = 4;
    local cy = 4;
    if (editing) then 
      GameInput.bind(Action.Debug_F7,function() 
        systems.Render.activate_game = true;
        love.mouse.setRelativeMode(true);
        do return true end;
      end);
      GameInput.bind(Action.Debug_F8,function() 
        love.mouse.setRelativeMode(false);
        do return true end;
      end);
      imgui.Window.SetNextWindowPos(0,20);
      imgui.Window.SetNextWindowSize(w,h - 20);
      local open = imgui.Window.Begin("DockArea",true,({"NoWindowBg","NoTitleBar","NoResize","NoMove","NoBringToFrontOnFocus","NoCollapse"}));
      if (open) then 
        love.graphics.setBackgroundColor(17.8,31.4,44.);
        imgui.Window.BeginDockspace();
        imgui.Window.SetNextDock("Right");
        editor.Editor.running = false;
        local flags = ({"NoScrollbar"});
        open = imgui.Window.BeginDock("Editor##editor_view",nil,flags);
        if (systems.Render.activate_game) then 
          imgui.Window.SetDockActive();
          systems.Render.activate_game = false;
        end;
        if (open) then 
          editor.Editor.running = true;
          local _hx_3_v_f1, _hx_3_v_f2 = imgui.Window.GetContentRegionMax();
          local size_0 = _hx_3_v_f1;
          local size_1 = _hx_3_v_f2;
          local vp = _hx_o({__fields__={x=true,y=true,w=true,h=true},x=0,y=0,w=size_0 + (cx * 2),h=size_1 + (cy * 2)});
          if ((vp.w ~= systems.Render.canvases[0]:getWidth()) or (vp.h ~= systems.Render.canvases[0]:getHeight())) then 
            systems.Render.gui_resize(vp.w,vp.h);
          end;
          self:draw_game_view(vp,entities,true);
        end;
        imgui.Window.EndDock();
        imgui.Window.SetNextDock("Bottom");
        ui.LogWindow.draw();
        imgui.Window.SetNextDockSplitRatio(0.2,0.5);
        imgui.Window.SetNextDock("Left");
        editor.Editor.draw();
        imgui.Window.EndDockspace();
      end;
      imgui.Window.End();
    else
      love.graphics.setBackgroundColor(89,157,220);
      local vp1 = _hx_o({__fields__={x=true,y=true,w=true,h=true},x=0,y=0,w=w,h=h});
      self:draw_game_view(vp1,entities,false);
      local c = systems.Render.main_canvas;
      local rw = w / c:getWidth();
      local rh = h / c:getHeight();
      self:setup_post();
      love.graphics.draw(c,vp1.x,vp1.y,0,rw,rh);
      love.graphics.setShader();
    end;
    if (World.is_local()) then 
      love.graphics.setColor(51.,0.,0.,242.25);
      local str = "LOCAL MAP";
      local f = love.graphics.getFont();
      love.graphics.rectangle("fill",20,20,f:getWidth(str) + 20,f:getHeight() + 20);
      love.graphics.setColor(255.0,0.,0.,255.0);
      love.graphics.print(str,30,30);
    end;
    love.graphics.setColor(255.0,255.0,255.0,255.0);
    systems.Hud.draw();
    love.graphics.setColor(255.0,255.0,255.0,255.0);
  end
  ,'__class__',  systems.Render
)
systems.Render.__super__ = System
setmetatable(systems.Render.prototype,{__index=System.prototype})

systems.Trigger.new = function(_fixed_tick) 
  local self = _hx_new(systems.Trigger.prototype)
  systems.Trigger.super(self,_fixed_tick)
  return self
end
systems.Trigger.super = function(self,_fixed_tick) 
  System.super(self,_fixed_tick);
end
systems.Trigger.__name__ = {"systems","Trigger"}
systems.Trigger.register_signals = function() 
  Signal.register("Test",function(params) 
    local e = params.e;
    local ts = params.ts;
    if (ts == components.TriggerState.Entered) then 
      haxe.Log.trace("Entered",_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Trigger.hx",lineNumber=40,className="systems.Trigger",methodName="register_signals"}));
      e.trigger.enabled = false;
      local _self = e.transform.position;
      local new_pos = math._Vec3.Vec3_Impl_._new(_self[1],_self[2],_self[3]);
      local v = new_pos[3] + 1;
      new_pos[3] = v;
      TimerAction.add(1,e.transform.position,new_pos,actor.TweenType.OutCubic,function() 
        Signal.emit("enable-trigger",_hx_o({__fields__={e=true},e=e}));
        e.transform:update();
      end);
    end;
    if (ts == components.TriggerState.Inside) then 
      haxe.Log.trace("Inside",_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Trigger.hx",lineNumber=52,className="systems.Trigger",methodName="register_signals"}));
    end;
    if (ts == components.TriggerState.Left) then 
      haxe.Log.trace("Left",_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Trigger.hx",lineNumber=56,className="systems.Trigger",methodName="register_signals"}));
    end;
  end);
  Signal.register("enable-trigger",function(params1) 
    params1.e.trigger.enabled = true;
  end);
  Signal.register("animation-grind",function(params2) 
    haxe.Log.trace("grind",_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Trigger.hx",lineNumber=72,className="systems.Trigger",methodName="register_signals"}));
    local e1 = params2.e;
    local tl = e1.animation.timeline;
    local gr = e1.player:get_track(tl,"grind");
    if (not tl:find_track(gr)) then 
      tl:reset();
      tl:play(gr);
    end;
  end);
  Signal.register("animation-skate",function(params3) 
    haxe.Log.trace("skate",_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Trigger.hx",lineNumber=84,className="systems.Trigger",methodName="register_signals"}));
    local e2 = params3.e;
    local tl1 = e2.animation.timeline;
    local gr1 = e2.player:get_track(tl1,"skate");
    if (not tl1:find_track(gr1)) then 
      tl1:reset();
      tl1:play(gr1);
    end;
  end);
  Signal.register("animation-air-trick-a",function(params4) 
    haxe.Log.trace("air a",_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Trigger.hx",lineNumber=96,className="systems.Trigger",methodName="register_signals"}));
    local e3 = params4.e;
    local tl2 = e3.animation.timeline;
    local gr2 = e3.player:get_track(tl2,"trick.a");
    if (not tl2:find_track(gr2)) then 
      tl2:reset();
      tl2:play(gr2);
    end;
    gr2.callback = function() 
      Signal.emit("animation-skate",params4);
    end;
  end);
  Signal.register("animation-rail-trick-a",function(params5) 
    haxe.Log.trace("rail a",_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Trigger.hx",lineNumber=112,className="systems.Trigger",methodName="register_signals"}));
    local e4 = params5.e;
    local tl3 = e4.animation.timeline;
    if (e4.player.trick_state == components.TrickState.TrickA) then 
      e4.player.trick_state = components.TrickState.None;
      local gr3 = e4.player:get_track(tl3,"grind");
      if (not tl3:find_track(gr3)) then 
        tl3:reset();
        tl3:play(gr3);
      end;
    else
      e4.player.trick_state = components.TrickState.TrickA;
      local gr4 = e4.player:get_track(tl3,"trick.a");
      if (not tl3:find_track(gr4)) then 
        tl3:reset();
        tl3:play(gr4);
      end;
      gr4.callback = function() 
        Signal.emit("animation-rail-grind-a",params5);
      end;
    end;
    math._Vec3.Vec3_Impl_.normalize(e4.transform.velocity);
    e4.transform.velocity = math._Vec3.Vec3_Impl_.scale(e4.transform.velocity,10);
  end);
  Signal.register("animation-rail-grind-a",function(params6) 
    haxe.Log.trace("grind a",_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Trigger.hx",lineNumber=143,className="systems.Trigger",methodName="register_signals"}));
    local e5 = params6.e;
    local tl4 = e5.animation.timeline;
    local gr5 = e5.player:get_track(tl4,"grind.a");
    if (not tl4:find_track(gr5)) then 
      tl4:reset();
      tl4:play(gr5);
    end;
  end);
end
systems.Trigger.in_front_of = function(p,e,max_distance,min_angle) 
  local dir = math._Quat.Quat_Impl_.mul_vec3(p.orientation,math._Vec3.Vec3_Impl_.scale(math._Vec3.Vec3_Impl_._new(0,1,0),-1));
  local ppos = World.to_world(p.position,p.tile_x,p.tile_y);
  local epos = World.to_world(e.position,e.tile_x,e.tile_y);
  local p2e = math._Vec3.Vec3_Impl_.sub(epos,ppos);
  math._Vec3.Vec3_Impl_.normalize(p2e);
  if ((((p2e[1] * dir[1]) + (p2e[2] * dir[2])) + (p2e[3] * dir[3])) > min_angle) then 
    local dx = ppos[1] - epos[1];
    local dy = ppos[2] - epos[2];
    local dz = ppos[3] - epos[3];
    local in_range = _G.math.sqrt(((dx * dx) + (dy * dy)) + (dz * dz)) <= max_distance;
    local offset = math._Vec3.Vec3_Impl_._new(0,0,0.001);
    if (in_range) then 
      Debug.line(math._Vec3.Vec3_Impl_.add(ppos,offset),math._Vec3.Vec3_Impl_.add(math._Vec3.Vec3_Impl_.add(ppos,p2e),offset),0,1,0.5);
    else
      Debug.line(math._Vec3.Vec3_Impl_.add(ppos,offset),math._Vec3.Vec3_Impl_.add(math._Vec3.Vec3_Impl_.add(ppos,p2e),offset),1,0,0.5);
    end;
    do return in_range end;
  end;
  do return false end;
end
systems.Trigger.prototype = _hx_a(
  'filter', function(self,e) 
    if (e.player ~= nil) then 
      self.player = e;
    end;
    if (e.trigger ~= nil) then 
      do return e.transform ~= nil end;
    else
      do return false end;
    end;
  end,
  'update', function(self,entities,dt) 
    if (imgui.Input.GetWantCaptureKeyboard()) then 
      do return end;
    end;
    if (self.player == nil) then 
      do return end;
    end;
    local p = self.player;
    local _this = p.transform;
    local ppos = World.to_world(_this.position,_this.tile_x,_this.tile_y);
    local dir = math._Quat.Quat_Impl_.mul_vec3(p.transform.orientation,math._Vec3.Vec3_Impl_._new(0,-1,0));
    local range = math._Vec3.Vec3_Impl_._new(0,0,0);
    local _g = 0;
    local _hx_break_0 = false;
    while (_g < entities.length) do 
      repeat 
      local e = entities[_g];
      _g = _g + 1;
      local trigger = e.trigger;
      local _this1 = e.transform;
      local tpos = World.to_world(_this1.position,_this1.tile_x,_this1.tile_y);
      local hit = false;
      if (not trigger.enabled) then 
        break;
      end;
      local _g1 = trigger.type;
      local _g11 = _g1[1];
      if (_g11) == 0 then 
        local dx = tpos[1] - ppos[1];
        local dy = tpos[2] - ppos[2];
        local dz = tpos[3] - ppos[3];
        hit = _G.math.sqrt(((dx * dx) + (dy * dy)) + (dz * dz)) <= trigger.range;
      elseif (_g11) == 1 then 
        local _g12 = 0;
        while (_g12 < 3) do 
          _g12 = _g12 + 1;
          local i = _g12 - 1;
          range[i + 1] = trigger.range;
          end;
        local aabb = math.Bounds.from_extents(math._Vec3.Vec3_Impl_.sub(tpos,range),math._Vec3.Vec3_Impl_.add(tpos,range));
        if (((((aabb.min[1] <= ppos[1]) and (aabb.max[1] >= ppos[1])) and (aabb.min[2] <= ppos[2])) and (aabb.max[2] >= ppos[2])) and (aabb.min[3] <= ppos[3])) then 
          hit = aabb.max[3] >= ppos[3];
        else
          hit = false;
        end;
      elseif (_g11) == 2 then 
        hit = systems.Trigger.in_front_of(p.transform,e.transform,trigger.range,1 - trigger.max_angle); end;
      if (hit) then 
        if (not trigger.inside) then 
          trigger.inside = true;
          Signal.emit(trigger.cb,_hx_o({__fields__={e=true,ts=true},e=e,ts=components.TriggerState.Entered}));
        end;
        Signal.emit(trigger.cb,_hx_o({__fields__={e=true,ts=true},e=e,ts=components.TriggerState.Inside}));
      else
        if (trigger.inside) then 
          trigger.inside = false;
          Signal.emit(trigger.cb,_hx_o({__fields__={e=true,ts=true},e=e,ts=components.TriggerState.Left}));
        end;
      end;
      
    until true
    if _hx_break_1 then _hx_break_1 = false; break; end
    end;
    TimerAction.update(dt);
  end
  ,'__class__',  systems.Trigger
)
systems.Trigger.__super__ = System
setmetatable(systems.Trigger.prototype,{__index=System.prototype})

systems.WeatherSystem.new = function() 
  local self = _hx_new(systems.WeatherSystem.prototype)
  systems.WeatherSystem.super(self)
  return self
end
systems.WeatherSystem.super = function(self) 
  self.rng = love.math.newRandomGenerator();
  self.now = 0.0;
  self.cloud_count = 50;
  self.cloud_parts = _hx_tab_array({ }, 0);
  self.cloud_tiles = _hx_tab_array({ }, 0);
  System.super(self);
  self.canvas = love.graphics.newCanvas(512,512,"rgba8",4);
  local n = World.tiles_x * World.tiles_y;
  local div = (World.tiles_x + World.tiles_y) / 2;
  local _g1 = 0;
  local _g = n;
  while (_g1 < _g) do 
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    local x = _G.math.fmod(i, World.tiles_x);
    local y = Std.int(i / World.tiles_x);
    local x1 = love.math.noise(x / div,y / div);
    local y1 = 1 - love.math.noise(x / div,y / div);
    local this1;
    local this2 = ({length = 2});
    this1 = this2;
    this1[0] = x1;
    this1[1] = y1;
    local dir = this1;
    if (math._Vec2.Vec2_Impl_.length(dir) > 1) then 
      math._Vec2.Vec2_Impl_.normalize(dir);
    end;
    dir = math._Vec2.Vec2_Impl_.scale(dir,2.);
    local tmp = self.cloud_tiles;
    local _self = dir;
    local this3;
    local this4 = ({length = 2});
    this3 = this4;
    this3[0] = _self[0];
    this3[1] = _self[1];
    tmp:push(_hx_o({__fields__={rain=true,wind=true},rain=0.0,wind=this3}));
    end;
  self:spawn(self.cloud_count);
end
systems.WeatherSystem.__name__ = {"systems","WeatherSystem"}
systems.WeatherSystem.prototype = _hx_a(
  'spawn', function(self,n) 
    local lifetime_variance = 10.0;
    local _g1 = 0;
    local _g = n;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      local tmp = self.cloud_parts;
      local x = self.rng:random(World.tiles_x);
      local y = self.rng:random(World.tiles_y);
      local this1;
      local this2 = ({length = 2});
      this1 = this2;
      this1[0] = x;
      this1[1] = y;
      tmp:push(_hx_o({__fields__={position=true,last_update=true,age=true},position=this1,last_update=self.now,age=self.rng:random(lifetime_variance)}));
      end;
  end,
  'filter', function(self,e) 
    do return false end
  end,
  'update', function(self,entities,dt) 
    local _gthis = self;
    local tmp = self;
    tmp.now = tmp.now + dt;
    do return end
  end
  ,'__class__',  systems.WeatherSystem
)
systems.WeatherSystem.__super__ = System
setmetatable(systems.WeatherSystem.prototype,{__index=System.prototype})

ui.Anchor.new = {}
ui.Anchor.__name__ = {"ui","Anchor"}
ui.Anchor.update = function(wnd) 
  local size = wnd:get_framebuffer_size();
  ui.Anchor._width = size.width;
  ui.Anchor._height = size.height;
  ui.Anchor.padding_left = _G.math.floor(ui.Anchor._width * (ui.Anchor.overscan / 2));
  ui.Anchor.padding_right = ui.Anchor.padding_left;
  ui.Anchor.padding_top = _G.math.floor(ui.Anchor._height * (ui.Anchor.overscan / 2));
  ui.Anchor.padding_bottom = ui.Anchor.padding_top;
end
ui.Anchor.get_bottom = function() 
  do return Std.int((ui.Anchor._height + ui.Anchor.y_offset) - ui.Anchor.padding_bottom) end;
end
ui.Anchor.get_left = function() 
  do return Std.int(ui.Anchor.x_offset + ui.Anchor.padding_left) end;
end
ui.Anchor.get_right = function() 
  do return Std.int((ui.Anchor._width + ui.Anchor.x_offset) - ui.Anchor.padding_right) end;
end

ui.Helpers.new = {}
ui.Helpers.__name__ = {"ui","Helpers"}
ui.Helpers.setup_imgui = function() 
  local scale = 1.0;
  if (_G.select(2, love.getVersion()) == 10) then 
    scale = love.window.getPixelScale();
  end;
  imgui.ImGui.SetGlobalFontFromFileTTF("assets/fonts/NotoSans-Regular.ttf",16 * scale,0,0,2,2);
  imgui.Style.PushStyleColor("Text",1.00,1.00,1.00,1.00);
  imgui.Style.PushStyleColor("WindowBg",0.07,0.07,0.08,0.98);
  imgui.Style.PushStyleColor("PopupBg",0.07,0.07,0.08,0.98);
  imgui.Style.PushStyleColor("CheckMark",0.15,1.0,0.4,0.91);
  imgui.Style.PushStyleColor("Border",0.70,0.70,0.70,0.20);
  imgui.Style.PushStyleColor("FrameBg",0.80,0.80,0.80,0.12);
  imgui.Style.PushStyleColor("FrameBgHovered",0.04,0.50,0.78,1.00);
  imgui.Style.PushStyleColor("FrameBgActive",0.15,0.52,0.43,1.00);
  imgui.Style.PushStyleColor("TitleBg",0.15,0.52,0.43,0.76);
  imgui.Style.PushStyleColor("TitleBgCollapsed",0.11,0.22,0.23,0.50);
  imgui.Style.PushStyleColor("TitleBgActive",0.15,0.52,0.43,1.00);
  imgui.Style.PushStyleColor("MenuBarBg",0.07,0.07,0.11,0.76);
  imgui.Style.PushStyleColor("ScrollbarBg",0.26,0.29,0.33,1.00);
  imgui.Style.PushStyleColor("ScrollbarGrab",0.40,0.43,0.47,0.76);
  imgui.Style.PushStyleColor("ScrollbarGrabHovered",0.28,0.81,0.68,0.76);
  imgui.Style.PushStyleColor("ScrollbarGrabActive",0.96,0.66,0.06,1.00);
  imgui.Style.PushStyleColor("SliderGrab",0.28,0.81,0.68,0.47);
  imgui.Style.PushStyleColor("SliderGrabActive",0.96,0.66,0.06,0.76);
  imgui.Style.PushStyleColor("Button",0.22,0.74,0.61,0.47);
  imgui.Style.PushStyleColor("ButtonHovered",0.00,0.48,1.00,1.00);
  imgui.Style.PushStyleColor("ButtonActive",0.83,0.57,0.04,0.76);
  imgui.Style.PushStyleColor("Header",0.22,0.74,0.61,0.47);
  imgui.Style.PushStyleColor("HeaderHovered",0.07,0.51,0.92,0.76);
  imgui.Style.PushStyleColor("HeaderActive",0.96,0.66,0.06,0.76);
  imgui.Style.PushStyleColor("Column",0.22,0.74,0.61,0.47);
  imgui.Style.PushStyleColor("ColumnHovered",0.28,0.81,0.68,0.76);
  imgui.Style.PushStyleColor("ColumnActive",0.96,0.66,0.06,1.00);
  imgui.Style.PushStyleColor("ResizeGrip",0.22,0.74,0.61,0.47);
  imgui.Style.PushStyleColor("ResizeGripHovered",0.28,0.81,0.68,0.76);
  imgui.Style.PushStyleColor("ResizeGripActive",0.96,0.66,0.06,0.76);
  imgui.Style.PushStyleColor("CloseButton",0.00,0.00,0.00,0.47);
  imgui.Style.PushStyleColor("CloseButtonHovered",0.00,0.00,0.00,0.76);
  imgui.Style.PushStyleColor("PlotLinesHovered",0.22,0.74,0.61,1.00);
  imgui.Style.PushStyleColor("PlotHistogram",0.15,0.52,0.43,1.00);
  imgui.Style.PushStyleColor("PlotHistogramHovered",0.96,0.66,0.06,1.00);
  imgui.Style.PushStyleColor("TextSelectedBg",0.22,0.74,0.61,0.47);
  imgui.Style.PushStyleColor("ModalWindowDarkening",0.20,0.20,0.20,0.69);
  imgui.ImGui.NewFrame();
end
ui.Helpers.drag_vec3 = function(label,v,enabled,speed,min,max) 
  if (max == nil) then 
    max = 9999;
  end;
  if (min == nil) then 
    min = -9999;
  end;
  if (speed == nil) then 
    speed = 0.1;
  end;
  if (enabled == nil) then 
    enabled = true;
  end;
  local _hx_1_r_status, _hx_1_r_f1, _hx_1_r_f2, _hx_1_r_f3 = imgui.Widget.DragFloat3(label,v[1],v[2],v[3],speed,min,max);
  if (not enabled) then 
    do return end;
  end;
  v[1] = _hx_1_r_f1;
  v[2] = _hx_1_r_f2;
  v[3] = _hx_1_r_f3;
end
ui.Helpers.input_quat = function(label,q,enabled) 
  if (enabled == nil) then 
    enabled = true;
  end;
  local eul = math._Quat.Quat_Impl_.to_euler(q);
  local _hx_1_result_status, _hx_1_result_f1, _hx_1_result_f2, _hx_1_result_f3 = imgui.Widget.DragFloat3(label,_G.math.deg(eul[1]),_G.math.deg(eul[2]),_G.math.deg(eul[3]),0.5,-180,180);
  if (not enabled) then 
    do return end;
  end;
  eul[1] = _G.math.rad(_hx_1_result_f1);
  eul[2] = _G.math.rad(_hx_1_result_f2);
  eul[3] = _G.math.rad(_hx_1_result_f3);
  local tmp = math._Quat.Quat_Impl_.from_euler(eul);
  local _g = 0;
  while (_g < 4) do 
    _g = _g + 1;
    local i = _g - 1;
    local v = tmp[i];
    q[i] = v;
    end;
end

ui.LogWindow.new = {}
ui.LogWindow.__name__ = {"ui","LogWindow"}
ui.LogWindow.draw = function() 
  GameInput.bind(Action.Debug_F2,function() 
    Main.toggle_window(WindowType.Log);
    do return true end;
  end);
  if (not Main.showing_menu(WindowType.Log)) then 
    do return end;
  end;
  imgui.Window.SetNextWindowSize(550,350);
  if (imgui.Window.Begin("Log")) then 
    local _g = 0;
    local _g1 = ui.LogWindow.messages;
    while (_g < _g1.length) do 
      local msg = _g1[_g];
      _g = _g + 1;
      imgui.Widget.TextWrapped(msg);
      end;
    imgui.Widget.SetScrollHere(1.0);
  end;
  imgui.Window.End();
end

ui.MainMenu.new = {}
ui.MainMenu.__name__ = {"ui","MainMenu"}
ui.MainMenu.draw = function() 
  Main.editing = Main.showing_menu(WindowType.EditorUI);
  if (not love.mouse.getRelativeMode() or Main.editing) then 
    if (imgui.MenuBar.BeginMainMenuBar()) then 
      if (imgui.MenuBar.BeginMenu("File")) then 
        if (imgui.MenuBar.MenuItem("Load Game")) then 
          Main.player:load();
        end;
        if (imgui.MenuBar.MenuItem("Save Game")) then 
          Main.player:save();
        end;
        imgui.Widget.Separator();
        if (imgui.MenuBar.MenuItem("Reload Map")) then 
          World.reload();
          Main.respawn();
        end;
        if (imgui.MenuBar.MenuItem("Save Map")) then 
          World.save();
        end;
        imgui.Widget.Separator();
        if (imgui.MenuBar.MenuItem("Exit")) then 
          love.event.quit();
        end;
        imgui.MenuBar.EndMenu();
      end;
      if (imgui.MenuBar.BeginMenu("Debug")) then 
        if (imgui.MenuBar.BeginMenu("Player")) then 
          if (imgui.MenuBar.MenuItem("Respawn")) then 
            Main.respawn();
          end;
          imgui.MenuBar.EndMenu();
        end;
        imgui.MenuBar.EndMenu();
      end;
      if (imgui.MenuBar.BeginMenu("Window")) then 
        imgui.Widget.Separator();
        if (imgui.MenuBar.MenuItem("Camera...")) then 
          Main.toggle_window(WindowType.CameraDebug);
        end;
        if (imgui.MenuBar.MenuItem("Editor...","F1")) then 
          Main.toggle_window(WindowType.EditorUI);
        end;
        if (imgui.MenuBar.MenuItem("Profiler...","F3")) then 
          Main.toggle_window(WindowType.ProfilerUI);
        end;
        if (imgui.MenuBar.MenuItem("Log...")) then 
          Main.toggle_window(WindowType.Log);
        end;
        imgui.MenuBar.EndMenu();
      end;
    end;
    imgui.MenuBar.EndMainMenuBar();
  end;
end

utils.AssertionFailure.new = function(message,parts,user_msg) 
  local self = _hx_new(utils.AssertionFailure.prototype)
  utils.AssertionFailure.super(self,message,parts,user_msg)
  return self
end
utils.AssertionFailure.super = function(self,message,parts,user_msg) 
  self.message = message;
  if (user_msg ~= nil) then 
    self.message = "" .. user_msg .. "\n" .. self.message;
  end;
  self.parts = parts;
end
utils.AssertionFailure.__name__ = {"utils","AssertionFailure"}
utils.AssertionFailure.prototype = _hx_a(
  'toString', function(self) 
    local buf_length;
    local buf_b = _hx_e();
    buf_length = 0;
    local str = Std.string("Assertion failure: " .. self.message);
    _G.table.insert(buf_b,str);
    buf_length = buf_length + str.length;
    local _g = 0;
    local _g1 = self.parts;
    while (_g < _g1.length) do 
      local part = _g1[_g];
      _g = _g + 1;
      local str1 = Std.string("\n\t" .. part.expr .. ": " .. Std.string(part.value));
      _G.table.insert(buf_b,str1);
      buf_length = buf_length + str1.length;
      end;
    do return _G.table.concat(buf_b) end
  end
  ,'__class__',  utils.AssertionFailure
)

utils.CacheResource.new = function(load_cb) 
  local self = _hx_new(utils.CacheResource.prototype)
  utils.CacheResource.super(self,load_cb)
  return self
end
utils.CacheResource.super = function(self,load_cb) 
  self.loader = _hx_funcToField(load_cb);
  self:clear();
end
utils.CacheResource.__name__ = {"utils","CacheResource"}
utils.CacheResource.prototype = _hx_a(
  'load', function(self,filename,options) 
    local this1 = self.ignore;
    if ((this1.k[filename] or false)) then 
      do return nil end;
    end;
    local this2 = self.storage;
    if ((this2.k[filename] or false)) then 
      local this3 = self.storage;
      do return this3.v[filename] end;
    end;
    local res = self:loader(filename,options);
    if (res == nil) then 
      local _this = self.ignore;
      _this.v[filename] = true;
      _this.k[filename] = true;
      local _tmp0 = res;
      local _tmp1 = _tmp0 ~= nil;
      if (not _tmp1) then 
        _G.error(utils.AssertionFailure.new("res != null",_hx_tab_array({[0]=_hx_o({__fields__={expr=true,value=true},expr="res",value=_tmp0}), _hx_o({__fields__={expr=true,value=true},expr="res != null",value=_tmp1}) }, 2),"Unable to load resource \"$filename\""),0);
      end;
      do return nil end;
    end;
    local _this1 = self.storage;
    _this1.v[filename] = res;
    _this1.k[filename] = true;
    do return res end
  end,
  'clear', function(self) 
    self.storage = haxe.ds.StringMap.new();
    self.ignore = haxe.ds.StringMap.new();
  end
  ,'__class__',  utils.CacheResource
)
_hx_bit_clamp = function(v) 
  if v <= 2147483647 and v >= -2147483648 then
    if v > 0 then return _G.math.floor(v)
    else return _G.math.ceil(v)
    end
  end
  if v > 2251798999999999 then v = v*2 end;
  if (v ~= v or math.abs(v) == _G.math.huge) then return nil end
  return _hx_bit.band(v, 2147483647 ) - math.abs(_hx_bit.band(v, 2147483648))
end
pcall(require, 'bit')
if bit then
  _hx_bit = bit
elseif bit32 then
  local _hx_bit_raw = bit32
  _hx_bit = setmetatable({}, { __index = _hx_bit_raw });
  _hx_bit.bnot = function(...) return _hx_bit_clamp(_hx_bit_raw.bnot(...)) end;
  _hx_bit.bxor = function(...) return _hx_bit_clamp(_hx_bit_raw.bxor(...)) end;
end
local _hx_string_mt = _G.getmetatable('');
String.__oldindex = _hx_string_mt.__index;
_hx_string_mt.__index = String.__index;
_hx_string_mt.__add = function(a,b) return Std.string(a)..Std.string(b) end;
_hx_string_mt.__concat = _hx_string_mt.__add
_hx_array_mt.__index = Array.prototype

local _hx_static_init = function()
  Debug.vertices = _hx_tab_array({ }, 0)
  Debug.capsule_queue = _hx_tab_array({ }, 0)
  Debug.cube_indices = _hx_tab_array({[0]=0, 4, 1, 5, 2, 6, 3, 7, 0, 1, 0, 3, 2, 3, 2, 1, 4, 5, 4, 7, 6, 7, 6, 5 }, 24)
  GameInput.callbacks = haxe.ds.EnumValueMap.new()
  GameInput.active = _hx_tab_array({ }, 0)
  GameInput.kb_mappings = (function() 
    local _hx_1
    
    local _g = haxe.ds.StringMap.new();
    
    _g:set("w",_hx_o({__fields__={player=true,menu=true},player=Action.YLup,menu=Action.MenuUp}));
    
    _g:set("s",_hx_o({__fields__={player=true,menu=true},player=Action.YLdown,menu=Action.MenuDown}));
    
    _g:set("a",_hx_o({__fields__={player=true,menu=true},player=Action.XLleft,menu=Action.MenuLeft}));
    
    _g:set("d",_hx_o({__fields__={player=true,menu=true},player=Action.XLright,menu=Action.MenuRight}));
    
    _g:set("up",_hx_o({__fields__={player=true,menu=true},player=Action.YLup,menu=Action.MenuUp}));
    
    _g:set("down",_hx_o({__fields__={player=true,menu=true},player=Action.YLdown,menu=Action.MenuDown}));
    
    _g:set("left",_hx_o({__fields__={player=true,menu=true},player=Action.XLleft,menu=Action.MenuLeft}));
    
    _g:set("right",_hx_o({__fields__={player=true,menu=true},player=Action.XLright,menu=Action.MenuRight}));
    
    _g:set("kp8",_hx_o({__fields__={player=true,menu=true},player=Action.YRup,menu=Action.MenuUp}));
    
    _g:set("kp2",_hx_o({__fields__={player=true,menu=true},player=Action.YRdown,menu=Action.MenuDown}));
    
    _g:set("kp4",_hx_o({__fields__={player=true,menu=true},player=Action.XRleft,menu=Action.MenuLeft}));
    
    _g:set("kp6",_hx_o({__fields__={player=true,menu=true},player=Action.XRright,menu=Action.MenuRight}));
    
    _g:set("lctrl",_hx_o({__fields__={player=true,menu=true},player=Action.TrickA,menu=nil}));
    
    _g:set("lshift",_hx_o({__fields__={player=true,menu=true},player=Action.TrickB,menu=nil}));
    
    _g:set("rctrl",_hx_o({__fields__={player=true,menu=true},player=Action.TrickA,menu=nil}));
    
    _g:set("rshift",_hx_o({__fields__={player=true,menu=true},player=Action.TrickB,menu=nil}));
    
    _g:set("space",_hx_o({__fields__={player=true,menu=true},player=Action.Jump,menu=nil}));
    
    _g:set("kp0",_hx_o({__fields__={player=true,menu=true},player=Action.Jump,menu=nil}));
    
    _g:set("return",_hx_o({__fields__={player=true,menu=true},player=nil,menu=Action.MenuConfirm}));
    
    _g:set("escape",_hx_o({__fields__={player=true,menu=true},player=Action.MenuCancel,menu=Action.MenuCancel}));
    
    _g:set("backspace",_hx_o({__fields__={player=true,menu=true},player=nil,menu=Action.MenuCancel}));
    
    _hx_1 = _g;
    return _hx_1
  end )()
  GameInput.gp_mappings = (function() 
    local _hx_2
    
    local _g = haxe.ds.StringMap.new();
    
    _g:set("a",_hx_o({__fields__={player=true,menu=true},player=Action.Jump,menu=Action.MenuConfirm}));
    
    _g:set("b",_hx_o({__fields__={player=true,menu=true},player=nil,menu=Action.MenuCancel}));
    
    _g:set("x",_hx_o({__fields__={player=true,menu=true},player=Action.TrickA,menu=nil}));
    
    _g:set("y",_hx_o({__fields__={player=true,menu=true},player=Action.TrickB,menu=nil}));
    
    _g:set("leftshoulder",_hx_o({__fields__={player=true,menu=true},player=Action.CameraReverse,menu=Action.MenuPrev}));
    
    _g:set("rightshoulder",_hx_o({__fields__={player=true,menu=true},player=Action.CameraRecenter,menu=Action.MenuNext}));
    
    _g:set("leftstick",_hx_o({__fields__={player=true,menu=true},player=Action.Walk,menu=nil}));
    
    _g:set("start",_hx_o({__fields__={player=true,menu=true},player=Action.MenuToggle,menu=Action.MenuToggle}));
    
    _g:set("back",_hx_o({__fields__={player=true,menu=true},player=nil,menu=Action.MenuCancel}));
    
    _hx_2 = _g;
    return _hx_2
  end )()
  GameInput.input_state = haxe.ds.EnumValueMap.new()
  GameInput.gp_raw_axes = (function() 
    local _hx_3
    
    local _g = haxe.ds.StringMap.new();
    
    _g:set("leftx",0.0);
    
    _g:set("lefty",0.0);
    
    _g:set("rightx",0.0);
    
    _g:set("righty",0.0);
    
    _g:set("triggerleft",0.0);
    
    _g:set("triggerright",0.0);
    
    _hx_3 = _g;
    return _hx_3
  end )()
  Language.data = i18n.I18n.new()
  Main.open_windows = _hx_tab_array({[0]=WindowType.EditorUI }, 1)
  Main.editing = false
  Main.show_profiler = false
  Main.has_focus = true
  Main.dt = 0
  _Profiler.SegmentColor_Impl_.Render = (function() 
    local _hx_4
    
    local this1 = math._Vec3.Vec3_Impl_._new(1.0,0.0,0.0);
    
    _hx_4 = this1;
    return _hx_4
  end )()
  _Profiler.SegmentColor_Impl_.Default = (function() 
    local _hx_5
    
    local this1 = math._Vec3.Vec3_Impl_._new(0.0,0.5,1.0);
    
    _hx_5 = this1;
    return _hx_5
  end )()
  _Profiler.SegmentColor_Impl_.Player = (function() 
    local _hx_6
    
    local this1 = math._Vec3.Vec3_Impl_._new(1.0,0.5,0.0);
    
    _hx_6 = this1;
    return _hx_6
  end )()
  _Profiler.SegmentColor_Impl_.World = (function() 
    local _hx_7
    
    local this1 = math._Vec3.Vec3_Impl_._new(0.25,0.5,0.25);
    
    _hx_7 = this1;
    return _hx_7
  end )()
  Profiler.time_stack = haxe.ds.GenericStack.new()
  Profiler.this_frame = _hx_o({__fields__={data=true,start=true,duration=true,fps=true,delta=true,memory=true},data=_hx_tab_array({ }, 0),start=0.0,duration=0.0,fps=0.0,delta=0.0,memory=0.0})
  Profiler.frame_history = _hx_tab_array({ }, 0)
  Profiler.sample_rate = 0.033333333333333333
  Profiler.history_length = Std.int((1 / Profiler.sample_rate) * 5)
  Profiler.last_update = -1.0
  Profiler.slowest = haxe.ds.StringMap.new()
  Profiler.fastest = haxe.ds.StringMap.new()
  Profiler.first_update = 0
  Signal.signals = haxe.ds.StringMap.new()
  GameTime.SEASON_INFLUENCE = 0.5
  GameTime.TIME_SCALE = 1.0
  GameTime.day = 1
  TimerAction.timers = _hx_tab_array({ }, 0)
  TimerScript.routines = _hx_tab_array({ }, 0)
  WorldTile.octree_looseness = 1.0
  World.path = "assets/maps/world.fresh"
  World.is_local_map = false
  World.kill_z = -21
  World.tiles_x = 10
  World.tiles_y = 5
  World.tile_size = 100
  World.visible_tiles = _hx_tab_array({ }, 0)
  World.borked = _hx_tab_array({ }, 0)
  World.time = 0
  World.tickrate = 0.0083333333333333332
  Zone.map_version = 1
  Zone.HEIGHTMAP_TILE = "<heightmap>"
  collision.Response.VERY_CLOSE_DIST = 0.0005
  editor.Editor.running = true
  editor.Editor.show_select_drawable = false
  editor.Editor.selected_item = ""
  editor.EntityList.available_entities = _hx_tab_array({ }, 0)
  editor.HeightmapTerrain.HEIGHT_SCALE = 25
  editor.Panel.panels = _hx_tab_array({ }, 0)
  editor.Prefab.group = _hx_tab_array({ }, 0)
  editor.Prefab.tmp_filename = ""
  editor.Prefab.keep_positions = false
  editor.Prefab.BASE_DIRECTORY = "assets/prefabs/"
  editor.Prefab.FILE_SUFFIX = ".fab"
  editor.Prefab.FILE_TILE_SUFFIX = ".tile.fab"
  lua.Boot.hiddenFields = {__id__=true, hx__closures=true, super=true, prototype=true, __fields__=true, __ifields__=true, __class__=true, __properties__=true}
  math.Intersect.EPSILON = 1.19209290e-07
  render.Grass.scale_samples = false
  systems.Hud.layers = _hx_tab_array({ }, 0)
  systems.Hud.subtitle_queue = _hx_tab_array({ }, 0)
  systems.Hud.subtitle_active = false
  systems.Hud.subtitle_opacity = 0
  systems.PlayerController.follow_camera = false
  systems.PlayerController.follow_real = systems.PlayerController.follow_camera
  systems.PlayerController.mx = 0
  systems.PlayerController.my = 0
  systems.PlayerController.now = 0
  systems.Render.r = 7.0
  systems.Render.g = 14.0
  systems.Render.b = 16.0
  systems.Render.exposure = 1.5
  systems.Render.vignette = 0.75
  systems.Render.ab = false
  systems.Render.wire_mode = false
  systems.Render.game_aa = 4
  systems.Render.grass_enabled = false
  systems.Render.grass_range = 50
  systems.Render.grass_density = 1.5
  systems.Render.grass_seed = 50
  systems.Render.instances = _hx_tab_array({ }, 0)
  systems.Render.clouds = (function() 
    local _hx_8
    
    local _g = _hx_tab_array({ }, 0);
    
    local _g2 = 0;
    local _g1 = World.tiles_x * World.tiles_y;
    while (_g2 < _g1) do 
      _g2 = _g2 + 1;
      local i = _g2 - 1;
      _g:push(_hx_o({__fields__={rain=true},rain=0.0}));
      end;
    
    _hx_8 = _g;
    return _hx_8
  end )()
  systems.Render.activate_game = false
  systems.Render.now = 0.0
  ui.Anchor.x_offset = 0
  ui.Anchor.y_offset = 0
  ui.Anchor.padding_left = 0
  ui.Anchor.padding_right = 0
  ui.Anchor.padding_top = 0
  ui.Anchor.padding_bottom = 0
  ui.Anchor.overscan = 0.1
  ui.LogWindow.messages = _hx_tab_array({ }, 0)
  
  String.prototype.__class__ = String;
  String.__name__ = ({"String"});
  Array.__name__ = ({"Array"});
end

_hx_bind = function(o,m)
  if m == nil then return nil end;
  local f;
  if o._hx__closures == nil then
    _G.rawset(o, '_hx__closures', {});
  else 
    f = o._hx__closures[m];
  end
  if (f == nil) then
    f = function(...) return m(o, ...) end;
    o._hx__closures[m] = f;
  end
  return f;
end
_hx_funcToField = function(f)
  if type(f) == 'function' then 
    return function(self,...) 
      return f(...) 
    end
  else 
    return f
  end
end
_G.math.randomseed(_G.os.time());
_hx_print = print or (function() end)
_hx_box_mr = function(x,nt)
   res = _hx_o({__fields__={}})
   for i,v in ipairs(nt) do
     res[v] = x[i]
   end
   return res
end
_hx_table = {}
_hx_table.pack = _G.table.pack or function(...)
    return {...}
end
_hx_table.unpack = _G.table.unpack or _G.unpack
_hx_table.maxn = _G.table.maxn or function(t)
  local maxn=0;
  for i in pairs(t) do
    maxn=type(i)=='number'and i>maxn and i or maxn
  end
  return maxn
end;
_hx_static_init();
Main.main()
return _hx_exports
